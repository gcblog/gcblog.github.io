<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code随手记</title>
  <subtitle>Practice from here</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gcblog/github.io/"/>
  <updated>2018-05-04T03:47:16.408Z</updated>
  <id>http://gcblog/github.io/</id>
  
  <author>
    <name>夜千寻墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>slice</title>
    <link href="http://gcblog/github.io/2018/05/04/slice/"/>
    <id>http://gcblog/github.io/2018/05/04/slice/</id>
    <published>2018-05-04T03:45:23.000Z</published>
    <updated>2018-05-04T03:47:16.408Z</updated>
    
    <content type="html"><![CDATA[<p>切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。</p>
<h3 id="slice声明和创建"><a href="#slice声明和创建" class="headerlink" title="slice声明和创建"></a>slice声明和创建</h3><p>slice 本身不是数组，它指向数组的底层<br>作为变长数组饿替代方案，可以关联底层数组的全部或者局部<br>可以直接创建，一般用make(), 也可以从底层数组获取生成<br>如果多个slice 指向相同的底层数组，一个值的改变会影响全部</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">func sliceCreate() &#123;</div><div class="line"></div><div class="line">	//声明 slice 如果只是声明，只有指针初始地址，容量为0</div><div class="line">	var slice1 []int</div><div class="line"></div><div class="line">	fmt.Printf(&quot;slice1  %p\n&quot;, slice1)</div><div class="line"></div><div class="line">	//添加元素后，容量超出上限，内存地址重新分配</div><div class="line">	slice1 = []int&#123;1, 2, 3&#125;</div><div class="line"></div><div class="line">	fmt.Printf(&quot;slice1  %p\n&quot;, slice1)</div><div class="line"></div><div class="line">	//声明并赋值</div><div class="line"></div><div class="line">	var s2 = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class="line">	fmt.Println(s2)</div><div class="line"></div><div class="line">	var arr = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</div><div class="line">	fmt.Print(&quot;s2  \n&quot;, arr)</div><div class="line"></div><div class="line">	// 取第二个元素</div><div class="line">	slice2 := arr[1]</div><div class="line">	fmt.Println(slice2)</div><div class="line"></div><div class="line">	//取第5到10个元素</div><div class="line">	slice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间</div><div class="line">	fmt.Println(slice3)</div><div class="line"></div><div class="line">	//从第5个元素取到最后  的两种写法</div><div class="line">	slice4 := arr[5:len(arr)]</div><div class="line">	slice5 := arr[5:]</div><div class="line">	fmt.Println(slice4, slice5)</div><div class="line"></div><div class="line">	//取前5个元素</div><div class="line">	slice6 := arr[:5]</div><div class="line">	fmt.Print(&quot;\n&quot;, slice6)</div><div class="line"></div><div class="line">	//使用make 创建slice</div><div class="line">	//存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍</div><div class="line">	// 如果不给初始容量，默认的初始容量就是当前元素个数</div><div class="line">	s1 := make([]int, 3, 10)</div><div class="line">	fmt.Print(&quot;\n&quot;, len(s1), cap(s1))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">slice1  0x0</div><div class="line">slice1  0xc4200182c0</div><div class="line">[a b c]</div><div class="line">s2  </div><div class="line">[0 1 2 3 4 5 6 7 8 9]1</div><div class="line">[5 6 7 8 9]</div><div class="line">[5 6 7 8 9] [5 6 7 8 9]</div><div class="line"></div><div class="line">[0 1 2 3 4]</div><div class="line">3 10</div></pre></td></tr></table></figure>
<h3 id="ReSlice"><a href="#ReSlice" class="headerlink" title="ReSlice"></a>ReSlice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func ResliceTest() &#123;</div><div class="line">	</div><div class="line">	// reslice索引 以 被slice 为准</div><div class="line">	// 索引不可以超过cap值</div><div class="line"></div><div class="line">	var a = []byte&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;&#125;</div><div class="line"></div><div class="line">	// 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间</div><div class="line">	//取出 cde</div><div class="line">	var s1 = a[2:5]</div><div class="line">	fmt.Println(string(s1))</div><div class="line">	fmt.Println(len(s1), cap(s1))</div><div class="line"></div><div class="line">	//从 s1中取出de</div><div class="line">	var s2 = s1[1:3]</div><div class="line">	fmt.Print(&quot;\n&quot;, string(s2))</div><div class="line"></div><div class="line">	// 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾</div><div class="line"></div><div class="line">	var s3 = s1[0:cap(s1)]</div><div class="line">	fmt.Print(&quot;\n s3 = &quot;, string(s3))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cde</div><div class="line">3 6</div><div class="line"></div><div class="line">de</div><div class="line"> s3 = cdefgh</div></pre></td></tr></table></figure>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>可以在slice尾部追加元素<br>可以将一个slice追加到另一个slice<br>slice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func appendTest() &#123;</div><div class="line"></div><div class="line">	s1 := make([]int, 3, 6)</div><div class="line">	fmt.Printf(&quot;%p\n&quot;, s1)</div><div class="line"></div><div class="line">	s1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变</div><div class="line">	fmt.Printf(&quot;%v---%p\n&quot;, s1, s1)</div><div class="line"></div><div class="line">	s1 = append(s1, 9) //超出容量，内存地址改变</div><div class="line">	fmt.Printf(&quot;%v %p\n&quot;, s1, s1)</div><div class="line"></div><div class="line">	var arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class="line">	var slice2 = arr[2:5] //3, 4, 5</div><div class="line">	var slice3 = arr[1:3] //2, 3</div><div class="line"></div><div class="line">	fmt.Println(slice2, slice3) //重叠部分是3</div><div class="line"></div><div class="line">	slice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变</div><div class="line">	fmt.Println(arr, slice2, slice3)</div><div class="line"></div><div class="line">	slice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变</div><div class="line">	fmt.Println(slice3)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0xc42001c0c0</div><div class="line">[0 0 0 1 2 3]---0xc42001c0c0</div><div class="line">[0 0 0 1 2 3 9] 0xc420078060</div><div class="line">[3 4 5] [2 3]</div><div class="line">[1 2 9 4 5] [9 4 5] [2 9]</div><div class="line">[2 9 1 2 2 2 2 2]</div></pre></td></tr></table></figure>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func copyTest() &#123;</div><div class="line"></div><div class="line">	//copy 会把重叠部分的元素给覆盖</div><div class="line">	var s1 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class="line">	var s2 = []int&#123;7, 8, 9&#125;</div><div class="line">	// 短的copy到长的情况</div><div class="line">	copy(s1, s2) //把s2 copy 到s1 中</div><div class="line">	fmt.Println(&quot;s1---&quot;, s1)</div><div class="line"></div><div class="line">	// 长的copy到短的情况</div><div class="line">	var s3 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class="line">	var s4 = []int&#123;7, 8, 9&#125;</div><div class="line">	copy(s4, s3)</div><div class="line">	fmt.Println(&quot;s4---&quot;, s4)</div><div class="line"></div><div class="line">	var s5 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class="line">	var s6 = []int&#123;7, 8, 9&#125;</div><div class="line">	//将制定元素copy到指定位置</div><div class="line">	copy(s5[2:4], s6[1:3])</div><div class="line">	fmt.Println(&quot;s5---&quot;, s5)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s1--- [7 8 9 4 5 6 7]</div><div class="line">s4--- [1 2 3]</div><div class="line">s5--- [1 2 8 9 5 6 7]</div></pre></td></tr></table></figure>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>go官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func sliceDelete() &#123;</div><div class="line"></div><div class="line">	var slice = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;</div><div class="line"></div><div class="line">	fmt.Println(removeString(slice, 2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//删除函数</div><div class="line">func removeString(s []string, i int) []string &#123;</div><div class="line"></div><div class="line">	return append(s[:i], s[i+1:]...)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[a b d]</div></pre></td></tr></table></figure>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>官方还是没有提供插入的方法，需要自己实现，如果用<code>append</code>实现，<code>append</code>每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现<br>这里需要引入<code>reflect</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func silceInsert() &#123;</div><div class="line"></div><div class="line">	a := []int&#123;1, 2, 3, 4, 5&#125;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(&quot;插入元素后&quot;, Insert(a, 3, 0))</div><div class="line"></div><div class="line">	b := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(&quot;插入元素后&quot;, Insert(b, 3, &quot;x&quot;))</div><div class="line"></div><div class="line">	c := []interface&#123;&#125;&#123;1, &quot;a&quot;, true, 3.2, &apos;a&apos;&#125;</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(&quot;插入元素后&quot;, Insert(c, 3, false))</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func Insert(slice interface&#123;&#125;, pos int, value interface&#123;&#125;) interface&#123;&#125; &#123;</div><div class="line">	v := reflect.ValueOf(slice)</div><div class="line">	v = reflect.Append(v, reflect.ValueOf(value))</div><div class="line">	reflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len()))</div><div class="line">	v.Index(pos).Set(reflect.ValueOf(value))</div><div class="line">	return v.Interface()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1 2 3 4 5]</div><div class="line">插入元素后 [1 2 3 0 4 5]</div><div class="line">[a b c d e]</div><div class="line">插入元素后 [a b c x d e]</div><div class="line">[1 a true 3.2 97]</div><div class="line">插入元素后 [1 a true false 3.2 97]</div></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入<code>sort</code></p>
<h4 id="升序排序"><a href="#升序排序" class="headerlink" title="升序排序"></a>升序排序</h4><p>对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func sliceSort() &#123;</div><div class="line"></div><div class="line">	intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class="line">	float8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class="line">	stringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class="line"></div><div class="line">	sort.Ints(intList)</div><div class="line">	sort.Float64s(float8List)</div><div class="line">	sort.Strings(stringList)</div><div class="line"></div><div class="line">	fmt.Printf(&quot;%v\n%v\n%v\n&quot;, intList, float8List, stringList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[0 1 2 3 4 5 6 7 8 9]</div><div class="line">[3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9]</div><div class="line">[a b c d f i w x y z]</div></pre></td></tr></table></figure>
<h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p>int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。</p>
<p>go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func sliceSort2() &#123;</div><div class="line">	intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class="line">	float8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class="line">	stringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class="line"></div><div class="line">	sort.Sort(sort.Reverse(sort.IntSlice(intList)))</div><div class="line">	sort.Sort(sort.Reverse(sort.Float64Slice(float8List)))</div><div class="line">	sort.Sort(sort.Reverse(sort.StringSlice(stringList)))</div><div class="line"></div><div class="line">	fmt.Printf(&quot;%v\n%v\n%v\n&quot;, intList, float8List, stringList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[9 8 7 6 5 4 3 2 1 0]</div><div class="line">[99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14]</div><div class="line">[z y x w i f d c b a]</div></pre></td></tr></table></figure>
<h4 id="结构体类型的排序"><a href="#结构体类型的排序" class="headerlink" title="结构体类型的排序"></a>结构体类型的排序</h4><p>结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。</p>
<h5 id="1、模拟-IntSlice-排序"><a href="#1、模拟-IntSlice-排序" class="headerlink" title="1、模拟 IntSlice 排序"></a>1、模拟 IntSlice 排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name string</div><div class="line">    Age  int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 按照 Person.Age 从大到小排序</div><div class="line">type PersonSlice [] Person</div><div class="line"> </div><div class="line">func (a PersonSlice) Len() int &#123;    	 // 重写 Len() 方法</div><div class="line">    return len(a)</div><div class="line">&#125;</div><div class="line">func (a PersonSlice) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class="line">    a[i], a[j] = a[j], a[i]</div><div class="line">&#125;</div><div class="line">func (a PersonSlice) Less(i, j int) bool &#123;    // 重写 Less() 方法， 从大到小排序</div><div class="line">    return a[j].Age &lt; a[i].Age</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    people := [] Person&#123;</div><div class="line">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class="line">        &#123;&quot;li si&quot;, 30&#125;,</div><div class="line">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class="line">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(PersonSlice(people))    // 按照 Age 的逆序排序</div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(sort.Reverse(PersonSlice(people)))    // 按照 Age 的升序排序</div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。<br>这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。</p>
<h5 id="2、封装成-Wrapper"><a href="#2、封装成-Wrapper" class="headerlink" title="2、封装成 Wrapper"></a>2、封装成 Wrapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name string</div><div class="line">    Age  int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type PersonWrapper struct &#123;					//注意此处</div><div class="line">    people [] Person</div><div class="line">    by func(p, q * Person) bool</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func (pw PersonWrapper) Len() int &#123;    		// 重写 Len() 方法</div><div class="line">    return len(pw.people)</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class="line">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class="line">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    people := [] Person&#123;</div><div class="line">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class="line">        &#123;&quot;li si&quot;, 30&#125;,</div><div class="line">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class="line">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class="line">        return q.Age &lt; p.Age    // Age 递减排序</div><div class="line">    &#125;&#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class="line">        return p.Name &lt; q.Name    // Name 递增排序</div><div class="line">    &#125;&#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。</p>
<h5 id="3、进一步封装"><a href="#3、进一步封装" class="headerlink" title="3、进一步封装"></a>3、进一步封装</h5><p>感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name string</div><div class="line">    Age  int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type PersonWrapper struct &#123;</div><div class="line">    people [] Person</div><div class="line">    by func(p, q * Person) bool</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type SortBy func(p, q *Person) bool</div><div class="line"> </div><div class="line">func (pw PersonWrapper) Len() int &#123;    		// 重写 Len() 方法</div><div class="line">    return len(pw.people)</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Swap(i, j int)&#123;         // 重写 Swap() 方法</div><div class="line">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class="line">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 封装成 SortPerson 方法</div><div class="line">func SortPerson(people [] Person, by SortBy)&#123;</div><div class="line">    sort.Sort(PersonWrapper&#123;people, by&#125;)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    people := [] Person&#123;</div><div class="line">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class="line">        &#123;&quot;li si&quot;, 30&#125;,</div><div class="line">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class="line">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class="line">        return q.Age &lt; p.Age    // Age 递减排序</div><div class="line">    &#125;&#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    SortPerson(people, func (p, q *Person) bool &#123;</div><div class="line">        return p.Name &lt; q.Name    // Name 递增排序</div><div class="line">    &#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。</p>
<h5 id="4、另一种思路"><a href="#4、另一种思路" class="headerlink" title="4、另一种思路"></a>4、另一种思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name        string</div><div class="line">    Weight      int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type PersonSlice []Person</div><div class="line"> </div><div class="line">func (s PersonSlice) Len() int  &#123; return len(s) &#125;</div><div class="line">func (s PersonSlice) Swap(i, j int)     &#123; s[i], s[j] = s[j], s[i] &#125;</div><div class="line"> </div><div class="line">type ByName struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByName 中</div><div class="line"> </div><div class="line">func (s ByName) Less(i, j int) bool     &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125;    // 将 Less 绑定到 ByName 上</div><div class="line"> </div><div class="line"> </div><div class="line">type ByWeight struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByWeight 中</div><div class="line">func (s ByWeight) Less(i, j int) bool   &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125;    // 将 Less 绑定到 ByWeight 上</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    s := []Person&#123;</div><div class="line">        &#123;&quot;apple&quot;, 12&#125;,</div><div class="line">        &#123;&quot;pear&quot;, 20&#125;,</div><div class="line">        &#123;&quot;banana&quot;, 50&#125;,</div><div class="line">        &#123;&quot;orange&quot;, 87&#125;,</div><div class="line">        &#123;&quot;hello&quot;, 34&#125;,</div><div class="line">        &#123;&quot;world&quot;, 43&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    sort.Sort(ByWeight&#123;s&#125;)</div><div class="line">    fmt.Println(&quot;People by weight:&quot;)</div><div class="line">    printPeople(s)</div><div class="line"> </div><div class="line">    sort.Sort(ByName&#123;s&#125;)</div><div class="line">    fmt.Println(&quot;\nPeople by name:&quot;)</div><div class="line">    printPeople(s)</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">func printPeople(s []Person) &#123;</div><div class="line">    for _, o := range s &#123;</div><div class="line">        fmt.Printf(&quot;%-8s (%v)\n&quot;, o.Name, o.Weight)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。</p>
<h3 id="取最值"><a href="#取最值" class="headerlink" title="取最值"></a>取最值</h3><p>这个取最大值和最小值也是需要自己实现, 引入包<code>math</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func sliceMinMax() &#123;</div><div class="line">	intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class="line"></div><div class="line">	fmt.Println(intList)</div><div class="line">	//取最大值</div><div class="line">	fmt.Println(&quot;maxValue = &quot;, getMaxValue(intList))</div><div class="line"></div><div class="line">	//取最小值</div><div class="line">	fmt.Println(&quot;minValue = &quot;, getMinValue(intList))</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func getMaxValue(slice []int) int &#123;</div><div class="line">	var maxValue float64 = float64(slice[0])</div><div class="line">	for _, v := range slice &#123;</div><div class="line">		maxValue = math.Max(float64(maxValue), float64(v))</div><div class="line">	&#125;</div><div class="line">	return int(maxValue)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func getMinValue(slice []int) int &#123;</div><div class="line">	var maxValue float64 = float64(slice[0])</div><div class="line">	for _, v := range slice &#123;</div><div class="line">		maxValue = math.Min(float64(maxValue), float64(v))</div><div class="line">	&#125;</div><div class="line">	return int(maxValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2 4 3 5 7 6 9 8 1 0]</div><div class="line">maxValue =  9</div><div class="line">minValue =  0</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。&lt;/p&gt;
&lt;h3 id=&quot;slice声明和创建&quot;&gt;&lt;a href=&quot;#slice声明和创建&quot; class=&quot;headerlink&quot; title=&quot;slice声明和创建&quot;&gt;&lt;/a&gt;slice声明和创建&lt;/h3&gt;&lt;p&gt;slice 本身不是数组，它指向数组的底层&lt;br&gt;作为变长数组饿替代方案，可以关联底层数组的全部或者局部&lt;br&gt;可以直接创建，一般用make(), 也可以从底层数组获取生成&lt;br&gt;如果多个slice 指向相同的底层数组，一个值的改变会影响全部&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
      <category term="slice" scheme="http://gcblog/github.io/tags/slice/"/>
    
      <category term="排序" scheme="http://gcblog/github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串操作</title>
    <link href="http://gcblog/github.io/2018/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    <id>http://gcblog/github.io/2018/04/26/字符串操作/</id>
    <published>2018-04-26T03:30:20.000Z</published>
    <updated>2018-04-27T08:06:16.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>本文列举关于字符串最常用的几个操作，都会举例说明</p>
<ul>
<li><a href="#0">字符串长度</a></li>
<li><a href="#1">查找</a></li>
<li><a href="#2">替换</a></li>
<li><a href="#3">分割</a></li>
<li><a href="#4">合并</a></li>
<li><a href="#5">前缀或后缀</a></li>
<li><a href="#6">截取</a></li>
<li><a href="#7">删除</a></li>
<li><a href="#8">插入</a></li>
<li><a href="#9">编码转换</a></li>
<li><a href="#10">转换数值类型</a></li>
<li><a href="#11">大小写转换</a></li>
<li><a href="#12">Trim操作</a></li>
<li><a href="#13">ASCII 转换</a></li>
<li><a href="#14">字符串重复几次</a></li>
<li><a href="#15">字符或子串在字符串中首次出现的位置或最后一次出现的位置</a></li>
</ul>
<p>字符串相关操作需要导入包<code>strings</code></p>
<a id="more"></a>
<h3 id="0">字符串长度</h3>    

<ul>
<li><code>len()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func strLength() &#123;</div><div class="line">	var str = &quot;abc&quot;</div><div class="line">	var length = len(str)</div><div class="line">	fmt.Println(length)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1">查找</h3>    

<ul>
<li><code>func Contains(s, substr string) bool</code> 子串substr在s中，返回true</li>
<li><code>func ContainsAny(s, chars string) bool</code>  chars中任何一个字符在s中，返回true</li>
<li><code>func ContainsRune(s string, r rune) bool</code>  Unicode代码点r在s中，返回true</li>
<li><code>func Count(s, sep string) int</code> sep 在s中重复出现的次数(不计算重叠)</li>
<li><code>func Index(s, sep string)</code> int 在字符串s中查找sep所在的位置, 找不到返回-1</li>
</ul>
<blockquote>
<p>在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。<br>另外，Count 是计算子串在字符串中出现的无重叠的次数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">func existSubStringOrChar() &#123;</div><div class="line"></div><div class="line">	var super = &quot;abcdef!&quot;</div><div class="line">	var suba = &quot;abc&quot;</div><div class="line">	var subb = &quot;ef!&quot;</div><div class="line"></div><div class="line">	var hasa = existSubString(super, suba)</div><div class="line">	var hasb = existSubChar(super, subb)</div><div class="line"></div><div class="line">	fmt.Println(hasa, hasb)</div><div class="line"></div><div class="line">	var s = &quot;fivevev&quot;</div><div class="line">	var sep1 = &quot;vev&quot;</div><div class="line">	var sep2 = &quot;adfd&quot;</div><div class="line"></div><div class="line">	var c1 = repeatCount(s, sep1)</div><div class="line">	var c2 = repeatCount(s, sep2)</div><div class="line">	fmt.Println(c1, c2)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 是否存在某个字符或子串</div><div class="line">func existSubString(superString string, substring string) bool &#123;</div><div class="line">	return strings.Contains(superString, substring)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//substring 是否含有superString 的任意一个字符</div><div class="line">func existSubChar(superString string, substring string) bool &#123;</div><div class="line">	return strings.ContainsAny(superString, substring)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//substring 的重复出现次数</div><div class="line">func repeatCount(superString string, substring string) int &#123;</div><div class="line">	return strings.Count(superString, substring)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true true</div><div class="line">1 0</div></pre></td></tr></table></figure>
<h3 id="2">替换</h3>    

<ul>
<li><code>strings.Replace(s, old, new, n)</code></li>
</ul>
<p><code>s</code>需要替换的字符串   <code>old</code>需要被替换掉的某个子串    <code>new</code>替换的值<br><code>n</code>  <code>n&lt;0</code>全部替换  <code>n==0</code>不替换 <code>n&gt;0</code>全部替换 如果<code>n</code>的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func strReplace() &#123;</div><div class="line"></div><div class="line">	var str = &quot;cabcdefgabc&quot;</div><div class="line">	var value = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, -1)</div><div class="line">	var value1 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 0)</div><div class="line">	var value2 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 1)</div><div class="line">	var value3 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 3)</div><div class="line"></div><div class="line">	fmt.Println(value, value1, value2, value3)</div><div class="line">	strings.Replace(s, old, new, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc</div></pre></td></tr></table></figure></p>
<h3 id="3">分割</h3>

<h4 id="Fields-和-FieldsFunc"><a href="#Fields-和-FieldsFunc" class="headerlink" title="Fields 和 FieldsFunc"></a>Fields 和 FieldsFunc</h4><ul>
<li>Fields 按空格切割</li>
<li>FieldsFunc 按照自己指定的方式切割</li>
</ul>
<p>实际上，Fields 函数就是调用 FieldsFunc 实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func Fields(s string) []string &#123;</div><div class="line">    return FieldsFunc(s, unicode.IsSpace)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func strCut() &#123;</div><div class="line"></div><div class="line">	var str = &quot;abc bde efg&quot;</div><div class="line"></div><div class="line">	var cut1 = strings.Fields(str)</div><div class="line"></div><div class="line">	var cut2 = strings.FieldsFunc(str, unicode.IsSpace)</div><div class="line"></div><div class="line">	fmt.Println(cut1, cut2)</div><div class="line"></div><div class="line">	s := &quot;ab*cd*ef&quot;</div><div class="line">	result := strings.FieldsFunc(s, func(c rune) bool &#123;</div><div class="line">		if c == &apos;h&apos; &#123;</div><div class="line">			return true</div><div class="line">		&#125;</div><div class="line">		return false</div><div class="line">	&#125;)</div><div class="line">	fmt.Println(result)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[abc bde efg] [abc bde efg]</div><div class="line">[ab*cd*ef]</div></pre></td></tr></table></figure></p>
<h4 id="Split-和-SplitAfter、-SplitN-和-SplitAfterN"><a href="#Split-和-SplitAfter、-SplitN-和-SplitAfterN" class="headerlink" title="Split 和 SplitAfter、 SplitN 和 SplitAfterN"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;</div><div class="line">func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;</div><div class="line">func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;</div><div class="line">func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep,len(sep), n)&#125;</div></pre></td></tr></table></figure>
<p>它们都调用了 genSplit 函数。<br>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(“abc”,””)，得到的是[a b c]。</p>
<h5 id="功能区分：after-会保留分隔符"><a href="#功能区分：after-会保留分隔符" class="headerlink" title="功能区分：after 会保留分隔符"></a>功能区分：after 会保留分隔符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</div><div class="line">[&quot;foo,&quot; &quot;bar,&quot; &quot;baz&quot;]</div></pre></td></tr></table></figure></p>
<h5 id="N的区别"><a href="#N的区别" class="headerlink" title="N的区别"></a>N的区别</h5><p><code>N</code> 用来控制分割的个数<br>当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割</p>
<p><code>fmt.Printf(&quot;%q\n&quot;, strings.SplitN(&quot;foo,bar,baz&quot;, &quot;,&quot;, 2))</code><br>输出：<br><code>[&quot;foo&quot; &quot;bar,baz&quot;]</code></p>
<p>另外看一下官方文档提供的例子，注意一下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;))</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</div><div class="line">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</div><div class="line">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</div><div class="line">[&quot;&quot;]</div></pre></td></tr></table></figure></p>
<h5 id="split总结"><a href="#split总结" class="headerlink" title="split总结"></a>split总结</h5><p>关于字符串的分割，最常用的就是<code>Split</code>，其他几乎用不到</p>
<h3 id="4">合并</h3>

<p>将字符串数组（或slice）连接起来可以通过 Join 实现</p>
<ul>
<li><code>func Join(a []string, sep string) string</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func strJoin() &#123;</div><div class="line">	var arr = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class="line">	fmt.Println(arr)</div><div class="line">	// 用 ‘-’ 拼接</div><div class="line">	fmt.Println(strings.Join(arr, &quot;-&quot;))</div><div class="line">	// 直接拼接</div><div class="line">	fmt.Println(strings.Join(arr, &quot;&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[a b c]</div><div class="line">a-b-c</div><div class="line">abc</div></pre></td></tr></table></figure></p>
<h3 id="5">前缀或后缀</h3>    

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func presuf() &#123;</div><div class="line"></div><div class="line">	var str = &quot;abcdefg&quot;</div><div class="line">	//判断开始</div><div class="line">	var preA = strings.HasPrefix(str, &quot;a&quot;)</div><div class="line"></div><div class="line">	//判断结尾</div><div class="line">	var preG = strings.HasSuffix(str, &quot;g&quot;)</div><div class="line"></div><div class="line">	fmt.Println(preA, preG)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><code>true true</code></p>
<h3 id="6">截取</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func subString() &#123;</div><div class="line">	//strings 没有 截取字符串的方法</div><div class="line">	var str = &quot;abc中国defgh&quot;</div><div class="line">	// 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等</div><div class="line">	var strArr = string([]rune(str)[:4])</div><div class="line"></div><div class="line">	fmt.Println(strArr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abc中</div></pre></td></tr></table></figure></p>
<h3 id="7">删除</h3>

<p>strings 包中没有提供删除的方法，只能自己实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func deleteStrWithRange(s string, start int, end int) string &#123;</div><div class="line">if len(s) == 0 || end &gt; len(s) &#123;</div><div class="line">	return &quot;&quot;</div><div class="line">&#125;</div><div class="line">var str1 = string([]rune(s)[:start])</div><div class="line">var str2 = string([]rune(s)[end:])</div><div class="line">return str1 + str2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var sss = deleteStrWithRange(&quot;012345678&quot;, 1, 3)</div><div class="line">fmt.Println(sss)</div></pre></td></tr></table></figure>
<p>输出：<br><code>0345678</code></p>
<h3 id="8">插入</h3>

<p>go strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string</p>
<h3 id="9">编码转换</h3>

<p>字符串转换需要用到 <code>strconv</code></p>
<ul>
<li>Append 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte</li>
<li>Format 函数将给定的类型变量转换为string返回</li>
<li>Parse 函数将字符串转换为其他类型</li>
</ul>
<h4 id="unicode-与-中文-互转"><a href="#unicode-与-中文-互转" class="headerlink" title="unicode  与 中文 互转"></a>unicode  与 中文 互转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func chinaeseToUnicode() &#123;</div><div class="line">	sText := &quot;中文&quot;</div><div class="line">	textQuoted := strconv.QuoteToASCII(sText)</div><div class="line">	fmt.Println(textQuoted)</div><div class="line"></div><div class="line">	textUnquoted := textQuoted[1 : len(textQuoted)-1]</div><div class="line">	fmt.Println(textUnquoted)</div><div class="line"></div><div class="line">	sUnicodev := strings.Split(textUnquoted, &quot;\\u&quot;)</div><div class="line">	var context string</div><div class="line">	for _, v := range sUnicodev &#123;</div><div class="line">		if len(v) &lt; 1 &#123;</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		temp, err := strconv.ParseInt(v, 16, 32)</div><div class="line">		if err != nil &#123;</div><div class="line">			panic(err)</div><div class="line">		&#125;</div><div class="line">		context += fmt.Sprintf(&quot;%c&quot;, temp)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;\u4e2d\u6587&quot;</div><div class="line">\u4e2d\u6587</div><div class="line">中文</div></pre></td></tr></table></figure></p>
<h4 id="转码与解码"><a href="#转码与解码" class="headerlink" title="转码与解码"></a>转码与解码</h4><p>需要导入包 <code>net/url</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func encodeAndDecode() &#123;</div><div class="line">	var str = &quot;https://www.baidu.com/生活&quot;</div><div class="line"></div><div class="line">	//转码</div><div class="line">	var encode = url.QueryEscape(str)</div><div class="line"></div><div class="line">	fmt.Println(encode)</div><div class="line"></div><div class="line">	//解码</div><div class="line">	decodeurl, err := url.QueryUnescape(encode)</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(decodeurl)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BB</div><div class="line">https://www.baidu.com/生活</div></pre></td></tr></table></figure></p>
<h3 id="10">转换数值类型</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func strToValue() &#123;</div><div class="line"></div><div class="line">	// int 转 string</div><div class="line">	var intA int = 123</div><div class="line">	var stringA string = strconv.Itoa(intA)</div><div class="line">	fmt.Println(stringA, reflect.TypeOf(stringA))</div><div class="line"></div><div class="line">	// string 转 int</div><div class="line"></div><div class="line">	var stringB = &quot;45678&quot;</div><div class="line">	intB, err := strconv.Atoi(stringB)</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(intB, reflect.TypeOf(intB))</div><div class="line"></div><div class="line">	// string to float</div><div class="line">	var stringc = &quot;123.45678&quot;</div><div class="line">	floatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64,</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(floatC, reflect.TypeOf(floatC))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">123 string</div><div class="line">45678 int</div><div class="line">123.45678 float64</div></pre></td></tr></table></figure></p>
<h3 id="11">大小写转换</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)</div><div class="line">func Title(s string) string</div><div class="line"></div><div class="line">// 所有字母转换为小写</div><div class="line">func ToLower(s string) string</div><div class="line"></div><div class="line">// 所有字母转换为大写</div><div class="line">func ToUpper(s string) string</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fmt.Println(strings.Title(&quot;her royal highness&quot;))  // Her Royal Highness</div><div class="line"></div><div class="line">fmt.Println(strings.ToLower(&quot;Gopher123&quot;))  // gopher123</div><div class="line"></div><div class="line">fmt.Println(strings.ToUpper(&quot;Gopher&quot;))  // GOPHER</div></pre></td></tr></table></figure>
<h3 id="12">Trim操作</h3>

<p>bytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。</p>
<p>在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。</p>
<ul>
<li><code>func Trim(s string, cutset string) string</code> 去除两边自定义字符</li>
<li><code>func TrimFunc(s string, f func(rune) bool) string</code> 自定义清除</li>
<li><code>func TrimLeft(s string, cutset string) string</code> 清除左边</li>
<li><code>func TrimPrefix(s, prefix string) string</code> 删除前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func strtrim() &#123;</div><div class="line">	var str = &quot;  ads!/  ;&apos;  jha   asdfhj   &quot;</div><div class="line"></div><div class="line">	// 去除首尾空格，一般这个最常用</div><div class="line">	var value1 = strings.Trim(str, &quot; &quot;)</div><div class="line">	fmt.Println(value1)</div><div class="line"></div><div class="line">	//自定义trim</div><div class="line">	fmt.Println(strings.TrimFunc(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, func(r rune) bool &#123;</div><div class="line">		if r == &apos;&amp;&apos; &#123;</div><div class="line">			return true</div><div class="line">		&#125;</div><div class="line">		return false</div><div class="line">	&#125;))</div><div class="line"></div><div class="line">	//trim 左侧 &amp; 右侧</div><div class="line">	fmt.Println(strings.TrimLeft(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class="line">	fmt.Println(strings.TrimRight(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class="line"></div><div class="line">	//去除前缀，后缀也一样</div><div class="line">	var str2 = &quot;xxx_abcd&quot;</div><div class="line">	if strings.HasPrefix(str2, &quot;xxx_&quot;) &#123;</div><div class="line">		fmt.Println(strings.TrimPrefix(str2, &quot;xxx_&quot;))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ads!/  ;&apos;  jha   asdfhj</div><div class="line">nihao</div><div class="line">nihao&amp;&amp;&amp;&amp;</div><div class="line">&amp;&amp;&amp;&amp;nihao</div><div class="line">abcd</div></pre></td></tr></table></figure>
<h3 id="13">ASCII 转换</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func strASCII() &#123;</div><div class="line"></div><div class="line">	//字符转ASCII</div><div class="line">	var c rune = &apos;a&apos;</div><div class="line">	var i1 = int(c)</div><div class="line">	fmt.Println(&quot;&apos;a&apos; convert to ASCII&quot;, i1)</div><div class="line"></div><div class="line">	//ASCII 转字符</div><div class="line">	var i int = 98</div><div class="line">	var c1 = rune(i)</div><div class="line">	fmt.Println(&quot;98 convert to string&quot;, string(c1))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;a&apos; convert to ASCII 97</div><div class="line">98 convert to string b</div></pre></td></tr></table></figure>
<h3 id="14">字符串重复几次</h3>

<ul>
<li><code>func Repeat(s string, count int) string</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func strRepeatCount() &#123;</div><div class="line">	fmt.Println(strings.Repeat(&quot;a&quot;, 2))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<p><code>aa</code></p>
<h3 id="15">字符或子串在字符串中首次出现的位置或最后一次出现的位置</h3>

<h4 id="4个查找第一次出现的位置"><a href="#4个查找第一次出现的位置" class="headerlink" title="4个查找第一次出现的位置"></a>4个查找第一次出现的位置</h4><p>// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引<br><code>func Index(s, sep string) int</code><br>// chars中任何一个Unicode代码点在s中首次出现的位置<br><code>func IndexAny(s, chars string) int</code><br>// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true<br><code>func IndexFunc(s string, f func(rune) bool) int</code><br>// Unicode 代码点 r 在 s 中第一次出现的位置<br><code>func IndexRune(s string, r rune) int</code></p>
<p>一般用<code>indexAny</code></p>
<h4 id="3个查找最后一次出现的位置"><a href="#3个查找最后一次出现的位置" class="headerlink" title="3个查找最后一次出现的位置"></a>3个查找最后一次出现的位置</h4><p><code>func LastIndex(s, sep string) int</code><br><code>func LastIndexAny(s, chars string) int</code><br><code>func LastIndexFunc(s string, f func(rune) bool) int</code></p>
<p>一般用<code>LastIndexAny</code>就行</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;本文列举关于字符串最常用的几个操作，都会举例说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;字符串长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;替换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;前缀或后缀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6&quot;&gt;截取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7&quot;&gt;删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8&quot;&gt;插入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9&quot;&gt;编码转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10&quot;&gt;转换数值类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11&quot;&gt;大小写转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12&quot;&gt;Trim操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#13&quot;&gt;ASCII 转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#14&quot;&gt;字符串重复几次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#15&quot;&gt;字符或子串在字符串中首次出现的位置或最后一次出现的位置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串相关操作需要导入包&lt;code&gt;strings&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
      <category term="strings" scheme="http://gcblog/github.io/tags/strings/"/>
    
      <category term="字符串操作" scheme="http://gcblog/github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>go数组</title>
    <link href="http://gcblog/github.io/2018/04/18/go%E6%95%B0%E7%BB%84/"/>
    <id>http://gcblog/github.io/2018/04/18/go数组/</id>
    <published>2018-04-18T06:59:13.000Z</published>
    <updated>2018-04-18T07:01:46.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。</li>
<li>定义数组的格式：var <varname> [n]<type>，n&gt;=0</type></varname></li>
<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型</li>
<li>注意区分指向数组的指针和指针数组</li>
<li>数组在Go中为值类型</li>
<li>数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt;(比较的前提是数组个数相同，并且元素类型相同)</li>
<li>可以使用new来创建数组，此方法返回一个指向数组的指针</li>
<li>Go支持多维数组</li>
</ul>
<a id="more"></a>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func createArr() &#123;</div><div class="line"></div><div class="line">	// 指定数组长度</div><div class="line">	// 创建数组如果给定数组长度，数组个数就不能超过这个长度</div><div class="line">	var arr1 = [5]int&#123;1, 3, 5, 2, 9&#125;</div><div class="line">	fmt.Println(arr1)</div><div class="line"></div><div class="line">	//不指定数组长度</div><div class="line">	//Go 语言会根据元素的个数来设置数组的大小</div><div class="line">	var arr2 = []int&#123;1, 2&#125;</div><div class="line">	var arr3 = [...]int&#123;2, 3, 4&#125;</div><div class="line">	fmt.Println(arr2)</div><div class="line">	fmt.Println(arr3)</div><div class="line"></div><div class="line">	//创建变量或者常量 可以简写</div><div class="line">	arr4 := []int&#123;5&#125;</div><div class="line">	fmt.Println(arr4)</div><div class="line">	//初始化对指定元素赋值</div><div class="line">	//第三个元素 初始化为1</div><div class="line">	var arr5 = [5]int&#123;3: 1&#125;</div><div class="line">	fmt.Println(arr5)</div><div class="line"></div><div class="line">	// 获取数组的长度和容量</div><div class="line">	fmt.Println(len(arr1))</div><div class="line">	fmt.Println(cap(arr1))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[1 3 5 2 9]</div><div class="line">[1 2]</div><div class="line">[2 3 4]</div><div class="line">[5]</div><div class="line">[0 0 0 1 0]</div><div class="line">5</div><div class="line">5</div></pre></td></tr></table></figure></p>
<h4 id="编辑数组"><a href="#编辑数组" class="headerlink" title="编辑数组"></a>编辑数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func editArr() &#123;</div><div class="line"></div><div class="line">	var arr1 = []int&#123;1, 2&#125;</div><div class="line">	fmt.Print(len(arr1), cap(arr1))</div><div class="line">	fmt.Println(arr1)</div><div class="line"></div><div class="line">	// 给arr1 添加元素 3，4</div><div class="line">	var arr2 = append(arr1, 3, 4)</div><div class="line">	fmt.Println(&quot;arr1 = &quot;, arr1)</div><div class="line">	fmt.Println(&quot;arr2 = &quot;, arr2)</div><div class="line">	fmt.Print(len(arr1), cap(arr1))</div><div class="line"></div><div class="line">	//改变数组中元素的值</div><div class="line">	arr1[0] = 9</div><div class="line">	fmt.Println(arr1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2 2[1 2]</div><div class="line">[1 2 3 4]</div><div class="line">4 4[9 2 3 4]</div></pre></td></tr></table></figure></p>
<h4 id="指针-amp-数组"><a href="#指针-amp-数组" class="headerlink" title="指针&amp;数组"></a>指针&amp;数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func pointArr() &#123;</div><div class="line">	//数组指针   它是一个指针，指向数组的地址</div><div class="line">	a := []int&#123;5: 1&#125;</div><div class="line">	var p *[]int = &amp;a</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(p) //比a 多了一个取地址符</div><div class="line"></div><div class="line">	// 指针数组 数组里存放的是指针地址，不是实际的值</div><div class="line">	var x, y = 4, 5</div><div class="line">	arr := []*int&#123;&amp;x, &amp;y&#125;</div><div class="line">	fmt.Println(arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[0 0 0 0 0 1]</div><div class="line">&amp;[0 0 0 0 0 1]</div><div class="line">[0xc4200142b0 0xc4200142b8]</div></pre></td></tr></table></figure></p>
<h4 id="range遍历数组"><a href="#range遍历数组" class="headerlink" title="range遍历数组"></a>range遍历数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func rangeArr() &#123;</div><div class="line"></div><div class="line">	var arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class="line">	for i, v := range arr &#123;</div><div class="line">		fmt.Println(i, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div></pre></td></tr></table></figure></p>
<h4 id="new-关键字创建数组"><a href="#new-关键字创建数组" class="headerlink" title="new 关键字创建数组"></a>new 关键字创建数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func newarr() &#123;</div><div class="line"></div><div class="line">	var a = [5]int&#123;&#125;</div><div class="line">	a[1] = 2</div><div class="line">	fmt.Println(a)</div><div class="line"></div><div class="line">	p := new([5]int) //可以通过下标赋值</div><div class="line">	p[1] = 2</div><div class="line">	fmt.Println(p)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[0 2 0 0 0]</div><div class="line">&amp;[0 2 0 0 0]</div></pre></td></tr></table></figure></p>
<h4 id="数组传递"><a href="#数组传递" class="headerlink" title="数组传递"></a>数组传递</h4><p>在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line"></div><div class="line">	var testArr = [5]int&#123;1, 2, 3, 4, 5&#125;</div><div class="line"></div><div class="line">	fmt.Println(testArr)</div><div class="line"></div><div class="line">	modifyarr(testArr)</div><div class="line"></div><div class="line">	fmt.Println(&quot;In main&quot;, testArr)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func modifyarr(arr [5]int) &#123;</div><div class="line">	arr[0] = 10</div><div class="line">	fmt.Println(&quot;In modify&quot;, arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1 2 3 4 5]</div><div class="line">In modify [10 2 3 4 5]</div><div class="line">In main [1 2 3 4 5]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。&lt;/li&gt;
&lt;li&gt;定义数组的格式：var &lt;varName&gt; [n]&lt;type&gt;，n&amp;gt;=0&lt;/li&gt;
&lt;li&gt;数组长度也是类型的一部分，因此具有不同长度的数组为不同类型&lt;/li&gt;
&lt;li&gt;注意区分指向数组的指针和指针数组&lt;/li&gt;
&lt;li&gt;数组在Go中为值类型&lt;/li&gt;
&lt;li&gt;数组之间可以使用==或!=进行比较，但不可以使用&amp;lt;或&amp;gt;(比较的前提是数组个数相同，并且元素类型相同)&lt;/li&gt;
&lt;li&gt;可以使用new来创建数组，此方法返回一个指向数组的指针&lt;/li&gt;
&lt;li&gt;Go支持多维数组&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="数组" scheme="http://gcblog/github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>PhotoBatch-图片去重(3)</title>
    <link href="http://gcblog/github.io/2017/12/22/PhotoBatch-%E5%9B%BE%E7%89%87%E5%8E%BB%E9%87%8D-3/"/>
    <id>http://gcblog/github.io/2017/12/22/PhotoBatch-图片去重-3/</id>
    <published>2017-12-22T04:36:51.000Z</published>
    <updated>2017-12-22T06:28:58.704Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html" target="_blank" rel="external">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></p>
<p>很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。</p>
<p>这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。</p>
<p>另外还找到了其他几种方法，这里是地址<br><a href="http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html</a></p>
<h2 id="第一步，缩小尺寸。"><a href="#第一步，缩小尺寸。" class="headerlink" title="第一步，缩小尺寸。"></a>第一步，缩小尺寸。</h2><p>将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。<br>在macOS，使用的是<code>NSImage</code>, 两者的一些操作很类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize</div><div class="line">&#123;</div><div class="line">    NSImage *sourceImage = image;</div><div class="line">    if (![sourceImage isValid])&#123;</div><div class="line">        NSLog(@&quot;Invalid Image&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];</div><div class="line">        [smallImage lockFocus];</div><div class="line">        [sourceImage setSize: reSize];</div><div class="line">        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];</div><div class="line">        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];</div><div class="line">        [smallImage unlockFocus];</div><div class="line">        return smallImage;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <a id="more"></a>
<h2 id="第二步，简化色彩。"><a href="#第二步，简化色彩。" class="headerlink" title="第二步，简化色彩。"></a>第二步，简化色彩。</h2><p>将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。</p>
<h2 id="第三步，计算平均值。"><a href="#第三步，计算平均值。" class="headerlink" title="第三步，计算平均值。"></a>第三步，计算平均值。</h2><p>计算所有64个像素的灰度平均值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">a[ArrSize] = 0;</div><div class="line">b[ArrSize] = 0;</div><div class="line">CGPoint point;</div><div class="line">for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class="line">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class="line">        point.x = i;</div><div class="line">        point.y = j;</div><div class="line">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class="line">        a[cursize * i + j] = grey;</div><div class="line">        a[ArrSize] += grey;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[ArrSize] /= (ArrSize - 1);//灰度平均值</div><div class="line">for (i = 0 ; i &lt; cursize; i++) &#123;//计算b的灰度</div><div class="line">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class="line">        point.x = i;</div><div class="line">        point.y = j;</div><div class="line">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]);</div><div class="line">        b[cursize * i + j] = grey;</div><div class="line">        b[ArrSize] += grey;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">b[ArrSize] /= (ArrSize - 1);//灰度平均值</div></pre></td></tr></table></figure></p>
<h2 id="第四步，比较像素的灰度。"><a href="#第四步，比较像素的灰度。" class="headerlink" title="第四步，比较像素的灰度。"></a>第四步，比较像素的灰度。</h2><p>将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a[ArrSize] = 0;</div><div class="line">   b[ArrSize] = 0;</div><div class="line">   CGPoint point;</div><div class="line">   for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class="line">       for (j = 0; j &lt; cursize; j++) &#123;</div><div class="line">           point.x = i;</div><div class="line">           point.y = j;</div><div class="line">           grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class="line">           a[cursize * i + j] = grey;</div><div class="line">           a[ArrSize] += grey;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="第五步，计算哈希值。"><a href="#第五步，计算哈希值。" class="headerlink" title="第五步，计算哈希值。"></a>第五步，计算哈希值。</h2><p>将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。<br>得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算”汉明距离”（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。<br>实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。</p>
<p>这是一个比较耗时的操作，所以放在子线程中操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *totalArr = [NSMutableArray array];</div><div class="line">   </div><div class="line">   __weak __typeof(self)weakSelf = self;</div><div class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">       </div><div class="line">       for (NSString *filePath in allFiles) &#123;</div><div class="line">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理文件：%@&quot;, filePath];</div><div class="line">           &#125;);</div><div class="line">           if (totalArr.count == 0) &#123;</div><div class="line">               NSMutableArray *arr = [NSMutableArray array];</div><div class="line">               [arr addObject:filePath];</div><div class="line">               [totalArr addObject:arr];</div><div class="line">           &#125; else &#123;</div><div class="line">               </div><div class="line">               NSInteger groupCount = [[totalArr mutableCopy] count];</div><div class="line">               for (int i = 0; i &lt; groupCount; i++) &#123;</div><div class="line">                   NSMutableArray *arr = totalArr[i];</div><div class="line">                   NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject];</div><div class="line">                   NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath];</div><div class="line">                   Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb];</div><div class="line">                   if (simi &gt;= 0.9) &#123; //相似度比较接近</div><div class="line">                       [arr addObject:filePath];</div><div class="line">                       break;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       if (i == [[totalArr mutableCopy] count] - 1) &#123;  //已经遍历到最后一组，还没有找到相似图片，新建一组</div><div class="line">                           NSMutableArray *arr = [NSMutableArray array];</div><div class="line">                           [arr addObject:filePath];</div><div class="line">                           @synchronized(totalArr) &#123;</div><div class="line">                               [totalArr addObject:arr];</div><div class="line">                           &#125;</div><div class="line">                           break;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               </div><div class="line">               </div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       NSMutableArray *repeatArr = [NSMutableArray new];</div><div class="line">       for (NSArray *arr in totalArr) &#123;</div><div class="line">           if (arr.count &gt; 1) &#123;</div><div class="line">               [repeatArr addObject:arr];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">           weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理完成&quot;];</div><div class="line">           [self.checkRepeatView buildUIWithImageArr:repeatArr];</div><div class="line">       &#125;);</div><div class="line">       </div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>效果图：</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3_1.png" alt=""></p>
<p><a href="https://github.com/macOSApp/photoBatch" target="_blank" rel="external">demo地址:https://github.com/macOSApp/photoBatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;a href=&quot;http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html&quot;&gt;http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。&lt;/p&gt;
&lt;p&gt;这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。&lt;/p&gt;
&lt;p&gt;另外还找到了其他几种方法，这里是地址&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html&quot;&gt;http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一步，缩小尺寸。&quot;&gt;&lt;a href=&quot;#第一步，缩小尺寸。&quot; class=&quot;headerlink&quot; title=&quot;第一步，缩小尺寸。&quot;&gt;&lt;/a&gt;第一步，缩小尺寸。&lt;/h2&gt;&lt;p&gt;将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。&lt;br&gt;在macOS，使用的是&lt;code&gt;NSImage&lt;/code&gt;, 两者的一些操作很类似。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSImage *sourceImage = image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (![sourceImage isValid])&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        NSLog(@&amp;quot;Invalid Image&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [smallImage lockFocus];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [sourceImage setSize: reSize];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [smallImage unlockFocus];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return smallImage;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return nil;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="macOS" scheme="http://gcblog/github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://gcblog/github.io/tags/macOS/"/>
    
      <category term="macOSApp" scheme="http://gcblog/github.io/tags/macOSApp/"/>
    
      <category term="图片去重" scheme="http://gcblog/github.io/tags/%E5%9B%BE%E7%89%87%E5%8E%BB%E9%87%8D/"/>
    
      <category term="图片相似查询" scheme="http://gcblog/github.io/tags/%E5%9B%BE%E7%89%87%E7%9B%B8%E4%BC%BC%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>PhotoBatch-文件重命名(2)</title>
    <link href="http://gcblog/github.io/2017/12/04/PhotoBatch-%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D-2/"/>
    <id>http://gcblog/github.io/2017/12/04/PhotoBatch-文件重命名-2/</id>
    <published>2017-12-04T08:50:20.000Z</published>
    <updated>2017-12-04T08:52:53.477Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名</p>
<h3 id="搭建界面"><a href="#搭建界面" class="headerlink" title="搭建界面"></a>搭建界面</h3><p>搭了个简单的界面，如下图：<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png" alt="布局用了purelayout框架"><br>我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。</p>
<h3 id="文件夹处理"><a href="#文件夹处理" class="headerlink" title="文件夹处理"></a>文件夹处理</h3><p>获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以<br><code>file://</code>开头，需要把前面的<code>file://</code>去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (void)dealFiles:(NSArray *)filepaths</div><div class="line">&#123;</div><div class="line">    self.dealingLabel.stringValue = [filepaths.firstObject description];</div><div class="line">    </div><div class="line">    NSMutableArray *arr = [NSMutableArray new];</div><div class="line">    // 对文件夹路径进行处理</div><div class="line">    for (NSString *path in filepaths) &#123;</div><div class="line">        if ([[path description] hasPrefix:@&quot;file:///&quot;]) &#123;</div><div class="line">            NSString *newpath = [[path description] substringFromIndex:7];</div><div class="line">            if ([newpath hasSuffix:@&quot;/&quot;]) &#123;</div><div class="line">                newpath  = [newpath substringToIndex:newpath.length - 1];</div><div class="line">            &#125;</div><div class="line">            [arr addObject:newpath];</div><div class="line">            </div><div class="line">        &#125; else &#123;</div><div class="line">            if ([[path description] hasSuffix:@&quot;/&quot;]) &#123;</div><div class="line">                NSString *tempStr = [path description];</div><div class="line">                [arr addObject:[tempStr substringToIndex:tempStr.length - 1]];</div><div class="line">            &#125; else &#123;</div><div class="line">                [arr addObject:[path description]];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.folderPaths = filepaths;</div><div class="line">    </div><div class="line">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class="line">    for (NSString *docuPath in self.folderPaths) &#123; // 遍历所有文件夹 获取所有文件个数</div><div class="line">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class="line">        [allFiles addObjectsFromArray:files];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSAlert *alert = [[NSAlert alloc] init];</div><div class="line">    [alert setMessageText:@&quot;文件获取成功&quot;];</div><div class="line">    [alert setInformativeText:[NSString stringWithFormat:@&quot;文件总数：%ld 个&quot;, allFiles.count]];</div><div class="line">    [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) &#123;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文件批量重命名"><a href="#文件批量重命名" class="headerlink" title="文件批量重命名"></a>文件批量重命名</h3><p>遍历所有文件夹下所有文件，<code>NSFileManager</code> 并没有重命名的方法，如果要保留原文件，则执行<code>copy</code>操作，如果不保留原文件，则执行<code>move</code>操作。下面是重命名代码的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">- (IBAction)StartAction:(NSButton *)sender &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class="line">    for (NSString *docuPath in self.folderPaths) &#123;</div><div class="line">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class="line">        for (NSString *filename in files) &#123;</div><div class="line">            [allFiles addObject:[NSString stringWithFormat:@&quot;%@/%@&quot;, docuPath, filename]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (allFiles.count == 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    NSString *resultFilePath = [NSString stringWithFormat:@&quot;%@/%@&quot;, self.folderPaths.firstObject, @&quot;result&quot;];</div><div class="line">    </div><div class="line">    NSError *err = nil;</div><div class="line">    [XCFileManager createDirectoryAtPath:resultFilePath error:&amp;err];</div><div class="line">    NSString *prefixName = _reNameView.prefixInput.stringValue;</div><div class="line">    if (!prefixName || prefixName.length == 0) &#123;</div><div class="line">        prefixName = @&quot;img_&quot;;</div><div class="line">    &#125;</div><div class="line">    NSString *suffixName = _reNameView.suffixInput.stringValue;</div><div class="line">    if(!suffixName || suffixName.length == 0) &#123;</div><div class="line">        suffixName = @&quot;&quot;;</div><div class="line">    &#125;</div><div class="line">    NSInteger index = 1;</div><div class="line">    NSString *suffix = @&quot;&quot;;</div><div class="line">    for (NSString *path in allFiles) &#123;</div><div class="line">//        // 如果遇到 没有文件名的文件，直接过滤</div><div class="line">        if ([path componentsSeparatedByString:@&quot;.&quot;].count &lt; 2) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (suffixName.length == 0) &#123;</div><div class="line">            suffix = [[path componentsSeparatedByString:@&quot;.&quot;].lastObject description];</div><div class="line">        &#125; else &#123;</div><div class="line">            suffix = suffixName;</div><div class="line">        &#125;</div><div class="line">        self.dealingLabel.stringValue = [path description];</div><div class="line">        </div><div class="line">        NSString *movePath = [NSString stringWithFormat:@&quot;%@/%@%ld.%@&quot;, resultFilePath, prefixName, index,suffix];</div><div class="line">        if (_reNameView.checkSaveBtn.state == 1) &#123;</div><div class="line">           [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO];</div><div class="line">        &#125; else &#123;</div><div class="line">            [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        index ++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.dealingLabel.stringValue = @&quot;处理完成&quot;;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/macOSApp/photoBatch" target="_blank" rel="external">demo地址:https://github.com/macOSApp/photoBatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名&lt;/p&gt;
&lt;h3 id=&quot;搭建界面&quot;&gt;&lt;a href=&quot;#搭建界面&quot; class=&quot;headerlink&quot; title=&quot;搭建界面&quot;&gt;&lt;/a&gt;搭建界面&lt;/h3&gt;&lt;p&gt;搭了个简单的界面，如下图：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png&quot; alt=&quot;布局用了purelayout框架&quot;&gt;&lt;br&gt;我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。&lt;/p&gt;
&lt;h3 id=&quot;文件夹处理&quot;&gt;&lt;a href=&quot;#文件夹处理&quot; class=&quot;headerlink&quot; title=&quot;文件夹处理&quot;&gt;&lt;/a&gt;文件夹处理&lt;/h3&gt;&lt;p&gt;获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以&lt;br&gt;&lt;code&gt;file://&lt;/code&gt;开头，需要把前面的&lt;code&gt;file://&lt;/code&gt;去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。&lt;/p&gt;
    
    </summary>
    
      <category term="macOS" scheme="http://gcblog/github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://gcblog/github.io/tags/macOS/"/>
    
      <category term="macOSApp" scheme="http://gcblog/github.io/tags/macOSApp/"/>
    
      <category term="文件重命名" scheme="http://gcblog/github.io/tags/%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>PhotoBatch-文件操作(1)</title>
    <link href="http://gcblog/github.io/2017/11/26/PhotoBatch-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1/"/>
    <id>http://gcblog/github.io/2017/11/26/PhotoBatch-文件操作-1/</id>
    <published>2017-11-26T08:02:41.000Z</published>
    <updated>2017-11-26T08:08:50.748Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。</p>
<h3 id="文件拖拽"><a href="#文件拖拽" class="headerlink" title="文件拖拽"></a>文件拖拽</h3><ul>
<li>需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径</li>
</ul>
<h4 id="新建-macOS-工程"><a href="#新建-macOS-工程" class="headerlink" title="新建 macOS 工程"></a>新建 macOS 工程</h4><p>跟新建iOS项目工程几乎一致。</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png" alt="新建工程"><br><a id="more"></a></p>
<h4 id="自定义PBDragView"><a href="#自定义PBDragView" class="headerlink" title="自定义PBDragView"></a>自定义PBDragView</h4><p>在iOS中，最核心的的框架就是<code>Foundation</code>和<code>UIKit</code>, 在macOS中，就是<code>Foundation</code>和<code>AppKit</code>, 对于iOS中大部分控件，都是把前缀又<code>UI</code>换成了<code>NS</code>, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客<a href="https://www.objccn.io/issue-14-5" target="_blank" rel="external">从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5)</a>, 讲述了这两个框架的一些异同。</p>
<p>我们需要自定义一个 <code>PBDragView</code> 继承自<code>NSView</code>，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。</p>
<h4 id="注册支持的文件类型"><a href="#注册支持的文件类型" class="headerlink" title="注册支持的文件类型"></a>注册支持的文件类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)awakeFromNib</div><div class="line">&#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">    // 设置支持的文件类型</div><div class="line">    [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">#### 实现文件拖动的几个方法</div></pre></td></tr></table></figure>
<ul>
<li><p>(NSDragOperation)draggingEntered:(id<nsdragginginfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragEnter)]) {</nsdragginginfo></p>
<pre><code>[self.delegate dragEnter];
</code></pre><p>  }</p>
<p>  return NSDragOperationGeneric;<br>}</p>
</li>
<li><p>(void)draggingExited:(id<nsdragginginfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragExit)]) {</nsdragginginfo></p>
<pre><code>[self.delegate dragExit];
</code></pre><p>  }<br>}</p>
</li>
<li><p>(BOOL)performDragOperation:(id<nsdragginginfo>)sender<br>{<br>  // 获取所有的路径<br>  NSArray *arr =  [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];<br>  if (self.delegate &amp;&amp; arr.count &gt; 0 &amp;&amp; [self.delegate respondsToSelector:@selector(dragFileComplete:)]) {</nsdragginginfo></p>
<pre><code>[self.delegate dragFileComplete:arr];
</code></pre><p>  }<br>  return YES;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#### 在SB中使用PBDragView</div><div class="line"></div><div class="line">![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)</div><div class="line"></div><div class="line">运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。</div><div class="line"></div><div class="line"></div><div class="line">### 文件选择</div><div class="line"></div><div class="line">* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹</div><div class="line"></div><div class="line">#### 添加点击按钮</div><div class="line"></div><div class="line">在SB中添加按钮，然后添加点击事件</div><div class="line">![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)</div><div class="line"></div><div class="line"></div><div class="line">#### 文件选择功能实现</div></pre></td></tr></table></figure>
<p>  NSOpenPanel *openPanel = [NSOpenPanel openPanel];<br>  [openPanel setPrompt: @”打开”];<br>  [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹<br>  [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录<br>  [openPanel setCanChooseFiles:YES];  //设置允许打开文件<br>  [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹<br>  [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档<br>  [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档<br>  openPanel.allowedFileTypes = [NSArray arrayWithObjects: @”jpg”, @”doc”,@”txt”,@”jpeg”,@”png”,@”tiff”, nil]; //设置允许打开的文件类型<br>  [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) {</p>
<pre><code>NSArray *filePaths = [openPanel URLs];
NSLog(@&quot;-----%@&quot;, filePaths);
</code></pre><p>  }];<br>```<br>效果图：<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/4.png" alt="弹出系统的文件选择框"></p>
</li>
</ul>
<p><a href="https://github.com/macOSApp/photoBatch" target="_blank" rel="external">demo地址:https://github.com/macOSApp/photoBatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。&lt;/p&gt;
&lt;h3 id=&quot;文件拖拽&quot;&gt;&lt;a href=&quot;#文件拖拽&quot; class=&quot;headerlink&quot; title=&quot;文件拖拽&quot;&gt;&lt;/a&gt;文件拖拽&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;新建-macOS-工程&quot;&gt;&lt;a href=&quot;#新建-macOS-工程&quot; class=&quot;headerlink&quot; title=&quot;新建 macOS 工程&quot;&gt;&lt;/a&gt;新建 macOS 工程&lt;/h4&gt;&lt;p&gt;跟新建iOS项目工程几乎一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png&quot; alt=&quot;新建工程&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="macOS" scheme="http://gcblog/github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://gcblog/github.io/tags/macOS/"/>
    
      <category term="macOSApp" scheme="http://gcblog/github.io/tags/macOSApp/"/>
    
      <category term="文件处理" scheme="http://gcblog/github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Gif播放与暂停</title>
    <link href="http://gcblog/github.io/2017/11/14/Gif%E6%92%AD%E6%94%BE%E4%B8%8E%E6%9A%82%E5%81%9C/"/>
    <id>http://gcblog/github.io/2017/11/14/Gif播放与暂停/</id>
    <published>2017-11-14T02:13:08.000Z</published>
    <updated>2017-11-14T02:15:27.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gif播放的两种方式"><a href="#gif播放的两种方式" class="headerlink" title="gif播放的两种方式"></a>gif播放的两种方式</h2><h3 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h3><p>这应该是播放gif文件最简单的方式了，缺点：无法暂停播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//1. 把gif文件 转化成 data</div><div class="line">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class="line">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class="line"></div><div class="line">//2. 给UIWebView 设置data</div><div class="line">let webview = UIWebView()</div><div class="line">webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)</div><div class="line">webview.scalesPageToFit = true</div><div class="line">webview.load(gifData as Data, mimeType: &quot;image/gif&quot;, textEncodingName: String(), baseURL: NSURL() as URL)</div><div class="line">self.view.addSubview(webview)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h3><p>这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">let imageView = UIImageView()</div><div class="line">imageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)</div><div class="line">self.view.addSubview(imageView)</div><div class="line"></div><div class="line">// 1. 把gif文件 转化成 data</div><div class="line">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class="line">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class="line"></div><div class="line">// 2. 把data 转换成CGImageSource 对象</div><div class="line">guard let imageSource = CGImageSourceCreateWithData(gifData, nil) else &#123; return &#125;</div><div class="line">// 2.1 获取图片的个数</div><div class="line">let imageCount = CGImageSourceGetCount(imageSource)</div><div class="line"></div><div class="line">var images = [UIImage]()</div><div class="line">var gifDuration : TimeInterval = 0</div><div class="line">// 3. 遍历所有的图片</div><div class="line">for i in 0..&lt;imageCount &#123;</div><div class="line">    // 3.1 取出图片</div><div class="line">   guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil)  else &#123; return &#125;</div><div class="line"></div><div class="line">    let image = UIImage(cgImage: cgimage)</div><div class="line">    images.append(image)</div><div class="line">    if (i == 0) &#123;</div><div class="line">        imageView.image = image</div><div class="line">    &#125;</div><div class="line">    // 3.1 取出每张图片持续的时间</div><div class="line">    guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else &#123; continue &#125;</div><div class="line">    guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else &#123; continue &#125;</div><div class="line">    guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else &#123; continue &#125;</div><div class="line">    gifDuration += imageDuration.doubleValue</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 4.设置images属性</div><div class="line">imageView.animationImages = images</div><div class="line">imageView.animationDuration = gifDuration</div><div class="line">imageView.animationRepeatCount = 1</div><div class="line"></div><div class="line">// 5. 开始播放</div><div class="line">imageView.startAnimating()</div></pre></td></tr></table></figure>
<h2 id="Gif暂停实现"><a href="#Gif暂停实现" class="headerlink" title="Gif暂停实现"></a>Gif暂停实现</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gif播放的两种方式&quot;&gt;&lt;a href=&quot;#gif播放的两种方式&quot; class=&quot;headerlink&quot; title=&quot;gif播放的两种方式&quot;&gt;&lt;/a&gt;gif播放的两种方式&lt;/h2&gt;&lt;h3 id=&quot;UIWebView&quot;&gt;&lt;a href=&quot;#UIWebView&quot; class=&quot;headerlink&quot; title=&quot;UIWebView&quot;&gt;&lt;/a&gt;UIWebView&lt;/h3&gt;&lt;p&gt;这应该是播放gif文件最简单的方式了，缺点：无法暂停播放&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//1. 把gif文件 转化成 data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;guard let dataPath = Bundle.main.path(forResource: &amp;quot;demo&amp;quot;, ofType: &amp;quot;gif&amp;quot;) else &amp;#123; return &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;guard let gifData = NSData(contentsOfFile: dataPath) else &amp;#123; return &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//2. 给UIWebView 设置data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let webview = UIWebView()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webview.scalesPageToFit = true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webview.load(gifData as Data, mimeType: &amp;quot;image/gif&amp;quot;, textEncodingName: String(), baseURL: NSURL() as URL)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;self.view.addSubview(webview)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swfit" scheme="http://gcblog/github.io/categories/Swfit/"/>
    
    
      <category term="Swift" scheme="http://gcblog/github.io/tags/Swift/"/>
    
      <category term="Gif" scheme="http://gcblog/github.io/tags/Gif/"/>
    
      <category term="动画" scheme="http://gcblog/github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="runloop" scheme="http://gcblog/github.io/tags/runloop/"/>
    
      <category term="CADisplayLink" scheme="http://gcblog/github.io/tags/CADisplayLink/"/>
    
  </entry>
  
  <entry>
    <title>iOS三种录制视频方式详细对比</title>
    <link href="http://gcblog/github.io/2017/03/22/iOS%E4%B8%89%E7%A7%8D%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91%E6%96%B9%E5%BC%8F%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94/"/>
    <id>http://gcblog/github.io/2017/03/22/iOS三种录制视频方式详细对比/</id>
    <published>2017-03-21T16:24:33.000Z</published>
    <updated>2017-03-21T16:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先附上参考资料"><a href="#先附上参考资料" class="headerlink" title="先附上参考资料"></a>先附上参考资料</h3><p><a href="http://www.jianshu.com/p/16cb14f53933" target="_blank" rel="external">http://www.jianshu.com/p/16cb14f53933</a></p>
<p><a href="https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html" target="_blank" rel="external">https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html</a></p>
<p><a href="https://github.com/objcio/VideoCaptureDemo" target="_blank" rel="external">https://github.com/objcio/VideoCaptureDemo</a></p>
<p><a href="https://github.com/gsixxxx/DTSmallVideo" target="_blank" rel="external">https://github.com/gsixxxx/DTSmallVideo</a></p>
<p><a href="https://github.com/AndyFightting/VideoRecord" target="_blank" rel="external">https://github.com/AndyFightting/VideoRecord</a></p>
<h3 id="卷首吐槽语"><a href="#卷首吐槽语" class="headerlink" title="卷首吐槽语"></a>卷首吐槽语</h3><p>这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。</p>
<p>先附上dome <a href="https://github.com/suifengqjn/VideoRecord" target="_blank" rel="external">demo地址</a></p>
<h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p>方便大家对三中录制方式有一个大概的了解，看一下这张图片。<br><img src="https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true" alt="基本属性与类"><br>第一种采用系统的录制较为简单，详细介绍后面两种。<br><a id="more"></a></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c1.png" alt="1"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c2.png" alt="2"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c3.png" alt="3"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c4.png" alt="4"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c5.png" alt="5"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c6.png" alt="6"></p>
<p>demo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。</p>
<h3 id="1-UIImagePickerController"><a href="#1-UIImagePickerController" class="headerlink" title="1.UIImagePickerController"></a>1.UIImagePickerController</h3><p>这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    if ([self isVideoRecordingAvailable]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.sourceType = UIImagePickerControllerSourceTypeCamera;</div><div class="line">    self.mediaTypes = @[(NSString *)kUTTypeMovie];</div><div class="line">    self.delegate = self;</div><div class="line">    </div><div class="line">    //隐藏系统自带UI</div><div class="line">    self.showsCameraControls = NO;</div><div class="line">    //设置摄像头</div><div class="line">    [self switchCameraIsFront:NO];</div><div class="line">    //设置视频画质类别</div><div class="line">    self.videoQuality = UIImagePickerControllerQualityTypeMedium;</div><div class="line">    //设置散光灯类型</div><div class="line">    self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;</div><div class="line">    //设置录制的最大时长</div><div class="line">    self.videoMaximumDuration = 20;</div><div class="line">&#125;</div><div class="line">- (BOOL)isVideoRecordingAvailable</div><div class="line">&#123;</div><div class="line">    if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])&#123;</div><div class="line">        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class="line">        if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie])&#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)switchCameraIsFront:(BOOL)front</div><div class="line">&#123;</div><div class="line">    if (front) &#123;</div><div class="line">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront])&#123;</div><div class="line">            [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear])&#123;</div><div class="line">            [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-AVCaptureSession-AVCaptureMovieFileOutput"><a href="#2-AVCaptureSession-AVCaptureMovieFileOutput" class="headerlink" title="2.AVCaptureSession+AVCaptureMovieFileOutput"></a>2.AVCaptureSession+AVCaptureMovieFileOutput</h3><p>流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 创建捕捉会话</div><div class="line">2. 设置视频的输入</div><div class="line">3. 设置音频的输入</div><div class="line">4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据</div><div class="line">5. 添加视频预览层</div><div class="line">6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div></pre></td></tr></table></figure></p>
<h4 id="0-创建捕捉会话"><a href="#0-创建捕捉会话" class="headerlink" title="0. 创建捕捉会话"></a>0. 创建捕捉会话</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.session = [[AVCaptureSession alloc] init];</div><div class="line">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class="line">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="1-视频的输入"><a href="#1-视频的输入" class="headerlink" title="1. 视频的输入"></a>1. 视频的输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   - (void)setUpVideo</div><div class="line">&#123;</div><div class="line">    // 1.1 获取视频输入设备(摄像头)</div><div class="line">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class="line">    </div><div class="line">    // 视频 HDR (高动态范围图像)</div><div class="line">    // videoCaptureDevice.videoHDREnabled = YES;</div><div class="line">    // 设置最大，最小帧速率</div><div class="line">    //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60);</div><div class="line">    // 1.2 创建视频输入源</div><div class="line">    NSError *error=nil;</div><div class="line">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class="line">    // 1.3 将视频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">        [self.session addInput:self.videoInput];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-音频的输入"><a href="#2-音频的输入" class="headerlink" title="2. 音频的输入"></a>2. 音频的输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 2.1 获取音频输入设备</div><div class="line">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class="line">    NSError *error=nil;</div><div class="line">    // 2.2 创建音频输入源</div><div class="line">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class="line">    // 2.3 将音频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class="line">        [self.session addInput:self.audioInput];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="3-输出源设置"><a href="#3-输出源设置" class="headerlink" title="3.输出源设置"></a>3.输出源设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)setUpFileOut</div><div class="line">&#123;</div><div class="line">    // 3.1初始化设备输出对象，用于获得输出数据</div><div class="line">    self.FileOutput=[[AVCaptureMovieFileOutput alloc]init];</div><div class="line">    </div><div class="line">    // 3.2设置输出对象的一些属性</div><div class="line">    AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class="line">    //设置防抖</div><div class="line">    //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</div><div class="line">    if ([captureConnection isVideoStabilizationSupported ]) &#123;</div><div class="line">        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;</div><div class="line">    &#125;</div><div class="line">    //预览图层和视频方向保持一致</div><div class="line">    captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation;</div><div class="line">    </div><div class="line">    // 3.3将设备输出添加到会话中</div><div class="line">    if ([_session canAddOutput:_FileOutput]) &#123;</div><div class="line">        [_session addOutput:_FileOutput];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-视频预览层"><a href="#4-视频预览层" class="headerlink" title="4. 视频预览层"></a>4. 视频预览层</h4><p>一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class="line">&#123;</div><div class="line">    CGRect rect = CGRectZero;</div><div class="line">    switch (type) &#123;</div><div class="line">        case Type1X1:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class="line">            break;</div><div class="line">        case Type4X3:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class="line">            break;</div><div class="line">        case TypeFullScreen:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    self.previewlayer.frame = rect;</div><div class="line">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-开始采集画面"><a href="#5-开始采集画面" class="headerlink" title="5. 开始采集画面"></a>5. 开始采集画面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.session startRunning];</div></pre></td></tr></table></figure>
<h4 id="6-开始录制"><a href="#6-开始录制" class="headerlink" title="6.开始录制"></a>6.开始录制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)writeDataTofile</div><div class="line">&#123;</div><div class="line">    NSString *videoPath = [self createVideoFilePath];</div><div class="line">    self.videoUrl = [NSURL fileURLWithPath:videoPath];</div><div class="line">    [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-AVCaptureSession-AVAssetWriter"><a href="#3-AVCaptureSession-AVAssetWriter" class="headerlink" title="3.AVCaptureSession+AVAssetWriter"></a>3.AVCaptureSession+AVAssetWriter</h3><p>流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 创建捕捉会话</div><div class="line">2. 设置视频的输入 和 输出</div><div class="line">3. 设置音频的输入 和 输出</div><div class="line">4. 添加视频预览层</div><div class="line">5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div><div class="line">6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。</div></pre></td></tr></table></figure></p>
<h4 id="1-创建捕捉会话"><a href="#1-创建捕捉会话" class="headerlink" title="1. 创建捕捉会话"></a>1. 创建捕捉会话</h4><p>需要确保在同一个队列，最好队列只创建一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.session = [[AVCaptureSession alloc] init];</div><div class="line">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class="line">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-设置视频的输入-和-输出"><a href="#2-设置视频的输入-和-输出" class="headerlink" title="2.设置视频的输入 和 输出"></a>2.设置视频的输入 和 输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)setUpVideo</div><div class="line">&#123;</div><div class="line">    // 2.1 获取视频输入设备(摄像头)</div><div class="line">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class="line">    // 2.2 创建视频输入源</div><div class="line">    NSError *error=nil;</div><div class="line">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class="line">    // 2.3 将视频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">        [self.session addInput:self.videoInput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoOutput = [[AVCaptureVideoDataOutput alloc] init];</div><div class="line">    self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES</div><div class="line">    [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class="line">    if ([self.session canAddOutput:self.videoOutput]) &#123;</div><div class="line">        [self.session addOutput:self.videoOutput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-设置音频的输入-和-输出"><a href="#3-设置音频的输入-和-输出" class="headerlink" title="3. 设置音频的输入 和 输出"></a>3. 设置音频的输入 和 输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)setUpAudio</div><div class="line">&#123;</div><div class="line">    // 2.2 获取音频输入设备</div><div class="line">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class="line">    NSError *error=nil;</div><div class="line">    // 2.4 创建音频输入源</div><div class="line">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class="line">    // 2.6 将音频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class="line">        [self.session addInput:self.audioInput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.audioOutput = [[AVCaptureAudioDataOutput alloc] init];</div><div class="line">    [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class="line">    if([self.session canAddOutput:self.audioOutput]) &#123;</div><div class="line">        [self.session addOutput:self.audioOutput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-添加视频预览层"><a href="#4-添加视频预览层" class="headerlink" title="4. 添加视频预览层"></a>4. 添加视频预览层</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class="line">&#123;</div><div class="line">    CGRect rect = CGRectZero;</div><div class="line">    switch (type) &#123;</div><div class="line">        case Type1X1:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class="line">            break;</div><div class="line">        case Type4X3:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class="line">            break;</div><div class="line">        case TypeFullScreen:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.previewlayer.frame = rect;</div><div class="line">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-开始采集画面-1"><a href="#5-开始采集画面-1" class="headerlink" title="5. 开始采集画面"></a>5. 开始采集画面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.session startRunning];</div></pre></td></tr></table></figure>
<h4 id="6-初始化AVAssetWriter"><a href="#6-初始化AVAssetWriter" class="headerlink" title="6. 初始化AVAssetWriter"></a>6. 初始化AVAssetWriter</h4><p>AVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setUpWriter</div><div class="line">&#123;</div><div class="line">    self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]];</div><div class="line">    self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType];</div><div class="line">    self.writeManager.delegate = self;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-拿到数据流后处理"><a href="#7-拿到数据流后处理" class="headerlink" title="7.拿到数据流后处理"></a>7.拿到数据流后处理</h4><p>视频数据和音频数据需要分开处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        //视频</div><div class="line">        if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) &#123;</div><div class="line">            </div><div class="line">            if (!self.writeManager.outputVideoFormatDescription) &#123;</div><div class="line">                @synchronized(self) &#123;</div><div class="line">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">                    self.writeManager.outputVideoFormatDescription = formatDescription;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                @synchronized(self) &#123;</div><div class="line">                    if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class="line">                        [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo];</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //音频</div><div class="line">        if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) &#123;</div><div class="line">            if (!self.writeManager.outputAudioFormatDescription) &#123;</div><div class="line">                @synchronized(self) &#123;</div><div class="line">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">                    self.writeManager.outputAudioFormatDescription = formatDescription;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            @synchronized(self) &#123;</div><div class="line">                </div><div class="line">                if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class="line">                    [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们拿到最原始的数据以后，可以对其进行各种参数的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (void)setUpWriter</div><div class="line">&#123;</div><div class="line">    self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil];</div><div class="line">    //写入视频大小</div><div class="line">    NSInteger numPixels = self.outputSize.width * self.outputSize.height;</div><div class="line">    //每像素比特</div><div class="line">    CGFloat bitsPerPixel = 6.0;</div><div class="line">    NSInteger bitsPerSecond = numPixels * bitsPerPixel;</div><div class="line">    </div><div class="line">    // 码率和帧率设置</div><div class="line">    NSDictionary *compressionProperties = @&#123; AVVideoAverageBitRateKey : @(bitsPerSecond),</div><div class="line">                                             AVVideoExpectedSourceFrameRateKey : @(30),</div><div class="line">                                             AVVideoMaxKeyFrameIntervalKey : @(30),</div><div class="line">                                             AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel &#125;;</div><div class="line">    </div><div class="line">    //视频属性</div><div class="line">    self.videoCompressionSettings = @&#123; AVVideoCodecKey : AVVideoCodecH264,</div><div class="line">                                       AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,</div><div class="line">                                       AVVideoWidthKey : @(self.outputSize.height),</div><div class="line">                                       AVVideoHeightKey : @(self.outputSize.width),</div><div class="line">                                       AVVideoCompressionPropertiesKey : compressionProperties &#125;;</div><div class="line"></div><div class="line">    _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];</div><div class="line">    //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据</div><div class="line">    _assetWriterVideoInput.expectsMediaDataInRealTime = YES;</div><div class="line">    _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0);</div><div class="line">    </div><div class="line">    </div><div class="line">    // 音频设置</div><div class="line">    self.audioCompressionSettings = @&#123; AVEncoderBitRatePerChannelKey : @(28000),</div><div class="line">                                       AVFormatIDKey : @(kAudioFormatMPEG4AAC),</div><div class="line">                                       AVNumberOfChannelsKey : @(1),</div><div class="line">                                       AVSampleRateKey : @(22050) &#125;;</div><div class="line">    </div><div class="line">    </div><div class="line">    _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings];</div><div class="line">    _assetWriterAudioInput.expectsMediaDataInRealTime = YES;</div><div class="line">    </div><div class="line">    </div><div class="line">    if ([_assetWriter canAddInput:_assetWriterVideoInput]) &#123;</div><div class="line">        [_assetWriter addInput:_assetWriterVideoInput];</div><div class="line">    &#125;else &#123;</div><div class="line">        NSLog(@&quot;AssetWriter videoInput append Failed&quot;);</div><div class="line">    &#125;</div><div class="line">    if ([_assetWriter canAddInput:_assetWriterAudioInput]) &#123;</div><div class="line">        [_assetWriter addInput:_assetWriterAudioInput];</div><div class="line">    &#125;else &#123;</div><div class="line">        NSLog(@&quot;AssetWriter audioInput Append Failed&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.writeState = FMRecordStateRecording;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。</p>
<h3 id="fileOut和writer的相同点和不同点"><a href="#fileOut和writer的相同点和不同点" class="headerlink" title="fileOut和writer的相同点和不同点"></a>fileOut和writer的相同点和不同点</h3><p>从上面的两个流程大致可以看出来，<br>相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。<br>不同点：<br>输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。<br>AVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。</p>
<p>可配参数不一致，AVAssetWriter可以配置更多的参数。</p>
<p>视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。</p>
<p>其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。</p>
<p><a href="https://github.com/suifengqjn/VideoRecord" target="_blank" rel="external">demo地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先附上参考资料&quot;&gt;&lt;a href=&quot;#先附上参考资料&quot; class=&quot;headerlink&quot; title=&quot;先附上参考资料&quot;&gt;&lt;/a&gt;先附上参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/16cb14f53933&quot;&gt;http://www.jianshu.com/p/16cb14f53933&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html&quot;&gt;https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/objcio/VideoCaptureDemo&quot;&gt;https://github.com/objcio/VideoCaptureDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gsixxxx/DTSmallVideo&quot;&gt;https://github.com/gsixxxx/DTSmallVideo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AndyFightting/VideoRecord&quot;&gt;https://github.com/AndyFightting/VideoRecord&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;卷首吐槽语&quot;&gt;&lt;a href=&quot;#卷首吐槽语&quot; class=&quot;headerlink&quot; title=&quot;卷首吐槽语&quot;&gt;&lt;/a&gt;卷首吐槽语&lt;/h3&gt;&lt;p&gt;这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。&lt;/p&gt;
&lt;p&gt;先附上dome &lt;a href=&quot;https://github.com/suifengqjn/VideoRecord&quot;&gt;demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;脑图&quot;&gt;&lt;a href=&quot;#脑图&quot; class=&quot;headerlink&quot; title=&quot;脑图&quot;&gt;&lt;/a&gt;脑图&lt;/h3&gt;&lt;p&gt;方便大家对三中录制方式有一个大概的了解，看一下这张图片。&lt;br&gt;&lt;img src=&quot;https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true&quot; alt=&quot;基本属性与类&quot;&gt;&lt;br&gt;第一种采用系统的录制较为简单，详细介绍后面两种。&lt;br&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="视频" scheme="http://gcblog/github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="录制视频" scheme="http://gcblog/github.io/tags/%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>instruments实践</title>
    <link href="http://gcblog/github.io/2017/01/01/instruments%E5%AE%9E%E8%B7%B5/"/>
    <id>http://gcblog/github.io/2017/01/01/instruments实践/</id>
    <published>2017-01-01T09:24:39.000Z</published>
    <updated>2017-05-23T16:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个”意外”，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的：</p>
<h3 id="第一步：查看dealloc"><a href="#第一步：查看dealloc" class="headerlink" title="第一步：查看dealloc"></a>第一步：查看dealloc</h3><p>看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。<br><a id="more"></a></p>
<h3 id="第二步：查看内存-cpu"><a href="#第二步：查看内存-cpu" class="headerlink" title="第二步：查看内存,cpu"></a>第二步：查看内存,cpu</h3><p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/1.png" alt="查看运行状态的内存cpu"></p>
<p>我先后两次进入到这个页面，发现刚进入这个页面的瞬间内存飚的很高，然后瞬间又降下来，到这里问题已经变得明显了，这个页面确实存在问题，下面就需要深入的寻找问题所在。</p>
<h3 id="第三步：Profile"><a href="#第三步：Profile" class="headerlink" title="第三步：Profile"></a>第三步：Profile</h3><p>直接在上图的右上角点击 Profile in instruments,<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/2.png" alt="查看运行状态的内存cpu"><br>进入instruments后，我还是重复之前的操作，进入这个问题页面，还是发现了内存飙高的情况，然后我在下面的堆栈里找，发现怎么也找不到到底是哪个方法引起的。<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/3.png" alt="查看运行状态的内存cpu"><br>然后我发现上面的内存图上有条线可以拖动，然后我就把它拖到内存最高的地方，然后再去下面找，发现还是找不到。<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/4.png" alt="查看运行状态的内存cpu"><br>最后，我尝试在内存飙高的同时，点击左上角暂停运行，然后再下面的堆栈中继续找，这回终于找到了，是我自己的一个类渲染UI的时候导致的内存问题，找到具体的原因，解决起来也就轻松了。光看果然是没有用的，重要的还是要实践。</p>
<p>leak 右侧几个属性选项<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/7.png" alt="几个属性含义"></p>
<p>Separate by Thread（建议选择）   按照线程分类查看哪些占用cpu最多<br>Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。<br>Hidden System Librares (建议选择)   隐藏系统类库方法<br>Flatten Recursion （一般不选）：选上它会将调用栈里递归函数作为一个入口。<br>Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个”意外”，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的：&lt;/p&gt;
&lt;h3 id=&quot;第一步：查看dealloc&quot;&gt;&lt;a href=&quot;#第一步：查看dealloc&quot; class=&quot;headerlink&quot; title=&quot;第一步：查看dealloc&quot;&gt;&lt;/a&gt;第一步：查看dealloc&lt;/h3&gt;&lt;p&gt;看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。&lt;br&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="crash" scheme="http://gcblog/github.io/tags/crash/"/>
    
      <category term="性能" scheme="http://gcblog/github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="instruments" scheme="http://gcblog/github.io/tags/instruments/"/>
    
  </entry>
  
  <entry>
    <title>iOS数组防止越界crash</title>
    <link href="http://gcblog/github.io/2016/12/24/iOS%E6%95%B0%E7%BB%84%E9%98%B2%E6%AD%A2%E8%B6%8A%E7%95%8Ccrash/"/>
    <id>http://gcblog/github.io/2016/12/24/iOS数组防止越界crash/</id>
    <published>2016-12-24T07:45:55.000Z</published>
    <updated>2016-12-24T07:52:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。</p>
<h3 id="crash的具体几种情况"><a href="#crash的具体几种情况" class="headerlink" title="crash的具体几种情况"></a>crash的具体几种情况</h3><ul>
<li>取值：index超出array的索引范围</li>
<li>添加：插入的object为nil或者Null</li>
<li>插入：index大于count、插入的object为nil或者Null</li>
<li>删除：index超出array的索引范围</li>
<li>替换：index超出array的索引范围、替换的object为nil或者Null</li>
</ul>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>任何代码都需要围绕”高内聚，低耦合”的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的<a href="https://github.com/wanyakun/YKIntercepter" target="_blank" rel="external">demo</a>。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决：<br><a id="more"></a></p>
<ul>
<li><p>这是系统原本的调用方式<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/12.png" alt="这是系统原本的调用方式"></p>
</li>
<li><p>这是改变之后的调用方式<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/13.png" alt="这是改变之后的调用方式"></p>
</li>
</ul>
<p>我是先勾住array自带的方法，进行判断，如果没有越界等几种情况，再继续执行它自身的方法，相当于在执行方法前多了一步判断，而网上是直接把方法替换成自己的方法了，这里还是有本质的区别。</p>
<h3 id="具体实现原理"><a href="#具体实现原理" class="headerlink" title="具体实现原理"></a>具体实现原理</h3><p>这里举例说明 <code>NSArray</code> 的 <code>addObject:</code> 方法，其他也类似。</p>
<h4 id="先定义一个静态变量"><a href="#先定义一个静态变量" class="headerlink" title="先定义一个静态变量"></a>先定义一个静态变量</h4><p><code>static IMP array_old_func_imap_object = NULL;</code><br>这个变量用来记录array自带方法的指针地址</p>
<h4 id="获取方法，然后记录方法的指针地址"><a href="#获取方法，然后记录方法的指针地址" class="headerlink" title="获取方法，然后记录方法的指针地址"></a>获取方法，然后记录方法的指针地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method old_func_imap_object = class_getInstanceMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:));</div><div class="line">            array_old_func_imap_object = method_getImplementation(old_func_imap_object);</div></pre></td></tr></table></figure>
<h4 id="改变原方法的指针地址，并指向自定义方法"><a href="#改变原方法的指针地址，并指向自定义方法" class="headerlink" title="改变原方法的指针地址，并指向自定义方法"></a>改变原方法的指针地址，并指向自定义方法</h4><p><code>method_setImplementation(old_func_imap_object, [self methodForSelector:@selector(fm_objectAtIndex:)]);</code></p>
<h4 id="自定义方法的实现"><a href="#自定义方法的实现" class="headerlink" title="自定义方法的实现"></a>自定义方法的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)fm_objectAtIndex:(NSUInteger)index &#123;</div><div class="line">    if (index &lt; [(NSArray*)self count]) &#123;</div><div class="line">        return ((id(*)(id, SEL, NSUInteger))array_old_func_imap_object)(self, @selector(objectAtIndex:), index);</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;NArray objectAtIndex 失败--%@&quot;, [NSThread callStackSymbols]);</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h4><p>到这里已经差不多完成了，就剩最后一个问题了，就是怎么运用到项目中，让这个工具类继承自NSObject，把这个工具类写成一个单例，然后在load方法中调用单例。load 方法会在本类第一次使用的时候调用一次，所以，把这个工具类拖到项目中，不用写其他代码，就实现了以上的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    [FMDetecter sharedInstance];</div><div class="line">&#125;</div><div class="line"></div><div class="line">static dispatch_once_t onceToken;</div><div class="line">static FMDetecter *sharedInstance;</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedInstance = [[FMDetecter alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有完整的代码，有兴趣可查看<a href="https://github.com/suifengqjn/FMArrarMonitor" target="_blank" rel="external">demo</a></p>
<h3 id="实际出现的问题"><a href="#实际出现的问题" class="headerlink" title="实际出现的问题"></a>实际出现的问题</h3><p>我用这两种方式都试了试，新建一个空项目，然后把上面几个方法都试一遍，似乎都没问题，然后我把他们公司的项目中，程序有时候卡死，还会crash，还是没法用，两种方式都有问题，找了找原因，发现NSArray和NSMutableArray的那几个方法，系统自己会调用很多很多次，极大的影响了性能，还有网友遇到了其他的问题：替换了objectAtIndex方法有输入的地方出来了软键盘按手机Home键就Crash了。简直无解，最后，还是决定写个分类，虽然low一点，毕竟还是能解决我的问题，并且不会带来新的问题。</p>
<h4 id="这是给NSArray添加的方法"><a href="#这是给NSArray添加的方法" class="headerlink" title="这是给NSArray添加的方法"></a>这是给NSArray添加的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSArray+beyond.h&quot;</div><div class="line"></div><div class="line">@implementation NSArray (beyond)</div><div class="line">-(id)objectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &lt; self.count) &#123;</div><div class="line">        return [self objectAtIndex:index];</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="这是给NSMutableArray添加的方法"><a href="#这是给NSMutableArray添加的方法" class="headerlink" title="这是给NSMutableArray添加的方法"></a>这是给NSMutableArray添加的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSMutableArray+beyond.h&quot;</div><div class="line"></div><div class="line">@implementation NSMutableArray (beyond)</div><div class="line">-(id)objectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &lt; self.count) &#123;</div><div class="line">        return [self objectAtIndex:index];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line">- (void)addObjectCheck:(id)anObject</div><div class="line">&#123;</div><div class="line">    if (anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class="line">        [self addObject:anObject];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)insertObjectCheck:(id)anObject atIndex:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &lt;= self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class="line">        [self insertObject:anObject atIndex:index];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeObjectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &lt; self.count) &#123;</div><div class="line">        [self removeObjectAtIndex:index];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)replaceObjectAtIndexCheck:(NSUInteger)index withObject:(id)anObject</div><div class="line">&#123;</div><div class="line">    if (index &lt; self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class="line">        [self replaceObjectAtIndex:index withObject:anObject];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。&lt;/p&gt;
&lt;h3 id=&quot;crash的具体几种情况&quot;&gt;&lt;a href=&quot;#crash的具体几种情况&quot; class=&quot;headerlink&quot; title=&quot;crash的具体几种情况&quot;&gt;&lt;/a&gt;crash的具体几种情况&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;取值：index超出array的索引范围&lt;/li&gt;
&lt;li&gt;添加：插入的object为nil或者Null&lt;/li&gt;
&lt;li&gt;插入：index大于count、插入的object为nil或者Null&lt;/li&gt;
&lt;li&gt;删除：index超出array的索引范围&lt;/li&gt;
&lt;li&gt;替换：index超出array的索引范围、替换的object为nil或者Null&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;解决思路&quot;&gt;&lt;a href=&quot;#解决思路&quot; class=&quot;headerlink&quot; title=&quot;解决思路&quot;&gt;&lt;/a&gt;解决思路&lt;/h3&gt;&lt;p&gt;任何代码都需要围绕”高内聚，低耦合”的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的&lt;a href=&quot;https://github.com/wanyakun/YKIntercepter&quot;&gt;demo&lt;/a&gt;。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决：&lt;br&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="越界" scheme="http://gcblog/github.io/tags/%E8%B6%8A%E7%95%8C/"/>
    
      <category term="NSArray" scheme="http://gcblog/github.io/tags/NSArray/"/>
    
      <category term="NSMutableArray" scheme="http://gcblog/github.io/tags/NSMutableArray/"/>
    
      <category term="crash" scheme="http://gcblog/github.io/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>Swift小结</title>
    <link href="http://gcblog/github.io/2016/11/29/Swift%E5%B0%8F%E7%BB%93/"/>
    <id>http://gcblog/github.io/2016/11/29/Swift小结/</id>
    <published>2016-11-29T15:30:40.000Z</published>
    <updated>2016-12-03T16:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ul>
<li>格式 <code>lazy var 变量: 类型 = { 创建变量代码 }()</code></li>
<li>以 <code>lazy var</code> 开头，闭包末尾跟一个’()’</li>
<li>懒加载的写法本质上是定义并执行一个闭包</li>
<li>好处：没有解包的麻烦，并且 延迟创建</li>
<li>与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行<br>懒加载完整的写法：<br>eg:懒加载一个数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lazy var dataList: [String] = &#123; () -&gt; [String] in</div><div class="line">        return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>in 和 前面的代码块可以省略，写成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lazy var dataList: [String] = &#123;</div><div class="line">        return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了</p>
<p><code>lazy var dataList: [String] = [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</code></p>
<p>比如懒加载一个label</p>
<p><code>lazy var label: UILabel = UIlabel()</code></p>
<p>如果对label需要添加其他属性，就可以写成带（）的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lazy var label :UILabel = &#123;</div><div class="line">       let label = UILabel()</div><div class="line">        label.font = UIFont.systemFont(ofSize: 15)</div><div class="line">        label.textColor = UIColor.red</div><div class="line">        return label</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="extension"><a href="#extension" class="headerlink" title="extension"></a>extension</h3><p>swift中一个类只有一个.m文件，所有代码都会写在.m中，代码多了，难免就会混乱，<code>extension</code> 就是用来隔离代码用的。<br>extension最常用的几个地方：</p>
<h4 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extension HomeViewController : UITableViewdelegate,UItableViewDataSource &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对类的扩展"><a href="#对类的扩展" class="headerlink" title="对类的扩展"></a>对类的扩展</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">//对UIBarButtonItem UIbarButton 的一个扩展</div><div class="line">extension UIBarButtonItem &#123;</div><div class="line">    // 便利构造函数</div><div class="line">    convenience init(imageName: String, highImageName: String, size: CGSize = CGSize.zero) &#123;</div><div class="line">        </div><div class="line">        let btn = UIButton();</div><div class="line">       </div><div class="line">        btn.setImage(UIImage(named: imageName), for: UIControlState())</div><div class="line">        if(highImageName != &quot;&quot;) &#123;</div><div class="line">            btn.setImage(UIImage(named: highImageName), for: .highlighted)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if size == CGSize.zero &#123;</div><div class="line">            btn.sizeToFit()</div><div class="line">        &#125;else &#123;</div><div class="line">            btn.frame = CGRect(origin: CGPoint.zero, size: size)</div><div class="line">        &#125;</div><div class="line">        self.init(customView: btn)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="本类中的私有方法"><a href="#本类中的私有方法" class="headerlink" title="本类中的私有方法"></a>本类中的私有方法</h4><p>extension 外如果想调用extension 内的私有方法，需要加上<code>fileprivate</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// MARK: - 设置UI界面</div><div class="line">extension HomeController &#123;</div><div class="line">    fileprivate func setupUI() &#123;</div><div class="line">        setupNavgationbar()</div><div class="line">    &#125;</div><div class="line">    private func setupNavgationbar() &#123;</div><div class="line">   self.navigationItem.leftBarButtonItem = UIBarButtonItem(imageName:&quot;logo&quot;)</div><div class="line">           </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Swift宏定义"><a href="#Swift宏定义" class="headerlink" title="Swift宏定义"></a>Swift宏定义</h3><p>Swift中没有宏的存在，但是有其他实现的方法。而且Swift共享整个命名空间，不在需要.pch文件。新建一个Swfit file文件，最好导入UIKit框架，没有参数的宏直接使用常量定义即可，有参数的宏使用函数代替</p>
<h4 id="无参数的宏"><a href="#无参数的宏" class="headerlink" title="无参数的宏"></a>无参数的宏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//oc中的宏定义</div><div class="line">#define kIOS7   [UIDevice currentDevice].systemVersion.doubleValue&gt;=7.0 ? 1 :0</div><div class="line">#define kIOS8   [UIDevice currentDevice].systemVersion.doubleValue&gt;=8.0 ? 1 :0</div><div class="line">#define kScreenHeight     [UIScreen mainScreen].bounds.size.height</div><div class="line">#define kScreenWidth      [UIScreen mainScreen].bounds.size.width</div><div class="line">//转换成Swift的写法</div><div class="line">let kIOS7 = Double(UIDevice().systemVersion)&gt;=7.0 ? 1 :0</div><div class="line">let kIOS8 = Double(UIDevice().systemVersion)&gt;=8.0 ? 1 :0</div><div class="line"></div><div class="line">let kScreenHeight = UIScreen.mainScreen().bounds.size.height</div><div class="line">let kScreenWidth = UIScreen.mainScreen().bounds.size.width</div></pre></td></tr></table></figure>
<h4 id="有参数的宏"><a href="#有参数的宏" class="headerlink" title="有参数的宏"></a>有参数的宏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//oc写法</div><div class="line">#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]</div><div class="line">//Swift中的写法</div><div class="line">func RGBCOLOR(r:CGFloat,_ g:CGFloat,_ b:CGFloat) -&gt; UIColor</div><div class="line">&#123;</div><div class="line">    return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Swift中weakSelf-的-写法"><a href="#Swift中weakSelf-的-写法" class="headerlink" title="Swift中weakSelf 的 写法"></a>Swift中weakSelf 的 写法</h3><h4 id="第一种-类似OC的写法"><a href="#第一种-类似OC的写法" class="headerlink" title="第一种 类似OC的写法"></a>第一种 类似OC的写法</h4><p>这里只能用 <code>var</code> 修饰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">weak var weakSelf = self</div><div class="line">loadData &#123; (result) in</div><div class="line">    print(weakSelf?.view)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第二种-Swift推荐的方式"><a href="#第二种-Swift推荐的方式" class="headerlink" title="第二种 Swift推荐的方式"></a>第二种 Swift推荐的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loadData &#123; [weak self] (result) in</div><div class="line">     print(self?.view)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="第三种-不推荐使用"><a href="#第三种-不推荐使用" class="headerlink" title="第三种 不推荐使用"></a>第三种 不推荐使用</h4><p>[unowned self] 表示{} 中的 所有self 都是 assgined， 不会强引用，但是对象释放，指针地址不会变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//相当于 OC  __unsafe_unretain </div><div class="line">// 如果对象被释放，继续调用，就会出现野指针,有极大的安全隐患</div><div class="line">loadData &#123; [unowned self] (result) in</div><div class="line">		print(self.view) </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>Swift中单例写法较为简单，并且线程安全<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static let shared: XCRequest = &#123;</div><div class="line">     // 实例化对象</div><div class="line">     let instance = XCRequest()</div><div class="line">     // 返回对象</div><div class="line">     return instance</div><div class="line"> &#125;()</div></pre></td></tr></table></figure></p>
<p>还有另外一种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static let instance: XCRequest = XCRequest()</div><div class="line">    </div><div class="line">      class func shareManager() -&gt;XCRequest &#123;</div><div class="line">        </div><div class="line">      return instance  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter&amp;setter"></a>getter&amp;setter</h3><p>模仿OC的写法，事实上Swift不会这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var _name: String?</div><div class="line"></div><div class="line">var name: String? &#123;</div><div class="line">    get &#123;</div><div class="line">        return _name</div><div class="line">    &#125;</div><div class="line">    set &#123;</div><div class="line">        _name = newValue</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">      var age:Int&#123;</div><div class="line">        // 如果只重写了get,没有set. 那么属性是一个&quot;计算型&quot;属性</div><div class="line">        // 计算型属性不占用存储空间, 相当于OC中的readOnly</div><div class="line">        get&#123;</div><div class="line">            return 30</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    // 如果只有get可以简写为</div><div class="line">    var gender:String&#123;</div><div class="line">        return &quot;lnj&quot; </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h4><p>只有getter，没有setter的属性被称为计算型属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var title: String &#123; </div><div class="line">		get &#123; </div><div class="line">			return &quot;Mr &quot; + (name ?? &quot;&quot;) </div><div class="line">		&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>只实现 getter 方法的属性被称为计算型属性，等同于 OC 中的 ReadOnly 属性</li>
<li>计算型属性本身不占用内存空间</li>
<li>不可以给计算型属性设置数值</li>
</ul>
<p>计算型属性可以使用以下代码简写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var title: String &#123; </div><div class="line">	return &quot;Mr &quot; + (name ?? &quot;&quot;) </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="didSet"><a href="#didSet" class="headerlink" title="didSet"></a>didSet</h4><p>OC中最常见的就是重写setter方法，然后同时做一些额外的事情，那么Swift中就用didSet来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var room_list : [[String : NSObject]]? &#123;</div><div class="line">        didSet &#123;</div><div class="line">            guard let room_list = room_list else &#123; return &#125;</div><div class="line">            for dict in room_list &#123;</div><div class="line">                anchors.append(AnchorModel(dict: dict))</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="构造函数，析构函数"><a href="#构造函数，析构函数" class="headerlink" title="构造函数，析构函数"></a>构造函数，析构函数</h3><p>先了解两个概念</p>
<h4 id="方法重载："><a href="#方法重载：" class="headerlink" title="方法重载："></a>方法重载：</h4><pre><code>•    函数名相同，参数名／参数类型／参数个数不同
•    重载函数并不仅仅局限于构造函数
•    函数重载是面相对象程序设计语言的重要标志
•    OC 不支持函数重载，OC 的替代方式是 withXXX…
</code></pre><h4 id="方法重写："><a href="#方法重写：" class="headerlink" title="方法重写："></a>方法重写：</h4><pre><code>•    也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。
•    重写父类方法需要加override
•    重写是子类的方法覆盖父类的方法，要求方法名和参数都相同
•    因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。
•    重写必须继承，重载不用
</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Person: NSObject &#123;</div><div class="line"></div><div class="line">    var name: String</div><div class="line">    </div><div class="line">    ///最简单的必选属性的构造函数</div><div class="line">    ///构造函数的目的，给自己分配空间并设置初始值</div><div class="line">    ///属性的初始化放在super.init前面</div><div class="line">    /// 重写父类方法需要加override</div><div class="line">    override init () &#123;</div><div class="line">        </div><div class="line">        name = &quot;default name:Tom&quot;</div><div class="line">        </div><div class="line">        super.init()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// 如果实现了 构造函数的重载，并且没有重写构造函数，那么系统不再提供原始的init()函数</div><div class="line">    /// 方法重载（类似OC自定义初始化方法）</div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        super.init()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>相当于OC中的dealloc方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deinit &#123;</div><div class="line">    print(&quot;被释放了&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="guard-let-amp-if-let"><a href="#guard-let-amp-if-let" class="headerlink" title="guard let &amp; if let"></a>guard let &amp; if let</h3><p>相当于OC中用if来判断某个值是不是为空<br>我认为这个语法最大的好处是避免了写大量的 ？！，<br>用来判断的这个属性必须是可选的<br>guard 与 if 的区别是 guard只有在条件不满足的时候才会执行这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">guard let _:String = pe.name else &#123;</div><div class="line">		return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果要判断多个参数,一直在后面加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">guard let _ = pe.name, let _ = pe.title else &#123;</div><div class="line">            return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>if let 可以在条件成立或者不成立的情况下，在{}中分别处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if let name = pe.name &#123;</div><div class="line">            print(name)</div><div class="line">     &#125; else &#123;</div><div class="line">            return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>as 的三种情况</p>
<h4 id="as？"><a href="#as？" class="headerlink" title="as？"></a>as？</h4><pre><code>1.    前面的返回值是可选的
2.    guard let / if let 一定用 as?
</code></pre><h4 id="as-1"><a href="#as-1" class="headerlink" title="as!"></a>as!</h4><pre><code>1.    前面的返回值一定有值
</code></pre><h4 id="as-2"><a href="#as-2" class="headerlink" title="as"></a>as</h4><pre><code>1.    NSString -&gt; String
2.    NSArray -&gt;[ ]
3.    NSDictionary -&gt; [ ]
4.    这种情况是因为底层做了结构体和OC对象的桥接
</code></pre><h3 id="try-处理错误异常"><a href="#try-处理错误异常" class="headerlink" title="try 处理错误异常"></a>try 处理错误异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let jsonSTring = &quot;&#123;\&quot;name\&quot;: \&quot;zhang\&quot;]&quot;</div><div class="line">let data = jsonSTring.data(using: .utf8)</div><div class="line">//方法1. 推荐，如果解析成功就有值，否则 为nil</div><div class="line">let json1 = try? JSONSerialization.jsonObject(with: data!, options: [])</div><div class="line">print(json1 ?? &quot;json1 为 nil&quot;)</div><div class="line"></div><div class="line">//方法2. 墙裂不推荐 如果解析成功就有值，否则crash</div><div class="line">//let json2 = try! JSONSerialization.jsonObject(with: data!, options: [])</div><div class="line"></div><div class="line">//方法3. 异常处理,能够接受错误，可以在错误的情况下另行处理</div><div class="line">do &#123;</div><div class="line">    let json3 = try JSONSerialization.jsonObject(with: data!, options: [])</div><div class="line">    print(json3)</div><div class="line">&#125; catch &#123;</div><div class="line">    print(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func getWithPath(path: String,param: Dictionary&lt;String,Any&gt;?,completion: @escaping ((_ result: Any?, _ success:Bool) -&gt; ())) &#123;</div><div class="line">        </div><div class="line">        let url = URL(string: path.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!)</div><div class="line">        if let para = param &#123;</div><div class="line">            //对参数进行处理</div><div class="line">            print(para)</div><div class="line">        &#125; else &#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        let session = URLSession.shared</div><div class="line">        </div><div class="line">        let dataTask = session.dataTask(with: url!) &#123; (data, respond, error) in</div><div class="line">            </div><div class="line">            if let data = data &#123;</div><div class="line">                </div><div class="line">                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments)&#123;</div><div class="line">                    </div><div class="line">                    completion(result,true)</div><div class="line">                &#125;</div><div class="line">            &#125;else &#123;</div><div class="line">                </div><div class="line">                completion(error,false)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dataTask.resume()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func postWithPath(path: String,paras: Dictionary&lt;String,Any&gt;?,success: @escaping ((_ result: Any) -&gt; ()),failure: @escaping ((_ error: Error) -&gt; ())) &#123;</div><div class="line">        </div><div class="line">        let url = URL(string: path)</div><div class="line">        var request = URLRequest.init(url: url!)</div><div class="line">        request.httpMethod = &quot;POST&quot;</div><div class="line">        print(path)</div><div class="line">        request.httpBody = path.data(using: .utf8)</div><div class="line">        let session = URLSession.shared</div><div class="line">        let dataTask = session.dataTask(with: request) &#123; (data, respond, error) in</div><div class="line">            </div><div class="line">            if let data = data &#123;</div><div class="line">                </div><div class="line">                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) &#123;</div><div class="line">                    </div><div class="line">                    success(result)</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;else &#123;</div><div class="line">                failure(error!)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dataTask.resume()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;懒加载&quot;&gt;&lt;a href=&quot;#懒加载&quot; class=&quot;headerlink&quot; title=&quot;懒加载&quot;&gt;&lt;/a&gt;懒加载&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;格式 &lt;code&gt;lazy var 变量: 类型 = { 创建变量代码 }()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以 &lt;code&gt;lazy var&lt;/code&gt; 开头，闭包末尾跟一个’()’&lt;/li&gt;
&lt;li&gt;懒加载的写法本质上是定义并执行一个闭包&lt;/li&gt;
&lt;li&gt;好处：没有解包的麻烦，并且 延迟创建&lt;/li&gt;
&lt;li&gt;与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行&lt;br&gt;懒加载完整的写法：&lt;br&gt;eg:懒加载一个数组&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;lazy var dataList: [String] = &amp;#123; () -&amp;gt; [String] in&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return [&amp;quot;zero&amp;quot;,&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;in 和 前面的代码块可以省略，写成这样&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;lazy var dataList: [String] = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return [&amp;quot;zero&amp;quot;,&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lazy var dataList: [String] = [&amp;quot;zero&amp;quot;,&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比如懒加载一个label&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lazy var label: UILabel = UIlabel()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果对label需要添加其他属性，就可以写成带（）的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;lazy var label :UILabel = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       let label = UILabel()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        label.font = UIFont.systemFont(ofSize: 15)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        label.textColor = UIColor.red&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return label&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swfit" scheme="http://gcblog/github.io/categories/Swfit/"/>
    
    
      <category term="Swift" scheme="http://gcblog/github.io/tags/Swift/"/>
    
      <category term="单例" scheme="http://gcblog/github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="懒加载" scheme="http://gcblog/github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="extension" scheme="http://gcblog/github.io/tags/extension/"/>
    
      <category term="网络请求" scheme="http://gcblog/github.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>swift自动布局</title>
    <link href="http://gcblog/github.io/2016/11/24/swift%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    <id>http://gcblog/github.io/2016/11/24/swift自动布局/</id>
    <published>2016-11-24T15:48:09.000Z</published>
    <updated>2016-12-03T16:47:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="苹果原生自动布局"><a href="#苹果原生自动布局" class="headerlink" title="苹果原生自动布局"></a>苹果原生自动布局</h3><ul>
<li>自动布局核心公式</li>
</ul>
<p><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>
<ul>
<li>自动布局构造函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSLayoutConstraint(item: 视图,</div><div class="line">	attribute: 约束属性，</div><div class="line">	relatedBy: 约束关系，</div><div class="line">	toItem: 参照视图,</div><div class="line">	attribute: 参照属性,</div><div class="line">	multiplier:乘积,</div><div class="line">	constant:约束数值</div><div class="line">)</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>如果指定 宽 高 约束</p>
<ul>
<li>参照视图设置为 nil</li>
<li>参照属性选择 .notAnAttribute</li>
</ul>
</li>
<li><p>自动布局类函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSLayoutConstraint.constraints(withVisualFormat: VLF公式,</div><div class="line"> options:[], </div><div class="line"> metrics: 约束数值字典[String : 数值], </div><div class="line"> views: 视图字典[String : 子视图]</div><div class="line"> )</div></pre></td></tr></table></figure>
<ul>
<li>VFL 可视化格式化语言<ul>
<li>H 水平方向</li>
<li>V 垂直方向</li>
<li>| 边界</li>
<li>[] 包含控件的名称字符串，对应关系在<code>views</code>字典中定义</li>
<li>() 定义控件的宽/高，可以在<code>metrics</code>中指定<blockquote>
<p>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;苹果原生自动布局&quot;&gt;&lt;a href=&quot;#苹果原生自动布局&quot; class=&quot;headerlink&quot; title=&quot;苹果原生自动布局&quot;&gt;&lt;/a&gt;苹果原生自动布局&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;自动布局核心公式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;view1.attr1 = view2.attr2 * multiplier + constant&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动布局构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSLayoutConstraint(item: 视图,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	attribute: 约束属性，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	relatedBy: 约束关系，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	toItem: 参照视图,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	attribute: 参照属性,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	multiplier:乘积,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	constant:约束数值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swfit" scheme="http://gcblog/github.io/categories/Swfit/"/>
    
    
      <category term="Swift" scheme="http://gcblog/github.io/tags/Swift/"/>
    
      <category term="自动布局" scheme="http://gcblog/github.io/tags/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>自定义刷新控件</title>
    <link href="http://gcblog/github.io/2016/11/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6/"/>
    <id>http://gcblog/github.io/2016/11/16/自定义刷新控件/</id>
    <published>2016-11-16T15:05:20.000Z</published>
    <updated>2016-11-16T15:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：前言"><a href="#一：前言" class="headerlink" title="一：前言"></a>一：前言</h3><p>记得工作中第一次用的刷新控件是<code>svpulltorefresh</code>，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是<code>MJRefresh</code>,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致<code>MJRefresh</code>陷入一个死循环，导致不断的刷新，只能重启软件才行。<code>MJRefresh</code>工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的<code>UIRefreshControl</code>我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于<code>UIRefreshControl</code>，我同时也写了一个继承与<code>UIView</code>的control，两个进行对比，发现使用<code>UIview</code>会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。</p>
<h3 id="二-了解-UIRefreshControl"><a href="#二-了解-UIRefreshControl" class="headerlink" title="二: 了解 UIRefreshControl"></a>二: 了解 UIRefreshControl</h3><ul>
<li>基本使用方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//初始化一个control</div><div class="line">UIRefreshControl *control = [[UIRefreshControl alloc] init];</div><div class="line">//给control 添加一个刷新方法</div><div class="line">[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];</div><div class="line">//把control 添加到 tableView</div><div class="line">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>
<ul>
<li><p>存在的问题</p>
<ul>
<li><ol>
<li>刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果</li>
</ol>
</li>
<li><ol>
<li>经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。</li>
</ol>
</li>
</ul>
</li>
<li><p>自定义控件的思路</p>
<ul>
<li><ol>
<li>去掉默认的动画效果</li>
</ol>
</li>
<li><ol>
<li>自定义自己的动画效果</li>
</ol>
</li>
<li><ol>
<li>改变满足刷新时的条件<a id="more"></a>
<h3 id="三：FMRefreshControl"><a href="#三：FMRefreshControl" class="headerlink" title="三：FMRefreshControl"></a>三：FMRefreshControl</h3></li>
</ol>
</li>
</ul>
</li>
<li><p>先看一下我写完的这个控件的使用方法</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class="line"></div><div class="line">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>
<p>两行代码，用法比系统的还要稍微简单一点。</p>
<ul>
<li>再看一下效果</li>
</ul>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif" alt="image"></p>
<h3 id="四：思路与代码"><a href="#四：思路与代码" class="headerlink" title="四：思路与代码"></a>四：思路与代码</h3><h4 id="1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行"><a href="#1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行" class="headerlink" title="1. 关于 UIRefreshControl 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 superViwe,再执行"></a>1. 关于 <code>UIRefreshControl</code> 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 <code>superViwe</code>,再执行</h4><p><code>[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];</code><br>一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。</p>
<h4 id="2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。"><a href="#2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。" class="headerlink" title="2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。"></a>2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。</h4><h4 id="3-进入代码阶段"><a href="#3-进入代码阶段" class="headerlink" title="3. 进入代码阶段"></a>3. 进入代码阶段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class="line">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>
<p>初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(UIView *)newSuperview &#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    </div><div class="line">    if ([newSuperview isKindOfClass:[UIScrollView class]]) &#123;</div><div class="line">        self.superScrollView = (UIScrollView *)newSuperview;</div><div class="line">        </div><div class="line">        [self.superScrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于<br><code>UIScrollView</code>，如果是，就用KVO监听<code>contentOffset</code>属性，这样便能知道用户滑动的偏移量。</p>
<p>这里我定义了3种状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, FMRefreshState) &#123;</div><div class="line">    FMRefreshStateNormal = 0,     /** 普通状态 */</div><div class="line">    FMRefreshStatePulling,        /** 释放刷新状态 */</div><div class="line">    FMRefreshStateRefreshing,     /** 正在刷新 */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>以及切换状态后UI的切换和方法的触发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)setCurrentStatus:(FMRefreshState)currentStatus &#123;</div><div class="line">    _currentStatus = currentStatus;</div><div class="line">    switch (_currentStatus) &#123;</div><div class="line">        case FMRefreshStateNormal:</div><div class="line">            NSLog(@&quot;切换到Normal&quot;);</div><div class="line">            [self.imageView stopAnimating];</div><div class="line">            self.label.text = FM_Refresh_normal_title;</div><div class="line">            [self.label sizeToFit];</div><div class="line">            self.imageView.image = [UIImage imageNamed:@&quot;refresh_1&quot;];</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case FMRefreshStatePulling:</div><div class="line">            NSLog(@&quot;切换到Pulling&quot;);</div><div class="line">            self.label.text = FM_Refresh_pulling_title;</div><div class="line">            [self.label sizeToFit];</div><div class="line">            self.imageView.animationImages = self.refreshingImages;</div><div class="line">            self.imageView.animationDuration = 1.5;</div><div class="line">            [self.imageView startAnimating];</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case FMRefreshStateRefreshing:</div><div class="line">            NSLog(@&quot;切换到Refreshing&quot;);</div><div class="line">            self.label.text = FM_Refresh_Refreshing_title;</div><div class="line">            [self.label sizeToFit];</div><div class="line">            [self beginRefreshing];</div><div class="line">            self.imageView.animationImages = self.refreshingImages;</div><div class="line">            self.imageView.animationDuration = 1.5;</div><div class="line">            [self.imageView startAnimating];</div><div class="line">            [self doRefreshAction];</div><div class="line">            </div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>切换到<code>FMRefreshStateNormal</code> 停止动画，切换到<code>FMRefreshStatePulling</code> 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到<code>FMRefreshStateRefreshing</code>，如果此时往回滑动，小于临界值，那么状态重新切回<code>FMRefreshStateNormal</code>。<br>满足刷新条件，则便可执行以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)doRefreshAction</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class="line">    if (self.refreshTarget &amp;&amp; [self.refreshTarget respondsToSelector:self.refreshAction])</div><div class="line">        [self.refreshTarget performSelector:self.refreshAction];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">    </div><div class="line">    //isDragging 属性是指用户手指是否在拖动</div><div class="line">    if (self.superScrollView.isDragging &amp;&amp; !self.isRefreshing) &#123;</div><div class="line">        if (!self.originalOffsetY) &#123;</div><div class="line">            self.originalOffsetY = -self.superScrollView.contentInset.top;</div><div class="line">        &#125;</div><div class="line">        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;</div><div class="line">        if (self.currentStatus == FMRefreshStatePulling &amp;&amp; self.superScrollView.contentOffset.y &gt; normalPullingOffset) &#123;</div><div class="line">            </div><div class="line">            self.currentStatus = FMRefreshStateNormal;</div><div class="line">        &#125; else if (self.currentStatus == FMRefreshStateNormal &amp;&amp; self.superScrollView.contentOffset.y &lt; normalPullingOffset) &#123;</div><div class="line">            self.currentStatus = FMRefreshStatePulling;</div><div class="line">        &#125;</div><div class="line">    &#125; else if(!self.superScrollView.isDragging)&#123;</div><div class="line">        </div><div class="line">        if (self.currentStatus == FMRefreshStatePulling) &#123;</div><div class="line">            </div><div class="line">            self.currentStatus = FMRefreshStateRefreshing;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	//拖动的偏移量，转换成正数</div><div class="line">    CGFloat pullDistance = -self.frame.origin.y;</div><div class="line">    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);</div><div class="line">    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;</div><div class="line">    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;</div><div class="line">    </div><div class="line">    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);</div><div class="line">    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。</p>
<p>还有一种情况，上面也提到过，用户先滑动到<code>FMRefreshStatePulling</code>状态，然后又往回滑动，此时的偏移量在0-<code>FMRefreshStatePulling</code>状态的偏移量之间，此时调用自身的 <code>endRefreshing</code>偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：<br><a href="https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/" target="_blank" rel="external">https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/</a><br><a href="https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/" target="_blank" rel="external">https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)endRefreshing &#123;</div><div class="line">    if (self.currentStatus != FMRefreshStateRefreshing) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.currentStatus = FMRefreshStateNormal;</div><div class="line">    [super endRefreshing];</div><div class="line">    </div><div class="line">    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        if(self.superScrollView.contentOffset.y &gt;= self.originalOffsetY - k_FMRefresh_Height &amp;&amp; self.superScrollView.contentOffset.y &lt;= self.originalOffsetY) &#123;</div><div class="line">            CGPoint offset = self.superScrollView.contentOffset;</div><div class="line">            offset.y = self.originalOffsetY;</div><div class="line">            [self.superScrollView setContentOffset:offset animated:YES];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还有一点不要忘记 <code>dealloc</code>移除监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.superScrollView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。</p>
<p><a href="https://github.com/suifengqjn/FMRefreshControl" target="_blank" rel="external">domo地址：https://github.com/suifengqjn/FMRefreshControl</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一：前言&quot;&gt;&lt;a href=&quot;#一：前言&quot; class=&quot;headerlink&quot; title=&quot;一：前言&quot;&gt;&lt;/a&gt;一：前言&lt;/h3&gt;&lt;p&gt;记得工作中第一次用的刷新控件是&lt;code&gt;svpulltorefresh&lt;/code&gt;，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是&lt;code&gt;MJRefresh&lt;/code&gt;,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致&lt;code&gt;MJRefresh&lt;/code&gt;陷入一个死循环，导致不断的刷新，只能重启软件才行。&lt;code&gt;MJRefresh&lt;/code&gt;工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的&lt;code&gt;UIRefreshControl&lt;/code&gt;我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于&lt;code&gt;UIRefreshControl&lt;/code&gt;，我同时也写了一个继承与&lt;code&gt;UIView&lt;/code&gt;的control，两个进行对比，发现使用&lt;code&gt;UIview&lt;/code&gt;会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。&lt;/p&gt;
&lt;h3 id=&quot;二-了解-UIRefreshControl&quot;&gt;&lt;a href=&quot;#二-了解-UIRefreshControl&quot; class=&quot;headerlink&quot; title=&quot;二: 了解 UIRefreshControl&quot;&gt;&lt;/a&gt;二: 了解 UIRefreshControl&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本使用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//初始化一个control&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UIRefreshControl *control = [[UIRefreshControl alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//给control 添加一个刷新方法&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//把control 添加到 tableView&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[self.tableView addSubview:control];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存在的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义控件的思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;去掉默认的动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;自定义自己的动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;改变满足刷新时的条件
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="UIRefreshControl" scheme="http://gcblog/github.io/tags/UIRefreshControl/"/>
    
  </entry>
  
  <entry>
    <title>iOS语音识别</title>
    <link href="http://gcblog/github.io/2016/11/16/IOS10%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://gcblog/github.io/2016/11/16/IOS10语音识别详解/</id>
    <published>2016-11-16T15:05:20.000Z</published>
    <updated>2016-11-17T14:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。</p>
<pre><code>iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。
</code></pre><h3 id="一：基本配置"><a href="#一：基本配置" class="headerlink" title="一：基本配置"></a>一：基本配置</h3><ul>
<li>Xcode8，iOS10系统真机</li>
<li>导入头文件：OC <code>#import&lt;Speech/Speech.h&gt;</code>   swift <code>import Speech</code></li>
<li>配置info.plist文件:配置两个权限，语音识别和麦克风</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</div><div class="line">    &lt;string&gt;Your microphone will be used to record your speech when you press the &quot;Start Recording&quot; button.&lt;/string&gt;</div><div class="line">    </div><div class="line">    &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt;</div><div class="line">    &lt;string&gt;Speech recognition will be used to determine which words you speak into this device&apos;s microphone.&lt;/string&gt;</div></pre></td></tr></table></figure>
<h3 id="二：用到的几个类"><a href="#二：用到的几个类" class="headerlink" title="二：用到的几个类"></a>二：用到的几个类</h3><p><code>AVAudioEngine</code>                           语音引擎，负责提供语音输入<br><code>SFSpeechAudioBufferRecognitionRequest</code>   处理语音识别请求<br><code>SFSpeechRecognizer</code>                       语音识别器<br><code>SFSpeechRecognitionTask</code>                 输出语音识别对象的结果<br><code>NSLocale</code>                                语言类型<br>语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给<code>SFSpeechRecognitionTask</code>处理，最后输出文字。<br><code>SFSpeechRecognizer</code> 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//当开始检测音频源中的语音时首先调用此方法</div><div class="line">-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task</div><div class="line">&#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">//当识别出一条可用的信息后 会调用</div><div class="line">/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */</div><div class="line">-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription</div><div class="line">&#123;</div><div class="line">   </div><div class="line">&#125;</div><div class="line">//当识别完成所有可用的结果后调用</div><div class="line">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult</div><div class="line">&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//当不再接受音频输入时调用 即开始处理语音识别任务时调用</div><div class="line">- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task</div><div class="line">&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//当语音识别任务被取消时调用</div><div class="line">- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task</div><div class="line">&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//语音识别任务完成时被调用</div><div class="line">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="三：重点代码"><a href="#三：重点代码" class="headerlink" title="三：重点代码"></a>三：重点代码</h3><p>有两点需要注意：</p>
<ul>
<li>语音识别会很耗电以及会使用很多数据</li>
<li>语音识别一次只持续大概一分钟的时间</li>
</ul>
<p>我先定义了这几个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) AVAudioEngine         *audioEngine;</div><div class="line">@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;</div><div class="line">@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;</div><div class="line">@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;</div><div class="line">@property (nonatomic, strong) NSLocale                  *locale;</div></pre></td></tr></table></figure>
<ol>
<li><p>语音权限的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123;</div><div class="line">        BOOL isAuthorized = NO;</div><div class="line">       switch (status) &#123;</div><div class="line">                //结果未知 用户尚未进行选择</div><div class="line">            case SFSpeechRecognizerAuthorizationStatusNotDetermined:</div><div class="line">                isAuthorized = NO;</div><div class="line">                break;</div><div class="line">                //用户拒绝授权语音识别</div><div class="line">            case SFSpeechRecognizerAuthorizationStatusDenied:</div><div class="line">                isAuthorized = NO;</div><div class="line">                break;</div><div class="line">                //设备不支持语音识别功能</div><div class="line">            case SFSpeechRecognizerAuthorizationStatusRestricted:</div><div class="line">                isAuthorized = NO;</div><div class="line">                break;</div><div class="line">                //用户授权语音识别</div><div class="line">            case SFSpeechRecognizerAuthorizationStatusAuthorized:</div><div class="line">                isAuthorized = YES;</div><div class="line">                </div><div class="line">                break;</div><div class="line">                </div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (callback) &#123;</div><div class="line">            callback(isAuthorized, status);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p>将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];</div><div class="line">    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123;</div><div class="line">        [self.recognitionRequest appendAudioPCMBuffer:buffer];</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><code>SFSpeechRecognitionTask</code> 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">self.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class="line">        BOOL isFinal = NO;</div><div class="line">        NSString *bestResult = [[result bestTranscription] formattedString];</div><div class="line">        isFinal = result.isFinal;</div><div class="line">        if (error || isFinal) &#123;</div><div class="line">            [self endTask];</div><div class="line">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeFail:)]) &#123;</div><div class="line">                [self.delegate recognizeFail:error];</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) &#123;</div><div class="line">                [self.delegate recognizeSuccess:bestResult];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<h3 id="四：提取录音文件中的文字"><a href="#四：提取录音文件中的文字" class="headerlink" title="四：提取录音文件中的文字"></a>四：提取录音文件中的文字</h3><ol>
<li>也需要先获取用户的授权，授权代码与上面一致。</li>
<li>对文件的处理相对较为简单<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//初始化一个识别器</div><div class="line">SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];</div><div class="line">//初始化mp3的url</div><div class="line">NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];</div><div class="line">//初始化一个识别的请求</div><div class="line">SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];</div><div class="line">//发起请求</div><div class="line">[recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class="line">    if(error != nil)</div><div class="line">    &#123;</div><div class="line">        NSLog(@&quot;识别错误:%@&quot;,error);</div><div class="line">    &#125;</div><div class="line">    NSString *resultString = result.bestTranscription.formattedString;</div><div class="line">    NSLog(@&quot;%@&quot;,resultString);</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://github.com/suifengqjn/IOS10Speech" target="_blank" rel="external">github地址：https://github.com/suifengqjn/IOS10Speech</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;一：基本配置&quot;&gt;&lt;a href=&quot;#一：基本配置&quot; class=&quot;headerlink&quot; title=&quot;一：基本配置&quot;&gt;&lt;/a&gt;一：基本配置&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Xcode8，iOS10系统真机&lt;/li&gt;
&lt;li&gt;导入头文件：OC &lt;code&gt;#import&amp;lt;Speech/Speech.h&amp;gt;&lt;/code&gt;   swift &lt;code&gt;import Speech&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置info.plist文件:配置两个权限，语音识别和麦克风&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;string&amp;gt;Your microphone will be used to record your speech when you press the &amp;quot;Start Recording&amp;quot; button.&amp;lt;/string&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;key&amp;gt;NSSpeechRecognitionUsageDescription&amp;lt;/key&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;string&amp;gt;Speech recognition will be used to determine which words you speak into this device&amp;apos;s microphone.&amp;lt;/string&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;二：用到的几个类&quot;&gt;&lt;a href=&quot;#二：用到的几个类&quot; class=&quot;headerlink&quot; title=&quot;二：用到的几个类&quot;&gt;&lt;/a&gt;二：用到的几个类&lt;/h3&gt;&lt;p&gt;&lt;code&gt;AVAudioEngine&lt;/code&gt;                           语音引擎，负责提供语音输入&lt;br&gt;&lt;code&gt;SFSpeechAudioBufferRecognitionRequest&lt;/code&gt;   处理语音识别请求&lt;br&gt;&lt;code&gt;SFSpeechRecognizer&lt;/code&gt;                       语音识别器&lt;br&gt;&lt;code&gt;SFSpeechRecognitionTask&lt;/code&gt;                 输出语音识别对象的结果&lt;br&gt;&lt;code&gt;NSLocale&lt;/code&gt;                                语言类型&lt;br&gt;语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给&lt;code&gt;SFSpeechRecognitionTask&lt;/code&gt;处理，最后输出文字。&lt;br&gt;&lt;code&gt;SFSpeechRecognizer&lt;/code&gt; 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。&lt;br&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="语音识别" scheme="http://gcblog/github.io/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>runtime详解</title>
    <link href="http://gcblog/github.io/2016/04/16/runtime%E8%AF%A6%E8%A7%A3/"/>
    <id>http://gcblog/github.io/2016/04/16/runtime详解/</id>
    <published>2016-04-16T08:59:52.000Z</published>
    <updated>2016-11-17T13:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。</p>
<p>最初是在onevcat的博客上看到runtime的<a href="https://onevcat.com/2012/04/objective-c-runtime/" target="_blank" rel="external">runtime的博客</a>，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。</p>
<h3 id="一：基本概念"><a href="#一：基本概念" class="headerlink" title="一：基本概念"></a>一：基本概念</h3><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="http://opensource.apple.com//source/objc4/" target="_blank" rel="external">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。</p>
<ul>
<li>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li>
<li>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。</li>
<li>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</li>
</ul>
<h3 id="二：runtime的具体实现"><a href="#二：runtime的具体实现" class="headerlink" title="二：runtime的具体实现"></a>二：runtime的具体实现</h3><p>我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。<br>每一个oc的方法，底层必然有一个与之对应的runtime方法。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png" alt="image"></p>
<ul>
<li><p>当我们用OC写下这样一段代码<br><code>[tableView cellForRowAtIndexPath:indexPath];</code></p>
</li>
<li><p>在编译时RunTime会将上述代码转化成[发送消息]<br><code>objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</code></p>
</li>
</ul>
<h3 id="三-常见方法"><a href="#三-常见方法" class="headerlink" title="三:常见方法"></a>三:常见方法</h3><p> <code>unsigned int count;</code></p>
<ul>
<li><p>获取属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class="line">    for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class="line">        const char *propertyName = property_getName(propertyList[i]);</div><div class="line">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获取方法列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class="line">for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">    Method method = methodList[i];</div><div class="line">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>获取成员变量列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class="line">  for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">      Ivar myIvar = ivarList[i];</div><div class="line">      const char *ivarName = ivar_getName(myIvar);</div><div class="line">      NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>获取协议列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class="line">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">        Protocol *myProtocal = protocolList[i];</div><div class="line">        const char *protocolName = protocol_getName(myProtocal);</div><div class="line">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class="line">    &#125;</div><div class="line">  ``` </div><div class="line">  </div><div class="line">&gt;现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法</div><div class="line"></div><div class="line">- 获得类方法</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Class PersonClass = object_getClass([Person class]);<br>SEL oriSEL = @selector(test1);<br>Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 获得实例方法</div></pre></td></tr></table></figure></p>
<p>Class PersonClass = object_getClass([xiaoming class]);<br>SEL oriSEL = @selector(test2);<br>Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 添加方法</div></pre></td></tr></table></figure></p>
<p>BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 替换原方法实现</div></pre></td></tr></table></figure></p>
<p>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 交换两个方法</div></pre></td></tr></table></figure></p>
<p>method_exchangeImplementations(oriMethod, cusMethod);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">### 四：常见作用</div><div class="line">- 动态的添加对象的成员变量和方法</div><div class="line">- 动态交换两个方法的实现</div><div class="line">- 拦截并替换方法</div><div class="line">- 在方法上增加额外功能</div><div class="line">- 实现NSCoding的自动归档和解档</div><div class="line">- 实现字典转模型的自动转换</div><div class="line"></div><div class="line">### 五：代码实现</div><div class="line">要使用runtime，要先引入头文件`#import &lt;objc/runtime.h&gt;`</div><div class="line">这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。</div><div class="line"></div><div class="line">#### 1. 动态变量控制</div><div class="line">   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。</div><div class="line">   </div><div class="line">##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  </div><div class="line"></div><div class="line">	`Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);`  </div><div class="line"></div><div class="line">##### 2.遍历属性找到对应name字段  </div><div class="line"></div><div class="line">	`const char *varName = ivar_getName(var);`</div><div class="line"></div><div class="line">##### 3.修改对应的字段值成20 </div><div class="line">	</div><div class="line">	`object_setIvar(self.xiaoMing, var, @&quot;20&quot;);`  </div><div class="line">	</div><div class="line">##### 4.代码参考</div></pre></td></tr></table></figure></p>
<p>-(void)answer{<br>        unsigned int count = 0;<br>        Ivar <em>ivar = class_copyIvarList([self.xiaoMing class], &amp;count);<br>        for (int i = 0; i&lt;count; i++) {<br>            Ivar var = ivar[i];<br>            const char </em>varName = ivar_getName(var);<br>            NSString *name = [NSString stringWithUTF8String:varName];<br>            if ([name isEqualToString:@”_age”]) {<br>                object_setIvar(self.xiaoMing, var, @”20”);<br>                break;<br>            }<br>        }<br>        NSLog(@”XiaoMing’s age is %@”,self.xiaoMing.age);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.动态添加方法</div><div class="line"></div><div class="line">在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  </div><div class="line">  </div><div class="line">##### 1.动态给XiaoMing类中添加guess方法：</div></pre></td></tr></table></figure></p>
<pre><code>class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里参数地方说明一下：</div><div class="line"></div><div class="line">&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;</div><div class="line">&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;</div><div class="line">&gt;“v@:@@” 意思是，两个参数的没有返回值。  </div><div class="line"></div><div class="line"></div><div class="line">##### 2.调用guess方法响应事件：  </div><div class="line"></div><div class="line">	[self.xiaoMing performSelector:@selector(guess)];</div><div class="line"></div><div class="line">##### 3.编写guessAnswer的实现：  </div><div class="line">	</div><div class="line">	</div><div class="line">	void guessAnswer(id self,SEL _cmd)&#123;</div><div class="line">    	NSLog(@&quot;i am from beijing&quot;);   </div><div class="line">	&#125; </div><div class="line">	</div><div class="line"></div><div class="line">这个有两个地方留意一下：</div><div class="line">* void的前面没有+、-号，因为只是C的代码。</div><div class="line">* 必须有两个指定参数(id self,SEL _cmd)  </div><div class="line"></div><div class="line">##### 4.代码参考</div><div class="line"></div><div class="line">```  </div><div class="line">	-(void)answer&#123;</div><div class="line">    	class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);</div><div class="line">    	if ([self.xiaoMing respondsToSelector:@selector(guess)]) &#123;</div><div class="line">        </div><div class="line">        	[self.xiaoMing performSelector:@selector(guess)];</div><div class="line">        </div><div class="line">    	&#125; else&#123;</div><div class="line">        	NSLog(@&quot;Sorry,I don&apos;t know&quot;);</div><div class="line">    	&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	void guessAnswer(id self,SEL _cmd)&#123;</div><div class="line">   </div><div class="line">    	NSLog(@&quot;i am from beijing&quot;);</div><div class="line">    </div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="3：动态交换两个方法的实现"><a href="#3：动态交换两个方法的实现" class="headerlink" title="3：动态交换两个方法的实现"></a>3：动态交换两个方法的实现</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code> 和 <code>test2</code>这两个方法，后来被Runtime交换方法后，每次调动<code>test1</code> 的时候就会去执行<code>test2</code>，调动<code>test2</code> 的时候就会去执行<code>test1</code>， 。那么，Runtime是如何做到的呢？</p>
<h5 id="1-获取这个类中的两个方法并交换"><a href="#1-获取这个类中的两个方法并交换" class="headerlink" title="1. 获取这个类中的两个方法并交换"></a>1. 获取这个类中的两个方法并交换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Method m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));</div><div class="line">    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));</div><div class="line">    method_exchangeImplementations(m1, m2);</div></pre></td></tr></table></figure>
<p>交换方法之后，以后每次调用这两个方法都会交换方法的实现</p>
<h4 id="4：拦截并替换方法"><a href="#4：拦截并替换方法" class="headerlink" title="4：拦截并替换方法"></a>4：拦截并替换方法</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code>这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。</p>
<p>我们先增加一个tool类，然后写一个我们自己实现的方法-change，<br>通过runtime把test1替换成change。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Class PersionClass = object_getClass([Person class]);</div><div class="line">Class toolClass = object_getClass([tool class]);</div><div class="line"></div><div class="line">    ////源方法的SEL和Method</div><div class="line">    </div><div class="line">    SEL oriSEL = @selector(test1);</div><div class="line">    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);</div><div class="line">    </div><div class="line">    ////交换方法的SEL和Method</div><div class="line">    </div><div class="line">    SEL cusSEL = @selector(change);</div><div class="line">    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);</div><div class="line">    </div><div class="line">    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况</div><div class="line">    </div><div class="line">    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class="line">    if (addSucc) &#123;</div><div class="line">          // 添加成功：将源方法的实现替换到交换方法的实现     </div><div class="line">        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class="line">               </div><div class="line">    &#125;else &#123;</div><div class="line">    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即</div><div class="line">method_exchangeImplementations(oriMethod, cusMethod);  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="5：在方法上增加额外功能"><a href="#5：在方法上增加额外功能" class="headerlink" title="5：在方法上增加额外功能"></a>5：在方法上增加额外功能</h4><p>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@implementation UIButton (Hook)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line"></div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line"></div><div class="line">        Class selfClass = [self class];</div><div class="line"></div><div class="line">        SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class="line">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class="line"></div><div class="line">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class="line">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class="line"></div><div class="line">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class="line">        if (addSucc) &#123;</div><div class="line">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class="line">        &#125;else &#123;</div><div class="line">            method_exchangeImplementations(oriMethod, cusMethod);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class="line">    [CountTool addClickCount];</div><div class="line">    [self mySendAction:action to:target forEvent:event];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>load方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。</p>
<h4 id="6-实现NSCoding的自动归档和解档"><a href="#6-实现NSCoding的自动归档和解档" class="headerlink" title="6.实现NSCoding的自动归档和解档"></a>6.实现NSCoding的自动归档和解档</h4><p>如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍<code>encodeObject</code> 和 <code>decodeObjectForKey</code>方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。<br>假设现在有一个Movie类，有3个属性，它的<code>h</code>文件这这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding</div><div class="line">@interface Movie : NSObject&lt;NSCoding&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *movieId;</div><div class="line">@property (nonatomic, copy) NSString *movieName;</div><div class="line">@property (nonatomic, copy) NSString *pic_url;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果是正常写法， <code>m</code>文件应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &quot;Movie.h&quot;</div><div class="line">@implementation Movie</div><div class="line"></div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class="line">&#123;</div><div class="line">    [aCoder encodeObject:_movieId forKey:@&quot;id&quot;];</div><div class="line">    [aCoder encodeObject:_movieName forKey:@&quot;name&quot;];</div><div class="line">    [aCoder encodeObject:_pic_url forKey:@&quot;url&quot;];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithCoder:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        self.movieId = [aDecoder decodeObjectForKey:@&quot;id&quot;];</div><div class="line">        self.movieName = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">        self.pic_url = [aDecoder decodeObjectForKey:@&quot;url&quot;];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果这里有100个属性，那么我们也只能把100个属性都给写一遍。<br>不过你会使用runtime后，这里就有更简便的方法。<br>下面看看runtime的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &quot;Movie.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation Movie</div><div class="line"></div><div class="line">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class="line"></div><div class="line">&#123;</div><div class="line">    unsigned int count = 0;</div><div class="line">    Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class="line">    </div><div class="line">    for (int i = 0; i&lt;count; i++) &#123;</div><div class="line">        // 取出i位置对应的成员变量</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        // 查看成员变量</div><div class="line">        const char *name = ivar_getName(ivar);</div><div class="line">        // 归档</div><div class="line">        NSString *key = [NSString stringWithUTF8String:name];</div><div class="line">        id value = [self valueForKey:key];</div><div class="line">        [encoder encodeObject:value forKey:key];</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithCoder:(NSCoder *)decoder</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        unsigned int count = 0;</div><div class="line">        Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class="line">        for (int i = 0; i&lt;count; i++) &#123;</div><div class="line">        // 取出i位置对应的成员变量</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        // 查看成员变量</div><div class="line">        const char *name = ivar_getName(ivar);</div><div class="line">       // 归档</div><div class="line">       NSString *key = [NSString stringWithUTF8String:name];</div><div class="line">      id value = [decoder decodeObjectForKey:key];</div><div class="line">       // 设置到成员变量身上</div><div class="line">        [self setValue:value forKey:key];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">    &#125; </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。<br>我们把<code>encodeWithCoder</code> 和 <code>initWithCoder</code>这两个方法抽成宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#import &quot;Movie.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">#define encodeRuntime(A) \</div><div class="line">\</div><div class="line">unsigned int count = 0;\</div><div class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);\</div><div class="line">for (int i = 0; i&lt;count; i++) &#123;\</div><div class="line">Ivar ivar = ivars[i];\</div><div class="line">const char *name = ivar_getName(ivar);\</div><div class="line">NSString *key = [NSString stringWithUTF8String:name];\</div><div class="line">id value = [self valueForKey:key];\</div><div class="line">[encoder encodeObject:value forKey:key];\</div><div class="line">&#125;\</div><div class="line">free(ivars);\</div><div class="line">\</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#define initCoderRuntime(A) \</div><div class="line">\</div><div class="line">if (self = [super init]) &#123;\</div><div class="line">unsigned int count = 0;\</div><div class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);\</div><div class="line">for (int i = 0; i&lt;count; i++) &#123;\</div><div class="line">Ivar ivar = ivars[i];\</div><div class="line">const char *name = ivar_getName(ivar);\</div><div class="line">NSString *key = [NSString stringWithUTF8String:name];\</div><div class="line">id value = [decoder decodeObjectForKey:key];\</div><div class="line">[self setValue:value forKey:key];\</div><div class="line">&#125;\</div><div class="line">free(ivars);\</div><div class="line">&#125;\</div><div class="line">return self;\</div><div class="line">\</div><div class="line"></div><div class="line"></div><div class="line">@implementation Movie</div><div class="line"></div><div class="line">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class="line"></div><div class="line">&#123;</div><div class="line">    encodeRuntime(Movie)</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithCoder:(NSCoder *)decoder</div><div class="line">&#123;</div><div class="line">    initCoderRuntime(Movie)</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。</p>
<h4 id="7-实现字典转模型的自动转换"><a href="#7-实现字典转模型的自动转换" class="headerlink" title="7.实现字典转模型的自动转换"></a>7.实现字典转模型的自动转换</h4><p>字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。</p>
<ul>
<li>先实现最外层的属性转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 创建对应模型对象</div><div class="line"> id objc = [[self alloc] init];</div><div class="line"></div><div class="line"> unsigned int count = 0;</div><div class="line"></div><div class="line"> // 1.获取成员属性数组</div><div class="line"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class="line"></div><div class="line"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</div><div class="line"> for (int i = 0; i &lt; count; i++) &#123;</div><div class="line"></div><div class="line">     // 2.1 获取成员属性</div><div class="line">     Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">     // 2.2 获取成员属性名 C -&gt; OC 字符串</div><div class="line">    NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">     // 2.3 _成员属性名 =&gt; 字典key</div><div class="line">     NSString *key = [ivarName substringFromIndex:1];</div><div class="line"></div><div class="line">     // 2.4 去字典中取出对应value给模型属性赋值</div><div class="line">     id value = dict[key];</div><div class="line"></div><div class="line">     // 获取成员属性类型</div><div class="line">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。</p>
<ul>
<li>内层数组，字典的转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </div><div class="line"></div><div class="line">             //  是字典对象,并且属性名对应类型是自定义类型</div><div class="line">            // 处理类型字符串 @\&quot;User\&quot; -&gt; User</div><div class="line">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class="line">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];</div><div class="line">            // 自定义对象,并且值是字典</div><div class="line">            // value:user字典 -&gt; User模型</div><div class="line">            // 获取模型(user)类对象</div><div class="line">            Class modalClass = NSClassFromString(ivarType);</div><div class="line"></div><div class="line">            // 字典转模型</div><div class="line">            if (modalClass) &#123;</div><div class="line">                // 字典转模型 user</div><div class="line">                value = [modalClass objectWithDict:value];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class="line">            // 判断对应类有没有实现字典数组转模型数组的协议</div><div class="line">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                // 转换成id类型，就能调用任何对象的方法</div><div class="line">                id idSelf = self;</div><div class="line"></div><div class="line">                // 获取数组中字典对应的模型</div><div class="line">                NSString *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                // 生成模型</div><div class="line">                Class classModel = NSClassFromString(type);</div><div class="line">                NSMutableArray *arrM = [NSMutableArray array];</div><div class="line">                // 遍历字典数组，生成模型数组</div><div class="line">                for (NSDictionary *dict in value) &#123;</div><div class="line">                    // 字典转模型</div><div class="line">                    id model =  [classModel objectWithDict:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 把模型数组赋值给value</div><div class="line">                value = arrM;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 <code>[movie setValuesForKeysWithDictionary:dict];</code> 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，<br><code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code> 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个<code>id</code>,我们需要把它赋值给<code>uid</code>属性；2. 字典中属性比模型的属性还多的情况。<br>如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。<br>这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;id&quot;]) &#123;</div><div class="line">        self.uid = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="六-几个参数概念"><a href="#六-几个参数概念" class="headerlink" title="六.几个参数概念"></a>六.几个参数概念</h3><p>以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。<br>如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。</p>
<h4 id="1-objc-msgSend"><a href="#1-objc-msgSend" class="headerlink" title="1.objc_msgSend"></a>1.objc_msgSend</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* Basic Messaging Primitives</div><div class="line">*</div><div class="line">* On some architectures, use objc_msgSend_stret for some struct return types.</div><div class="line">* On some architectures, use objc_msgSend_fpret for some float return types.</div><div class="line">* On some architectures, use objc_msgSend_fp2ret for some float return types.</div><div class="line">*</div><div class="line">* These functions must be cast to an appropriate function pointer type </div><div class="line">* before being called. </div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。<br>最关键的一点：无论何时，要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p>
<h4 id="2-SEL"><a href="#2-SEL" class="headerlink" title="2.SEL"></a>2.SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector在Objc</code>中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:<br><code>typedef struct objc_selector *SEL</code>;<br>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。</p>
<h4 id="3-id"><a href="#3-id" class="headerlink" title="3.id"></a>3.id</h4><p><code>objc_msgSend</code>第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：<br><code>typedef struct objc_object *id</code>;<br>那objc_object又是啥呢：<br><code>struct objc_object { Class isa; }</code>;<br><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">官方文档</a>.</p>
<h4 id="4-Class"><a href="#4-Class" class="headerlink" title="4.Class"></a>4.Class</h4><p>之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：<br><code>typedef struct objc_class *Class</code>;<br>objc_class里面的东西多着呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">#if  !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在<code>objc_class</code>结构体中：<code>ivars是objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改 <code>*methodLists</code> 的值来添加成员方法，这也是Category实现的原理.</p>
<p>上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。<br><a href="https://github.com/suifengqjn/runtime" target="_blank" rel="external">demo下载</a></p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。&lt;/p&gt;
&lt;p&gt;最初是在onevcat的博客上看到runtime的&lt;a href=&quot;https://onevcat.com/2012/04/objective-c-runtime/&quot;&gt;runtime的博客&lt;/a&gt;，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。&lt;/p&gt;
&lt;h3 id=&quot;一：基本概念&quot;&gt;&lt;a href=&quot;#一：基本概念&quot; class=&quot;headerlink&quot; title=&quot;一：基本概念&quot;&gt;&lt;/a&gt;一：基本概念&lt;/h3&gt;&lt;p&gt;Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在&lt;a href=&quot;http://opensource.apple.com//source/objc4/&quot;&gt;这里&lt;/a&gt;下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。&lt;/li&gt;
&lt;li&gt;对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。&lt;/li&gt;
&lt;li&gt;OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。&lt;/li&gt;
&lt;li&gt;只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二：runtime的具体实现&quot;&gt;&lt;a href=&quot;#二：runtime的具体实现&quot; class=&quot;headerlink&quot; title=&quot;二：runtime的具体实现&quot;&gt;&lt;/a&gt;二：runtime的具体实现&lt;/h3&gt;&lt;p&gt;我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。&lt;br&gt;每一个oc的方法，底层必然有一个与之对应的runtime方法。&lt;br&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="runtime" scheme="http://gcblog/github.io/tags/runtime/"/>
    
      <category term="Method Swizzling" scheme="http://gcblog/github.io/tags/Method-Swizzling/"/>
    
  </entry>
  
  <entry>
    <title>iOS release,debug版设置不同的AppIcon</title>
    <link href="http://gcblog/github.io/2016/04/13/iOS-release-debug%E7%89%88%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84AppIcon/"/>
    <id>http://gcblog/github.io/2016/04/13/iOS-release-debug版设置不同的AppIcon/</id>
    <published>2016-04-13T10:41:56.000Z</published>
    <updated>2016-11-17T13:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。</p>
<p>通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>创建一个新的AppIcon</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png" alt="image"></p>
<a id="more"></a>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>给两个AppIcon分别加入不同的图片</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png" alt="image"></p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png" alt="image"></p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。&lt;/p&gt;
&lt;p&gt;通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。&lt;/p&gt;
&lt;h4 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h4&gt;&lt;p&gt;创建一个新的AppIcon&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS配置" scheme="http://gcblog/github.io/categories/iOS%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="配置" scheme="http://gcblog/github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>iOS公共库</title>
    <link href="http://gcblog/github.io/2016/04/06/iOS%E5%85%AC%E5%85%B1%E5%BA%93/"/>
    <id>http://gcblog/github.io/2016/04/06/iOS公共库/</id>
    <published>2016-04-06T08:59:52.000Z</published>
    <updated>2016-11-17T15:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>打开Xcode，file-&gt;new-&gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png" alt="image"></p>
<a id="more"></a>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>file-&gt;new-&gt;project-&gt;Application,创建我们的工程，创建好后关闭工程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png" alt="image"></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>file-&gt;new-&gt;project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework,创建依赖库</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png" alt="image"></p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><blockquote>
<p>新建一个Tool类，然后在Amy.h里面引入，引入的方式：<code>#import&lt;Amy/Tool.h&gt;</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png" alt="image"></p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><blockquote>
<p>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png" alt="image"></p>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><blockquote>
<p>打开workspace，通过 <code>file-&gt; AddFile to</code> 依次把工程和依赖添加到workspace中。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png" alt="image"></p>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><blockquote>
<p>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png" alt="image"></p>
<h3 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h3><blockquote>
<p>在我们的工程中可以引入依赖使用了。<br>引入方式：<code>#import&lt;Amy/Tool.h&gt;</code><br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png" alt="image"></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;打开Xcode，file-&amp;gt;new-&amp;gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="workspace" scheme="http://gcblog/github.io/tags/workspace/"/>
    
      <category term="公共库" scheme="http://gcblog/github.io/tags/%E5%85%AC%E5%85%B1%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发小技巧</title>
    <link href="http://gcblog/github.io/2016/03/15/iOS%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://gcblog/github.io/2016/03/15/iOS开发小技巧/</id>
    <published>2016-03-15T13:12:38.000Z</published>
    <updated>2016-11-17T15:03:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发的一些奇巧淫技,<br>“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.</p>
<h3 id="如何查看真机沙盒文件"><a href="#如何查看真机沙盒文件" class="headerlink" title="如何查看真机沙盒文件"></a>如何查看真机沙盒文件</h3><h4 id="一：安装iFunBox或IExployer"><a href="#一：安装iFunBox或IExployer" class="headerlink" title="一：安装iFunBox或IExployer"></a>一：安装iFunBox或IExployer</h4><h4 id="二：设置"><a href="#二：设置" class="headerlink" title="二：设置"></a>二：设置</h4><p>在xcode的上部导航栏里，选择window -&gt; Devices,找到目标app<img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png" alt="">,双击选中项目<img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png" alt="">,</p>
<a id="more"></a>
<p>这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container<img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png" alt="">,下载后保存到桌面，右键显示包内容即可。</p>
<p>###如何使用命令行进行打包?</p>
<p>一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。</p>
<h4 id="如果项目没有使用cocoapods"><a href="#如果项目没有使用cocoapods" class="headerlink" title="如果项目没有使用cocoapods:"></a>如果项目没有使用cocoapods:</h4><p>xcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)</p>
<h4 id="如果使用cocoapods"><a href="#如果使用cocoapods" class="headerlink" title="如果使用cocoapods:"></a>如果使用cocoapods:</h4><p>xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release<br><br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa</p>
<p>二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）</p>
<h4 id="如果项目没有使用cocoapods-1"><a href="#如果项目没有使用cocoapods-1" class="headerlink" title="如果项目没有使用cocoapods:"></a>如果项目没有使用cocoapods:</h4><p>xctool -scheme Demo archive -archivePath “Demo/“(会生成.xcarchive文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>
<h4 id="如果使用cocoapods-1"><a href="#如果使用cocoapods-1" class="headerlink" title="如果使用cocoapods:"></a>如果使用cocoapods:</h4><p>xctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath “Demo”<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>
<h3 id="Xcode历史版本下载地址"><a href="#Xcode历史版本下载地址" class="headerlink" title="Xcode历史版本下载地址"></a>Xcode历史版本下载地址</h3><p><a href="https://developer.apple.com/downloads/" target="_blank" rel="external">https://developer.apple.com/downloads/</a></p>
<h3 id="加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等"><a href="#加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等" class="headerlink" title="加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)"></a>加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)</h3><p><a href="https://developer.apple.com/appstore/contact/appreviewteam/index.html" target="_blank" rel="external">https://developer.apple.com/appstore/contact/appreviewteam/index.html</a><br>也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述</p>
<h3 id="Autolayout及SizeClass示意图"><a href="#Autolayout及SizeClass示意图" class="headerlink" title="Autolayout及SizeClass示意图"></a>Autolayout及SizeClass示意图</h3><p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png" alt=""> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png" alt=""> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png" alt=""></p>
<h3 id="窗口中有多个responder-如何快速释放键盘"><a href="#窗口中有多个responder-如何快速释放键盘" class="headerlink" title="窗口中有多个responder,如何快速释放键盘"></a>窗口中有多个responder,如何快速释放键盘</h3><h4 id="一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil"><a href="#一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil" class="headerlink" title="一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];"></a>一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</h4><h4 id="二：-self-view-endEditing-YES"><a href="#二：-self-view-endEditing-YES" class="headerlink" title="二：[self.view endEditing:YES];"></a>二：[self.view endEditing:YES];</h4><h3 id="如何去除UITableView中Group样式cell的边框"><a href="#如何去除UITableView中Group样式cell的边框" class="headerlink" title="如何去除UITableView中Group样式cell的边框"></a>如何去除UITableView中Group样式cell的边框</h3><h4 id="一：-UIView-tempView-UIView-alloc-init"><a href="#一：-UIView-tempView-UIView-alloc-init" class="headerlink" title="一： UIView *tempView = [[UIView alloc] init];"></a>一： UIView *tempView = [[UIView alloc] init];</h4><p>  <br> [cell setBackgroundView:tempView];<br>   <br>[cell setBackgroundColor:[UIColor clearColor]]; </p>
<h4 id="二：tableView-separatorColor-UIColor-clearColor"><a href="#二：tableView-separatorColor-UIColor-clearColor" class="headerlink" title="二：tableView.separatorColor=[UIColor clearColor];"></a>二：tableView.separatorColor=[UIColor clearColor];</h4><h3 id="如何解决colorWithPatternImage设置view背景色太占内存问题"><a href="#如何解决colorWithPatternImage设置view背景色太占内存问题" class="headerlink" title="如何解决colorWithPatternImage设置view背景色太占内存问题"></a>如何解决colorWithPatternImage设置view背景色太占内存问题</h3><p>  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”main_landscape.jpg”]];<br>  <br>切换成self.view.layer.contents =[UIImage imageNamed:@”name.png”].CGImage;</p>
<h3 id="App升级后如何删除NSUserDefaults全部数据"><a href="#App升级后如何删除NSUserDefaults全部数据" class="headerlink" title="App升级后如何删除NSUserDefaults全部数据"></a>App升级后如何删除NSUserDefaults全部数据</h3><p>APP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br><br>NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];<br>[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  </p>
<h3 id="如何修改图片颜色"><a href="#如何修改图片颜色" class="headerlink" title="如何修改图片颜色"></a>如何修改图片颜色</h3><p>先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br><br>self.imageView.image = [[UIImage imageNamed:@”back”] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];<br>self.imageView.tintColor = [UIColor redColor];<br><br>也可以在Asset catelog中设置render as<br> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png" alt=""></p>
<h3 id="如何放大图片使之不失真且不产生锯齿"><a href="#如何放大图片使之不失真且不产生锯齿" class="headerlink" title="如何放大图片使之不失真且不产生锯齿"></a>如何放大图片使之不失真且不产生锯齿</h3><p>在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png" alt=""></p>
<h3 id="如何在拉伸图片的时候使之不变形"><a href="#如何在拉伸图片的时候使之不变形" class="headerlink" title="如何在拉伸图片的时候使之不变形"></a>如何在拉伸图片的时候使之不变形</h3><p>一：stretchableImageWithLeftCapWidth: topCapHeight:<br><br>二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif" alt=""></p>
<h3 id="Storyboard中如何正确设置控件透明度"><a href="#Storyboard中如何正确设置控件透明度" class="headerlink" title="Storyboard中如何正确设置控件透明度"></a>Storyboard中如何正确设置控件透明度</h3><p>在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。<br><br>此时应该这样设置 Background →0ther →0pacity</p>
<h3 id="UIScreen-mainScreen-bounds获取屏幕大小不对的问题"><a href="#UIScreen-mainScreen-bounds获取屏幕大小不对的问题" class="headerlink" title="[UIScreen mainScreen].bounds获取屏幕大小不对的问题"></a>[UIScreen mainScreen].bounds获取屏幕大小不对的问题</h3><p>#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br><br>#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br><br>在标准模式下<br><br>6+：<br><br>[[UIScreen mainScreen] currentMode].size为{1242，2208}<br><br>[UIScreen mainScreen].bounds.size为{414，736}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{750，1334}<br><br>[UIScreen mainScreen].bounds.size为{375，667}<br></p>
<p>放大模式下(设置-&gt;显示与亮度-&gt;显示模式) <br><br>6+:<br><br>[[UIScreen mainScreen] currentMode].size为{1125,2001}<br><br>[UIScreen mainScreen].bounds.size为{375,667}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{640,1136}<br><br>[UIScreen mainScreen].bounds.size为{320,568}</p>
<h3 id="Mac模式下如何将视频生成Gif文件"><a href="#Mac模式下如何将视频生成Gif文件" class="headerlink" title="Mac模式下如何将视频生成Gif文件"></a>Mac模式下如何将视频生成Gif文件</h3><h4 id="一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn"><a href="#一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn" class="headerlink" title="一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)"></a>一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)</h4><h4 id="二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片"><a href="#二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片" class="headerlink" title="二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片"></a>二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br></h4><p>（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）<br><br>然后使用PicGIF (将多张图片生成gif文件)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发的一些奇巧淫技,&lt;br&gt;“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.&lt;/p&gt;
&lt;h3 id=&quot;如何查看真机沙盒文件&quot;&gt;&lt;a href=&quot;#如何查看真机沙盒文件&quot; class=&quot;headerlink&quot; title=&quot;如何查看真机沙盒文件&quot;&gt;&lt;/a&gt;如何查看真机沙盒文件&lt;/h3&gt;&lt;h4 id=&quot;一：安装iFunBox或IExployer&quot;&gt;&lt;a href=&quot;#一：安装iFunBox或IExployer&quot; class=&quot;headerlink&quot; title=&quot;一：安装iFunBox或IExployer&quot;&gt;&lt;/a&gt;一：安装iFunBox或IExployer&lt;/h4&gt;&lt;h4 id=&quot;二：设置&quot;&gt;&lt;a href=&quot;#二：设置&quot; class=&quot;headerlink&quot; title=&quot;二：设置&quot;&gt;&lt;/a&gt;二：设置&lt;/h4&gt;&lt;p&gt;在xcode的上部导航栏里，选择window -&amp;gt; Devices,找到目标app&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png&quot; alt=&quot;&quot;&gt;,双击选中项目&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png&quot; alt=&quot;&quot;&gt;,&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="缓存" scheme="http://gcblog/github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Xcode多工程联编及工程依赖</title>
    <link href="http://gcblog/github.io/2016/03/12/Xcode%E5%A4%9A%E5%B7%A5%E7%A8%8B%E8%81%94%E7%BC%96%E5%8F%8A%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96/"/>
    <id>http://gcblog/github.io/2016/03/12/Xcode多工程联编及工程依赖/</id>
    <published>2016-03-12T15:47:36.000Z</published>
    <updated>2016-11-17T14:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。</p>
<h3 id="一-target"><a href="#一-target" class="headerlink" title="一:target"></a>一:target</h3><p>target指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。</p>
<p>target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。</p>
<p>若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。</p>
<a id="more"></a>
<h3 id="二-project"><a href="#二-project" class="headerlink" title="二:project"></a>二:project</h3><p>xcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。<br>project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。<br>project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。</p>
<h3 id="三-build-settings"><a href="#三-build-settings" class="headerlink" title="三:build settings"></a>三:build settings</h3><p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>
<h3 id="四-workspace"><a href="#四-workspace" class="headerlink" title="四:workspace"></a>四:workspace</h3><p>workspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。<br>比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。<br>可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。</p>
<h3 id="五-xcode-schemexcode"><a href="#五-xcode-schemexcode" class="headerlink" title="五:xcode schemexcode"></a>五:xcode schemexcode</h3><p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>
<p>一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。</p>
<h3 id="六-案例"><a href="#六-案例" class="headerlink" title="六:案例"></a>六:案例</h3><p>下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 &gt; file &gt; New Workspace 新建一个空的workspace，名字可以随便取。<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png" alt="image"></p>
<p>在左边 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Framework &amp; Library &gt; Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png" alt="image"></p>
<p>在左边的 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Application &gt; Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace &gt; libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png" alt="image"><br>现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。</p>
<p>参考文章：<a href="http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory" target="_blank" rel="external">http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory</a></p>
<p><a href="http://gcblog.github.io" target="_blank" rel="external">!更多文章可前往我的blog：http://gcblog.github.io</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。&lt;/p&gt;
&lt;h3 id=&quot;一-target&quot;&gt;&lt;a href=&quot;#一-target&quot; class=&quot;headerlink&quot; title=&quot;一:target&quot;&gt;&lt;/a&gt;一:target&lt;/h3&gt;&lt;p&gt;target指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。&lt;/p&gt;
&lt;p&gt;target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。&lt;/p&gt;
&lt;p&gt;若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS配置" scheme="http://gcblog/github.io/categories/iOS%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="workspace" scheme="http://gcblog/github.io/tags/workspace/"/>
    
  </entry>
  
  <entry>
    <title>iOS缓存机制-非结构化存储</title>
    <link href="http://gcblog/github.io/2016/03/12/iOS%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <id>http://gcblog/github.io/2016/03/12/iOS缓存机制-非结构化存储/</id>
    <published>2016-03-12T11:43:33.000Z</published>
    <updated>2016-11-17T15:00:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。</p>
<p>它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟<code>NSUserDefaults</code>用法类似。</p>
<p>以下排名按照性能由低到高：</p>
<h3 id="1-EGOCache"><a href="#1-EGOCache" class="headerlink" title="1.EGOCache"></a>1.EGOCache</h3><p> 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。</p>
<h3 id="2-TMCache"><a href="#2-TMCache" class="headerlink" title="2.TMCache"></a>2.TMCache</h3><p> 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。</p>
<h3 id="3-PINCache"><a href="#3-PINCache" class="headerlink" title="3.PINCache"></a>3.PINCache</h3><p> 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。</p>
<a id="more"></a>
<h3 id="4-YYCache"><a href="#4-YYCache" class="headerlink" title="4.YYCache"></a>4.YYCache</h3><p> YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。</p>
<p> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png" alt="image"></p>
<p> YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。<br> 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. 可以设置缓存上限，设置一定时间内定时清理缓存</div><div class="line">2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型</div><div class="line">3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域</div><div class="line">4. 以上所有参数都可以根据自己的需求自行设置</div></pre></td></tr></table></figure>
<p> <a href="https://github.com/suifengqjn/KVCache" target="_blank" rel="external">demo地址</a></p>
<p> <a href="http://gcblog.gtihub.io" target="_blank" rel="external">github Blog同步更新</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。&lt;/p&gt;
&lt;p&gt;它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟&lt;code&gt;NSUserDefaults&lt;/code&gt;用法类似。&lt;/p&gt;
&lt;p&gt;以下排名按照性能由低到高：&lt;/p&gt;
&lt;h3 id=&quot;1-EGOCache&quot;&gt;&lt;a href=&quot;#1-EGOCache&quot; class=&quot;headerlink&quot; title=&quot;1.EGOCache&quot;&gt;&lt;/a&gt;1.EGOCache&lt;/h3&gt;&lt;p&gt; 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。&lt;/p&gt;
&lt;h3 id=&quot;2-TMCache&quot;&gt;&lt;a href=&quot;#2-TMCache&quot; class=&quot;headerlink&quot; title=&quot;2.TMCache&quot;&gt;&lt;/a&gt;2.TMCache&lt;/h3&gt;&lt;p&gt; 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。&lt;/p&gt;
&lt;h3 id=&quot;3-PINCache&quot;&gt;&lt;a href=&quot;#3-PINCache&quot; class=&quot;headerlink&quot; title=&quot;3.PINCache&quot;&gt;&lt;/a&gt;3.PINCache&lt;/h3&gt;&lt;p&gt; 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="缓存" scheme="http://gcblog/github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="性能" scheme="http://gcblog/github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
</feed>
