<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code随手记</title>
  <subtitle>Practice from here</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gcblog/github.io/"/>
  <updated>2018-07-04T11:38:04.031Z</updated>
  <id>http://gcblog/github.io/</id>
  
  <author>
    <name>夜千寻墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式Raft算法原理及实现</title>
    <link href="http://gcblog/github.io/2018/07/04/%E5%88%86%E5%B8%83%E5%BC%8FRaft%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/07/04/分布式Raft算法原理及实现/</id>
    <published>2018-07-04T11:37:18.000Z</published>
    <updated>2018-07-04T11:38:04.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Raft-状态"><a href="#Raft-状态" class="headerlink" title="Raft 状态"></a>Raft 状态</h2><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：</p>
<ul>
<li><code>follower（跟随者）</code> ：所有结点都以 <code>follower</code> 的状态开始。如果没收到 <code>leader</code>消息则会变成 <code>candidate</code>状态。</li>
<li><code>candidate（候选人）</code>：会向其他结点“拉选票”，如果得到大部分的票则成为<code>leader</code>。这个过程就叫做Leader选举(Leader Election)。</li>
<li><code>leader（领导者）</code>：所有对系统的修改都会先经过<code>leader</code>。</li>
</ul>
<a id="more"></a>
<h2 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h2><p>Raft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。</p>
<p>基于leader的方法，Raft算法可以分解成三个子问题：</p>
<p><code>Leader election</code> (领导选举)：原来的leader挂掉后，必须选出一个新的leader</p>
<p><code>Log replication</code> (日志复制)：leader从客户端接收日志，并复制到整个集群中</p>
<p><code>Safety</code> (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项</p>
<h2 id="Leader-election-领导选举"><a href="#Leader-election-领导选举" class="headerlink" title="Leader election (领导选举)"></a>Leader election (领导选举)</h2><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 <code>follower</code>(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，<code>follower</code> 会给当前term加1并且转换成<code>candidate</code>状态。</p>
<p>然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，</p>
<ul>
<li><p>他自己赢得了这次的选举</p>
<ul>
<li>如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。</li>
<li>当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。</li>
</ul>
</li>
<li><p>其他的服务器成为领导者</p>
<p>  如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理：</p>
<ul>
<li>如果leader的term大于或等于自身的term，那么改<code>candidate</code> 会转成<code>follower</code> 状态</li>
<li>如果leader的term小于自身的term，那么会拒绝该 <code>leader</code>，并继续保持<code>candidate</code> 状态</li>
</ul>
</li>
<li><p>一段时间之后没有任何一个获胜的人</p>
<ul>
<li><p>有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。</p>
</li>
<li><p>Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Log-replication-日志复制"><a href="#Log-replication-日志复制" class="headerlink" title="Log replication (日志复制)"></a>Log replication (日志复制)</h2><p>当选出 <code>leader</code> 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。<code>leader</code> 把指令追加成一个<code>log entry</code>，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，<code>leader</code> 会把该entry回放到状态机中，然后把结果返回给客户端。</p>
<p>当 <code>follower</code> 宕机或者运行较慢时，<code>leader</code> 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。</p>
<p>raft的log replication保证以下性质(Log Matching Property)：</p>
<ul>
<li><p>如果两个log entry有相同的index和term，那么它们存储相同的指令</p>
</li>
<li><p>如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的</p>
</li>
</ul>
<p>其中特性一通过以下保证：</p>
<ul>
<li>leader在一个特定的term和index下，只会创建一个log entry</li>
<li>log entry不会改变它们在日志中的位置</li>
</ul>
<p>特性二通过以下保证：</p>
<ul>
<li>AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm)</li>
</ul>
<p>如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。</p>
<p>为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。</p>
<h3 id="提交之前任期内的日志条目"><a href="#提交之前任期内的日志条目" class="headerlink" title="提交之前任期内的日志条目"></a>提交之前任期内的日志条目</h3><p>领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180123-10289.png" alt=""></p>
<p>如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下：</p>
<ul>
<li><p>图a中，S1被选为主，然后复制到log index为2的log entry到S2上</p>
</li>
<li><p>图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3)</p>
</li>
<li><p>图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉</p>
</li>
<li><p>图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry</p>
</li>
</ul>
<p>为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。</p>
<h3 id="安全性论证"><a href="#安全性论证" class="headerlink" title="安全性论证"></a>安全性论证</h3><p>以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180123-23202.png" alt=""></p>
<blockquote>
<p>如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p>
</blockquote>
<ol>
<li><p>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</p>
</li>
<li><p>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。</p>
</li>
<li><p>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</p>
</li>
<li><p>投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。</p>
</li>
<li><p>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</p>
<ul>
<li><p>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</p>
</li>
<li><p>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。</p>
</li>
</ul>
</li>
<li><p>因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目</p>
</li>
</ol>
<h3 id="跟随者和候选人崩溃"><a href="#跟随者和候选人崩溃" class="headerlink" title="跟随者和候选人崩溃"></a>跟随者和候选人崩溃</h3><p>跟随者或者候选人崩溃，会按如下处理：</p>
<ul>
<li>领导者会不断给它发送选举和追加日志的RPC，直到成功</li>
<li>跟随者会忽略它已经处理过的追加日志的RPC</li>
</ul>
<h3 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h3><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>广播时间</strong>指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；</p>
</li>
<li><p><strong>选举超时时间</strong>就是选举的超时时间限制</p>
</li>
<li><p><strong>平均故障间隔时间</strong>就是对于一台服务器而言，两次故障之间的平均时间。</p>
</li>
</ul>
<p>选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。</p>
<p>选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。</p>
<p>对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。</p>
<h2 id="动画演示-Raft"><a href="#动画演示-Raft" class="headerlink" title="动画演示 Raft"></a>动画演示 Raft</h2><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现效果：<br>4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;flag&quot;</div><div class="line">	&quot;net&quot;</div><div class="line">	&quot;strconv&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">	&quot;strings&quot;</div><div class="line">	&quot;net/http&quot;</div><div class="line">	&quot;math/rand&quot;</div><div class="line">)</div><div class="line"></div><div class="line">const (</div><div class="line">	LEADER = iota</div><div class="line">	CANDIDATE</div><div class="line">	FOLLOWER</div><div class="line">)</div><div class="line"></div><div class="line">//声明地址信息</div><div class="line">type Addr struct &#123;</div><div class="line">	Host string  //ip</div><div class="line">	Port int</div><div class="line">	Addr string</div><div class="line">&#125;</div><div class="line"></div><div class="line">type RaftServer struct &#123;</div><div class="line"></div><div class="line">	Votes int //选票</div><div class="line">	Role int // 角色 follower candidate leader</div><div class="line">	Nodes []Addr</div><div class="line">	isElecting bool //判断当前节点是否处于选举中</div><div class="line">	Timeout int //选举间隔时间（也叫超时时间）</div><div class="line">	ElecChan chan bool //通道信号</div><div class="line">	HeartBeatChan chan bool  //leader 的心跳信号</div><div class="line">	Port int //端口号</div><div class="line"></div><div class="line">	//网页接收到的参数 由主节点向子节点传参</div><div class="line">	CusMsg chan string</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (rs *RaftServer)changeRole(role int)  &#123;</div><div class="line">	switch role &#123;</div><div class="line">	case LEADER:</div><div class="line">		fmt.Println(&quot;leader&quot;)</div><div class="line">	case CANDIDATE:</div><div class="line">		fmt.Println(&quot;candidate&quot;)</div><div class="line">	case FOLLOWER:</div><div class="line">		fmt.Println(&quot;follower&quot;)</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	rs.Role = role</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (rs *RaftServer)resetTimeout()  &#123;</div><div class="line">	//Raft系统一般为1500-3000毫秒选一次</div><div class="line">	rs.Timeout =  2000</div><div class="line">&#125;</div><div class="line"></div><div class="line">//运行服务器</div><div class="line">func (rs *RaftServer)Run()  &#123;</div><div class="line">	//rs监听 是否有人 给我投票</div><div class="line">	listen , _ := net.Listen(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(rs.Port))</div><div class="line"></div><div class="line">	defer listen.Close()</div><div class="line"></div><div class="line">	go rs.elect()</div><div class="line"></div><div class="line">	//控制投票时间</div><div class="line">	go rs.electTimeDuration()</div><div class="line"></div><div class="line">	//go rs.printRole()</div><div class="line"></div><div class="line">	// 主节点发送心跳</div><div class="line">	go rs.sendHeartBeat()</div><div class="line">	//</div><div class="line">	go rs.sendDataToOtherNodes()</div><div class="line"></div><div class="line">	//监听http协议</div><div class="line">	go rs.setHttpServer()</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		conn,_ := listen.Accept()</div><div class="line">		go func()&#123;</div><div class="line"></div><div class="line">			for &#123;</div><div class="line">				by := make([]byte, 1024)</div><div class="line">				n,_:= conn.Read(by)</div><div class="line">				fmt.Println(&quot;收到消息&quot;, string(by[:n]))</div><div class="line"></div><div class="line">				value := string(by[:n])</div><div class="line">				v,_ := strconv.Atoi(value)</div><div class="line">				if v == rs.Port &#123;</div><div class="line">					rs.Votes++</div><div class="line">					fmt.Println(&quot;当前票数：&quot;, rs.Votes)</div><div class="line">					// leader 选举成功</div><div class="line">					if VoteSuccess(rs.Votes, 5) == true &#123;</div><div class="line">						fmt.Printf(&quot;我是 %v, 我被选举成leader&quot;, rs.Port)</div><div class="line"></div><div class="line">						//通知其他节点。停止选举</div><div class="line">						//重置其他节点状态和票数</div><div class="line">						rs.VoteToOther(&quot;stopVote&quot;)</div><div class="line">						rs.isElecting = false</div><div class="line">						//改变当前节点状态</div><div class="line"></div><div class="line">						rs.changeRole(LEADER)</div><div class="line">						break</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">				//收到leader发来的消息</div><div class="line">				if strings.HasPrefix(string(by[:n]), &quot;stopVote&quot;) &#123;</div><div class="line">					//停止给别人投票</div><div class="line">					rs.isElecting = false</div><div class="line">					//回退自己的状态</div><div class="line">					rs.changeRole(FOLLOWER)</div><div class="line">					break</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func VoteSuccess(vote int, target int) bool  &#123;</div><div class="line">	if vote &gt;= target &#123;</div><div class="line">		return true</div><div class="line">	&#125;</div><div class="line">	return false</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//发送数据)</div><div class="line">func (rs *RaftServer)VoteToOther(data string)  &#123;</div><div class="line">	for _,k := range rs.Nodes &#123;</div><div class="line">		if k.Port != rs.Port &#123;</div><div class="line">			if data == &quot;1234&quot; &#123;</div><div class="line">				fmt.Println(&quot;-------------&quot;, k.Port)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			label :conn,err := net.Dial(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(k.Port))</div><div class="line">			for  &#123;</div><div class="line">				if err != nil &#123;</div><div class="line">					time.Sleep(1*time.Second)</div><div class="line">					goto  label</div><div class="line">				&#125;</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">			conn.Write([]byte(data))</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//给别人投票</div><div class="line">func (rs *RaftServer)elect()  &#123;</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		//通过通道确定现在可以给别人投票</div><div class="line"></div><div class="line">		&lt;- rs.ElecChan</div><div class="line"></div><div class="line">		//给其他节点投票，不能投给自己</div><div class="line">		vote := getVoteNum()</div><div class="line"></div><div class="line">		rs.VoteToOther(strconv.Itoa(vote))</div><div class="line">		// 设置选举状态</div><div class="line">		if rs.Role != LEADER &#123;</div><div class="line">			rs.changeRole(CANDIDATE)</div><div class="line">		&#125; else &#123;</div><div class="line">			//是leader的情况</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func getVoteNum() int  &#123;</div><div class="line"></div><div class="line">	rand.Seed(time.Now().UnixNano())</div><div class="line">	return rand.Intn(4) + 5000</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func (rs *RaftServer)electTimeDuration()  &#123;</div><div class="line">	//</div><div class="line">	fmt.Println(&quot;+++&quot;, rs.isElecting)</div><div class="line">	for &#123;</div><div class="line">		if rs.isElecting &#123;</div><div class="line"></div><div class="line">			rs.ElecChan &lt;- true</div><div class="line">			time.Sleep(time.Duration(rs.Timeout) * time.Millisecond)</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打印当前对象的角色</div><div class="line">func (rs *RaftServer)printRole()  &#123;</div><div class="line">	for  &#123;</div><div class="line">		time.Sleep(1 * time.Second)</div><div class="line">		fmt.Println(rs.Port, &quot;状态为&quot;, rs.Role, rs.isElecting)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	//获取参数</div><div class="line">	//运行  go run main.go -p 5000  (p 后面就是要启动的端口)</div><div class="line">	port := flag.Int(&quot;p&quot;,1234,&quot;port&quot;)</div><div class="line">	flag.Parse()</div><div class="line">	fmt.Println(*port)</div><div class="line"></div><div class="line">	rs := RaftServer&#123;&#125;</div><div class="line">	rs.isElecting = true</div><div class="line">	rs.Votes = 0</div><div class="line">	rs.Role = FOLLOWER</div><div class="line">	//控制是否开始投票</div><div class="line">	rs.ElecChan = make(chan bool)</div><div class="line">	rs.HeartBeatChan = make(chan bool)</div><div class="line">	rs.CusMsg = make(chan string)</div><div class="line">	rs.resetTimeout()</div><div class="line">	rs.Nodes = []Addr&#123;</div><div class="line">		&#123;&quot;127.0.0.1&quot;,5000,&quot;5000&quot;&#125;,</div><div class="line">		&#123;&quot;127.0.0.1&quot;,5001,&quot;5001&quot;&#125;,</div><div class="line">		&#123;&quot;127.0.0.1&quot;,5002,&quot;5002&quot;&#125;,</div><div class="line">		&#123;&quot;127.0.0.1&quot;,5003,&quot;5003&quot;&#125;,</div><div class="line">	&#125;</div><div class="line">	rs.Port = *port</div><div class="line"></div><div class="line">	rs.Run()</div><div class="line"></div><div class="line">&#125;</div><div class="line">//主节点发送心跳信号给其他节点</div><div class="line">func (rs *RaftServer)sendHeartBeat()  &#123;</div><div class="line">	// 每隔1s 发送一次心跳</div><div class="line">	for &#123;</div><div class="line">		time.Sleep(1 * time.Second)</div><div class="line">		if rs.Role == LEADER &#123;</div><div class="line">			//发送消息</div><div class="line">			rs.VoteToOther(&quot;heat beating&quot;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//通过leader 给其他所有子节点发送数据</div><div class="line">func (rs *RaftServer)sendDataToOtherNodes()  &#123;</div><div class="line">	for &#123;</div><div class="line">		msg :=&lt;-rs.CusMsg</div><div class="line">		if rs.Role == LEADER &#123;</div><div class="line">			//发送消息</div><div class="line">			rs.VoteToOther(msg)</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//开启http服务器</div><div class="line">func (rs *RaftServer)setHttpServer()  &#123;</div><div class="line"></div><div class="line">	http.HandleFunc(&quot;/req&quot;, rs.request)</div><div class="line">	httpPort := rs.Port + 10</div><div class="line">	if err:=http.ListenAndServe(&quot;:&quot;+strconv.Itoa(httpPort), nil); err == nil &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//leader向其他子节点发送数据</div><div class="line">func (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request)&#123;</div><div class="line"></div><div class="line">	request.ParseForm()</div><div class="line">	if len(request.Form[&quot;data&quot;][0]) &gt; 0 &#123;</div><div class="line">		writer.Write([]byte(&quot;ok&quot;))</div><div class="line">		fmt.Println(request.Form[&quot;data&quot;][0])</div><div class="line">		rs.CusMsg &lt;- request.Form[&quot;data&quot;][0]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行：<br>开启4个终端 分别执行 </p>
<ul>
<li>go run main.go -p 5000</li>
<li>go run main.go -p 5001</li>
<li>go run main.go -p 5002</li>
<li>go run main.go -p 5003</li>
</ul>
<p>如果5001成为了leader，在浏览器输入<code>http://127.0.0.1:5011/req?data=XXX</code><br>xxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Raft-状态&quot;&gt;&lt;a href=&quot;#Raft-状态&quot; class=&quot;headerlink&quot; title=&quot;Raft 状态&quot;&gt;&lt;/a&gt;Raft 状态&lt;/h2&gt;&lt;p&gt;一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;follower（跟随者）&lt;/code&gt; ：所有结点都以 &lt;code&gt;follower&lt;/code&gt; 的状态开始。如果没收到 &lt;code&gt;leader&lt;/code&gt;消息则会变成 &lt;code&gt;candidate&lt;/code&gt;状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;candidate（候选人）&lt;/code&gt;：会向其他结点“拉选票”，如果得到大部分的票则成为&lt;code&gt;leader&lt;/code&gt;。这个过程就叫做Leader选举(Leader Election)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leader（领导者）&lt;/code&gt;：所有对系统的修改都会先经过&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://gcblog/github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://gcblog/github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Raft" scheme="http://gcblog/github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>拜占庭PBFT简单实现</title>
    <link href="http://gcblog/github.io/2018/07/03/%E6%8B%9C%E5%8D%A0%E5%BA%ADPBFT%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/07/03/拜占庭PBFT简单实现/</id>
    <published>2018-07-03T10:57:53.000Z</published>
    <updated>2018-07-03T11:00:39.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PBFT（拜占庭容错）"><a href="#PBFT（拜占庭容错）" class="headerlink" title="PBFT（拜占庭容错）"></a>PBFT（拜占庭容错）</h2><p>基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p>
<p>其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：</p>
<ol>
<li>Request：请求端C发送请求到任意一节点，这里是0</li>
<li>Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123</li>
<li>Prepare：123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播</li>
<li>Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求<br>5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈</li>
</ol>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;os&quot;</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;net/http&quot;</div><div class="line">	&quot;io&quot;</div><div class="line">)</div><div class="line"></div><div class="line">//声明节点信息,代表各个小国家</div><div class="line">type nodeInfo struct &#123;</div><div class="line">	//标示</div><div class="line">	id string</div><div class="line">	//准备访问的方法</div><div class="line">	path string</div><div class="line">	//服务器做出的相应</div><div class="line">	writer http.ResponseWriter</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//存放四个国家的地址</div><div class="line">var nodeTable = make(map[string]string)</div><div class="line"></div><div class="line">//拜占庭在Fabric中的使用</div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">	//获取执行的参数</div><div class="line">	userId :=os.Args[1]//获取执行的第一个参数</div><div class="line">	fmt.Println(userId)</div><div class="line"></div><div class="line">	//./main Apple</div><div class="line"></div><div class="line">	//创建四个国家的地址</div><div class="line">	nodeTable = map[string]string &#123;</div><div class="line">		&quot;Apple&quot;:&quot;localhost:1111&quot;,</div><div class="line">		&quot;MS&quot;:&quot;localhost:1112&quot;,</div><div class="line">		&quot;Google&quot;:&quot;localhost:1113&quot;,</div><div class="line">		&quot;IBM&quot;:&quot;localhost:1114&quot;,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	node:=nodeInfo&#123;userId,nodeTable[userId],nil&#125;</div><div class="line">	fmt.Println(node)</div><div class="line"></div><div class="line">	//http协议的回调函数</div><div class="line">	//http://localhost:1111/req?warTime=8888</div><div class="line">	http.HandleFunc(&quot;/req&quot;,node.request)</div><div class="line">	http.HandleFunc(&quot;/prePrepare&quot;,node.prePrepare)</div><div class="line">	http.HandleFunc(&quot;/prepare&quot;,node.prepare)</div><div class="line">	http.HandleFunc(&quot;/commit&quot;,node.commit)</div><div class="line"></div><div class="line">	//启动服务器</div><div class="line">	if err:=http.ListenAndServe(node.path,nil);err!=nil &#123;</div><div class="line">		fmt.Print(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//此函数是http访问时候req命令的请求回调函数</div><div class="line">func (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request)&#123;</div><div class="line">	//设置允许解析参数</div><div class="line">	request.ParseForm()</div><div class="line">	//如果有参数值，则继续处理</div><div class="line">	if (len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</div><div class="line">		node.writer = writer</div><div class="line">		//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播</div><div class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prePrepare&quot;)</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//由主节点向其他节点做广播</div><div class="line">func (node *nodeInfo)broadcast(msg string ,path string )&#123;</div><div class="line">	//遍历所有的国家</div><div class="line">	for nodeId,url:=range nodeTable &#123;</div><div class="line"></div><div class="line">		if nodeId == node.id &#123;</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		//调用Get请求</div><div class="line">		//http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;)</div><div class="line">		http.Get(&quot;http://&quot;+url+path+&quot;?warTime=&quot;+msg+&quot;&amp;nodeId=&quot;+node.id)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) &#123;</div><div class="line">	request.ParseForm()</div><div class="line">	//fmt.Println(&quot;hello world&quot;)</div><div class="line">	//在做分发</div><div class="line">	if(len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</div><div class="line">		//分发给其他三个人</div><div class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request)&#123;</div><div class="line"></div><div class="line">	request.ParseForm()</div><div class="line">	//调用验证</div><div class="line">	if len(request.Form[&quot;warTime&quot;])&gt;0&#123;</div><div class="line">		fmt.Println(request.Form[&quot;warTime&quot;][0])</div><div class="line">	&#125;</div><div class="line">	if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</div><div class="line">		fmt.Println(request.Form[&quot;nodeId&quot;][0])</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	node.authentication(request)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var authenticationsuccess = true</div><div class="line">var authenticationMap = make(map[string]string)</div><div class="line">//获得除了本节点外的其他节点数据</div><div class="line">func (node *nodeInfo)authentication(request *http.Request) &#123;</div><div class="line"></div><div class="line">	//接收参数</div><div class="line">	request.ParseForm()</div><div class="line"></div><div class="line">	if authenticationsuccess!=false  &#123;</div><div class="line">		if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</div><div class="line">			authenticationMap[request.Form[&quot;nodeId&quot;][0]]=&quot;ok&quot;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if len(authenticationMap)&gt;len(nodeTable)/3 &#123;</div><div class="line">		//则拜占庭原理实现,通过commit反馈给浏览器</div><div class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)&#123;</div><div class="line"></div><div class="line">	//给浏览器反馈相应</div><div class="line">	io.WriteString(node.writer,&quot;ok&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如何运行：开启4个终端，eg：go run main.go Apple  …<br>然后在浏览器输入：<code>http://localhost:1112/req?warTime=1234</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PBFT（拜占庭容错）&quot;&gt;&lt;a href=&quot;#PBFT（拜占庭容错）&quot; class=&quot;headerlink&quot; title=&quot;PBFT（拜占庭容错）&quot;&gt;&lt;/a&gt;PBFT（拜占庭容错）&lt;/h2&gt;&lt;p&gt;基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Request：请求端C发送请求到任意一节点，这里是0&lt;/li&gt;
&lt;li&gt;Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123&lt;/li&gt;
&lt;li&gt;Prepare：123,收到后记录并再次广播，1-&amp;gt;023，2-&amp;gt;013，3因为宕机无法广播&lt;/li&gt;
&lt;li&gt;Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求&lt;br&gt;5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="拜占庭" scheme="http://gcblog/github.io/tags/%E6%8B%9C%E5%8D%A0%E5%BA%AD/"/>
    
      <category term="PBFT" scheme="http://gcblog/github.io/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>共识算法DPOS原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/29/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95DPOS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/29/共识算法DPOS原理及实现/</id>
    <published>2018-06-29T11:31:58.000Z</published>
    <updated>2018-06-29T11:34:46.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>DPOS：Delegated Proof of Stake，委任权益证明<br>它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。</p>
<h2 id="算法具体实现原理"><a href="#算法具体实现原理" class="headerlink" title="算法具体实现原理"></a>算法具体实现原理</h2><p>假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。</p>
<a id="more"></a>
<h2 id="代码简单实现其原理"><a href="#代码简单实现其原理" class="headerlink" title="代码简单实现其原理"></a>代码简单实现其原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;math/rand&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">	&quot;strconv&quot;</div><div class="line">	&quot;crypto/sha256&quot;</div><div class="line">	&quot;encoding/hex&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Block struct &#123;</div><div class="line">	Index int</div><div class="line">	Timestamp string</div><div class="line">	Prehash string</div><div class="line">	Hash string</div><div class="line">	Data []byte</div><div class="line"></div><div class="line">	delegate *Node// 代理 区块由哪个节点挖出</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func GenesisBlock()  Block &#123;</div><div class="line">	gene := Block&#123;0, time.Now().String(),&quot;&quot;, &quot;&quot;, []byte(&quot;genesis block&quot;), nil&#125;</div><div class="line"></div><div class="line">	gene.Hash = string(blockHash(gene))</div><div class="line"></div><div class="line">	return Block&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func blockHash(block Block) []byte  &#123;</div><div class="line"></div><div class="line">	record := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)</div><div class="line"></div><div class="line">	h := sha256.New()</div><div class="line">	h.Write([]byte(record))</div><div class="line">	hashed := h.Sum(nil)</div><div class="line">	return hashed</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//节点类型</div><div class="line">type Node struct &#123;</div><div class="line">	Name  string //节点名称</div><div class="line">	Votes int    // 被选举的票数</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block  &#123;</div><div class="line"></div><div class="line">	var newBlock = Block&#123;lastBlock.Index+1, time.Now().String(), lastBlock.Hash, &quot;&quot;, data, nil&#125;</div><div class="line"></div><div class="line">	newBlock.Hash = hex.EncodeToString(blockHash(newBlock))</div><div class="line">	newBlock.delegate = node</div><div class="line">	return newBlock</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建节点</div><div class="line">var NodeArr = make([]Node,10)</div><div class="line">func CreateNode() &#123;</div><div class="line"></div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		name := fmt.Sprintf(&quot;NODE %d num&quot;, i+1)</div><div class="line">		NodeArr[i] = Node&#123;name, 0&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//简单模拟投票</div><div class="line">func Vote()  &#123;</div><div class="line">	for i := 0; i &lt; 10; i++ &#123;</div><div class="line">		rand.Seed(time.Now().UnixNano())</div><div class="line">		vote := rand.Intn(10) + 1</div><div class="line">		NodeArr[i].Votes = vote</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//选出票数最多的前3位</div><div class="line">func SortNodes() []Node  &#123;</div><div class="line">	n:= NodeArr</div><div class="line">	for i := 0; i&lt;len(n) ;i++  &#123;</div><div class="line">		for j := 0; j &lt; len(n)-1 ;j++  &#123;</div><div class="line">			if n[j].Votes &lt; n[j+1].Votes &#123;</div><div class="line">				n[j],n[j+1] = n[j+1],n[j]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return n[:3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">	CreateNode()</div><div class="line">	fmt.Println(NodeArr)</div><div class="line">	Vote()</div><div class="line">	nodes := SortNodes()</div><div class="line"></div><div class="line">	fmt.Println(nodes)</div><div class="line"></div><div class="line"></div><div class="line">	//创建创世区块</div><div class="line">	gene := GenesisBlock()</div><div class="line"></div><div class="line">	lastBlock := gene</div><div class="line">	for i:= 0; i&lt; len(nodes) ;i++  &#123;</div><div class="line">		lastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(&quot;new block %d&quot;,i)))</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">竞选的节点 [&#123;第 1 个节点 0&#125; &#123;第 2 个节点 0&#125; &#123;第 3 个节点 0&#125; &#123;第 4 个节点 0&#125; &#123;第 5 个节点 0&#125; &#123;第 6 个节点 0&#125; &#123;第 7 个节点 0&#125; &#123;第 8 个节点 0&#125; &#123;第 9 个节点 0&#125; &#123;第 10 个节点 0&#125;]</div><div class="line">选出的节点 [&#123;第 10 个节点 8&#125; &#123;第 4 个节点 7&#125; &#123;第 3 个节点 6&#125;]</div><div class="line">第 10 个节点 出块 &#123;1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357  0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000&#125;</div><div class="line">第 4 个节点 出块 &#123;2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018&#125;</div><div class="line">第 3 个节点 出块 &#123;3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理简介&quot;&gt;&lt;a href=&quot;#原理简介&quot; class=&quot;headerlink&quot; title=&quot;原理简介&quot;&gt;&lt;/a&gt;原理简介&lt;/h2&gt;&lt;p&gt;DPOS：Delegated Proof of Stake，委任权益证明&lt;br&gt;它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。&lt;/p&gt;
&lt;h2 id=&quot;算法具体实现原理&quot;&gt;&lt;a href=&quot;#算法具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;算法具体实现原理&quot;&gt;&lt;/a&gt;算法具体实现原理&lt;/h2&gt;&lt;p&gt;假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DPOS" scheme="http://gcblog/github.io/tags/DPOS/"/>
    
      <category term="共识算法" scheme="http://gcblog/github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>共识算法POS原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/29/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95POS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/29/共识算法POS原理及实现/</id>
    <published>2018-06-29T11:31:41.000Z</published>
    <updated>2018-06-29T11:33:55.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POS简介"><a href="#POS简介" class="headerlink" title="POS简介"></a>POS简介</h2><p>POS：Proof of Stake，股权证明<br>类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。<br>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。</p>
<h2 id="算法具体实现原理"><a href="#算法具体实现原理" class="headerlink" title="算法具体实现原理"></a>算法具体实现原理</h2><p>每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。</p>
<a id="more"></a>
<h2 id="代码简单实现其原理"><a href="#代码简单实现其原理" class="headerlink" title="代码简单实现其原理"></a>代码简单实现其原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;time&quot;</div><div class="line">	&quot;strconv&quot;</div><div class="line">	&quot;crypto/sha256&quot;</div><div class="line">	&quot;math/rand&quot;</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;encoding/hex&quot;</div><div class="line">)</div><div class="line"></div><div class="line">//实现pos挖矿的原理</div><div class="line"></div><div class="line">type Block struct &#123;</div><div class="line">	Index int</div><div class="line">	Data string //</div><div class="line">	PreHash string</div><div class="line">	Hash string</div><div class="line">	Timestamp string</div><div class="line">	//记录挖矿节点</div><div class="line">	Validator *Node</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func genesisBlock() Block  &#123;</div><div class="line"></div><div class="line">	var genesBlock  = Block&#123;0, &quot;Genesis block&quot;,&quot;&quot;,&quot;&quot;,time.Now().String(),&amp;Node&#123;0, 0, &quot;dd&quot;&#125;&#125;</div><div class="line">	genesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock))</div><div class="line">	return genesBlock</div><div class="line">&#125;</div><div class="line"></div><div class="line">func BlockHash(block *Block) []byte  &#123;</div><div class="line">	record := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address</div><div class="line">	h := sha256.New()</div><div class="line">	h.Write([]byte(record))</div><div class="line">	hashed := h.Sum(nil)</div><div class="line"></div><div class="line">	return hashed</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建全节点类型</div><div class="line">type Node struct &#123;</div><div class="line">	Tokens int //持币数量</div><div class="line">	Days int //持币时间</div><div class="line">	Address string //地址</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//创建5个节点</div><div class="line">//算法的实现要满足 持币越多的节点越容易出块</div><div class="line">var nodes = make([]Node, 5)</div><div class="line">//存放节点的地址</div><div class="line">var addr = make([]*Node, 15)</div><div class="line"></div><div class="line"></div><div class="line">func InitNodes()  &#123;</div><div class="line"></div><div class="line">	nodes[0] = Node&#123;1, 1, &quot;0x12341&quot;&#125;</div><div class="line">	nodes[1] = Node&#123;2, 1, &quot;0x12342&quot;&#125;</div><div class="line">	nodes[2] = Node&#123;3, 1, &quot;0x12343&quot;&#125;</div><div class="line">	nodes[3] = Node&#123;4, 1, &quot;0x12344&quot;&#125;</div><div class="line">	nodes[4] = Node&#123;5, 1, &quot;0x12345&quot;&#125;</div><div class="line"></div><div class="line">	cnt :=0</div><div class="line">	for i:=0;i&lt;5;i++ &#123;</div><div class="line">		for j:=0;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123;</div><div class="line">			addr[cnt] = &amp;nodes[i]</div><div class="line">			cnt++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//采用Pos共识算法进行挖矿</div><div class="line">func CreateNewBlock(lastBlock *Block, data string) Block&#123;</div><div class="line"></div><div class="line">	var newBlock Block</div><div class="line">	newBlock.Index = lastBlock.Index + 1</div><div class="line">	newBlock.Timestamp = time.Now().String()</div><div class="line">	newBlock.PreHash = lastBlock.Hash</div><div class="line">	newBlock.Data = data</div><div class="line"></div><div class="line"></div><div class="line">	//通过pos计算由那个村民挖矿</div><div class="line">	//设置随机种子</div><div class="line">	rand.Seed(time.Now().Unix())</div><div class="line">	//[0,15)产生0-15的随机值</div><div class="line">	var rd =rand.Intn(15)</div><div class="line"></div><div class="line">	//选出挖矿的旷工</div><div class="line">	node := addr[rd]</div><div class="line">	//设置当前区块挖矿地址为旷工</div><div class="line">	newBlock.Validator = node</div><div class="line">	//简单模拟 挖矿所得奖励</div><div class="line">	node.Tokens += 1</div><div class="line">	newBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock))</div><div class="line">	return newBlock</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	InitNodes()</div><div class="line"></div><div class="line">	//创建创世区块</div><div class="line">	var genesisBlock = genesisBlock()</div><div class="line"></div><div class="line">	//创建新区快</div><div class="line">	var newBlock = CreateNewBlock(&amp;genesisBlock, &quot;new block&quot;)</div><div class="line"></div><div class="line">	//打印新区快信息</div><div class="line">	fmt.Println(newBlock)</div><div class="line">	fmt.Println(newBlock.Validator.Address)</div><div class="line">	fmt.Println(newBlock.Validator.Tokens)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0&#125;</div><div class="line">0x12341</div><div class="line">2</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POS简介&quot;&gt;&lt;a href=&quot;#POS简介&quot; class=&quot;headerlink&quot; title=&quot;POS简介&quot;&gt;&lt;/a&gt;POS简介&lt;/h2&gt;&lt;p&gt;POS：Proof of Stake，股权证明&lt;br&gt;类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。&lt;br&gt;简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。&lt;/p&gt;
&lt;h2 id=&quot;算法具体实现原理&quot;&gt;&lt;a href=&quot;#算法具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;算法具体实现原理&quot;&gt;&lt;/a&gt;算法具体实现原理&lt;/h2&gt;&lt;p&gt;每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="共识算法" scheme="http://gcblog/github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="POS" scheme="http://gcblog/github.io/tags/POS/"/>
    
  </entry>
  
  <entry>
    <title>共识算法POW原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/29/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95POW%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/29/共识算法POW原理及实现/</id>
    <published>2018-06-29T11:31:22.000Z</published>
    <updated>2018-06-29T11:33:06.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POW简介"><a href="#POW简介" class="headerlink" title="POW简介"></a>POW简介</h2><p>Proof of Work，工作证明。<br>POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法</p>
<h2 id="算法具体实现原理"><a href="#算法具体实现原理" class="headerlink" title="算法具体实现原理"></a>算法具体实现原理</h2><p>这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。<br>这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。</p>
<a id="more"></a>
<h2 id="代码简单实现其原理"><a href="#代码简单实现其原理" class="headerlink" title="代码简单实现其原理"></a>代码简单实现其原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;strconv&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">	&quot;crypto/sha256&quot;</div><div class="line">	&quot;strings&quot;</div><div class="line">	&quot;encoding/hex&quot;</div><div class="line">	&quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">//pow 挖矿算法</div><div class="line"></div><div class="line">//定义难度系数</div><div class="line">const difiiculty = 4</div><div class="line"></div><div class="line">type Block struct &#123;</div><div class="line">	Index      int // 区块高度</div><div class="line">	TimeStamp  int64</div><div class="line">	Data       string //交易记录</div><div class="line">	Hash       string</div><div class="line">	Prehash    string</div><div class="line">	Nonce      int</div><div class="line">	Difficulty int //难度系数</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建区块链</div><div class="line">var BlockChain []Block</div><div class="line"></div><div class="line">//创世区块</div><div class="line">func GenesisBlock() *Block &#123;</div><div class="line"></div><div class="line">	var geneBlock = Block&#123;0, time.Now().Unix(), &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, difiiculty&#125;</div><div class="line">	geneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock))</div><div class="line"></div><div class="line">	return &amp;geneBlock</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">func BlockHash(block Block) []byte &#123;</div><div class="line">	re := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash +</div><div class="line">		strconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty)</div><div class="line"></div><div class="line">	h := sha256.New()</div><div class="line">	h.Write([]byte(re))</div><div class="line">	hashed := h.Sum(nil)</div><div class="line"></div><div class="line">	return hashed</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func isBlockValid(block Block) bool  &#123;</div><div class="line">	prefix := strings.Repeat(&quot;0&quot;, block.Difficulty)</div><div class="line">	return strings.HasPrefix(block.Hash, prefix)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建新区块 pow挖矿</div><div class="line">func CreateNewBlock(lastBlock *Block, data string) *Block &#123;</div><div class="line">	var newBlock Block</div><div class="line">	newBlock.Index = lastBlock.Index + 1</div><div class="line">	newBlock.TimeStamp = time.Now().Unix()</div><div class="line">	newBlock.Data = data</div><div class="line">	newBlock.Prehash = lastBlock.Hash</div><div class="line">	newBlock.Difficulty = difiiculty</div><div class="line">	newBlock.Nonce = 0</div><div class="line">	//开挖-当前区块的hash值的前面的0的个数与难度系数值相同</div><div class="line">	for &#123;</div><div class="line">		//计算hash</div><div class="line">		cuhash := hex.EncodeToString(BlockHash(newBlock))</div><div class="line">		fmt.Println(&quot;挖矿中&quot;,cuhash)</div><div class="line">		newBlock.Hash = cuhash</div><div class="line">		if isBlockValid(newBlock) &#123;</div><div class="line"></div><div class="line">			//校验区块</div><div class="line">			if VerflyBlock(newBlock, *lastBlock) &#123;</div><div class="line">				fmt.Println(&quot;挖矿成功&quot;)</div><div class="line">				return  &amp;newBlock</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		newBlock.Nonce ++</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//校验新的区块是否合法</div><div class="line">func VerflyBlock(newblock Block, lastBlock Block) bool  &#123;</div><div class="line">	if lastBlock.Index +1 !=newblock.Index &#123;</div><div class="line">		return false</div><div class="line">	&#125;</div><div class="line">	if newblock.Prehash !=lastBlock.Hash &#123;</div><div class="line">		return false</div><div class="line">	&#125;</div><div class="line">	return true</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	var genBlock = GenesisBlock()</div><div class="line">	</div><div class="line">	newBlock := CreateNewBlock(genBlock,&quot;新区块&quot;)</div><div class="line">	fmt.Println(newBlock)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489</div><div class="line">挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae</div><div class="line">挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171</div><div class="line">挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811</div><div class="line">挖矿成功</div><div class="line">&amp;&#123;1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POW简介&quot;&gt;&lt;a href=&quot;#POW简介&quot; class=&quot;headerlink&quot; title=&quot;POW简介&quot;&gt;&lt;/a&gt;POW简介&lt;/h2&gt;&lt;p&gt;Proof of Work，工作证明。&lt;br&gt;POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法&lt;/p&gt;
&lt;h2 id=&quot;算法具体实现原理&quot;&gt;&lt;a href=&quot;#算法具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;算法具体实现原理&quot;&gt;&lt;/a&gt;算法具体实现原理&lt;/h2&gt;&lt;p&gt;这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。&lt;br&gt;这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="共识算法" scheme="http://gcblog/github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="POW" scheme="http://gcblog/github.io/tags/POW/"/>
    
  </entry>
  
  <entry>
    <title>ESA和ECC签名验签</title>
    <link href="http://gcblog/github.io/2018/06/28/ESA%E5%92%8CECC%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE/"/>
    <id>http://gcblog/github.io/2018/06/28/ESA和ECC签名验签/</id>
    <published>2018-06-28T10:52:24.000Z</published>
    <updated>2018-06-28T11:01:12.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESA"><a href="#ESA" class="headerlink" title="ESA"></a>ESA</h2><p>DSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。<br>在安全性上，DSA和RSA差不多，但是速度比RSA快很多。</p>
<a id="more"></a>
<h3 id="ESA签名和验签"><a href="#ESA签名和验签" class="headerlink" title="ESA签名和验签"></a>ESA签名和验签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	//设置私钥使用的参数</div><div class="line">	var param dsa.Parameters</div><div class="line">	dsa.GenerateParameters(&amp;param, rand.Reader, dsa.L1024N160)</div><div class="line"></div><div class="line">	//创建私钥</div><div class="line">	var pri dsa.PrivateKey</div><div class="line">	pri.Parameters = param</div><div class="line">	dsa.GenerateKey(&amp;pri, rand.Reader)</div><div class="line"></div><div class="line"></div><div class="line">	//生成公钥</div><div class="line">	pub := pri.PublicKey</div><div class="line"></div><div class="line"></div><div class="line">	//签名</div><div class="line">	message := []byte(&quot;hello&quot;)</div><div class="line">	r,s,_ := dsa.Sign(rand.Reader, &amp;pri, message)</div><div class="line"></div><div class="line"></div><div class="line">	//验证</div><div class="line">	if dsa.Verify(&amp;pub, message, r, s)&#123;</div><div class="line">		fmt.Println(&quot;验签成功&quot;)</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h2><p>椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。</p>
<p>椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。<br>比特币就是用ECC来做签名和验签。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</li>
<li>计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多</li>
<li>存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多</li>
<li>带宽要求低使得ECC具有广泛得应用前景
　　　</li>
</ul>
<h3 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h3><p>一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。</p>
<blockquote>
<p>E:y<sup>2</sup>=ax<sup>3</sup>+ bx<sup>2</sup>+cx+d</p>
</blockquote>
<p>例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为:</p>
<blockquote>
<p>E:y<sup>2</sup>=x<sup>3</sup>-2x+4</p>
</blockquote>
<p>该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。　　</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180117-211235.png" alt=""></p>
<h3 id="ECC签名和验签"><a href="#ECC签名和验签" class="headerlink" title="ECC签名和验签"></a>ECC签名和验签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	message := []byte(&quot;hello&quot;)</div><div class="line"></div><div class="line">	//设置生成的私钥为256位</div><div class="line">	privatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</div><div class="line"></div><div class="line">	//创建公钥</div><div class="line">	publicKey := privatekey.PublicKey</div><div class="line"></div><div class="line">	//hash散列明文</div><div class="line">	digest := sha256.Sum256(message)</div><div class="line"></div><div class="line"></div><div class="line">	//用私钥签名</div><div class="line">	r,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:])</div><div class="line"></div><div class="line">	//设置私钥的参数类型</div><div class="line">	param := privatekey.Curve.Params()</div><div class="line"></div><div class="line">	//获取私钥的长度（字节）</div><div class="line">	curveOrderBytes:=param.P.BitLen()/8</div><div class="line"></div><div class="line">	//获得签名返回的字节</div><div class="line">	rByte,sByte := r.Bytes(), s.Bytes()</div><div class="line"></div><div class="line">	//创建数组合并字节</div><div class="line">	signature := make([]byte,curveOrderBytes*2)</div><div class="line">	copy(signature[:len(rByte)], rByte)</div><div class="line">	copy(signature[len(sByte):], sByte)</div><div class="line"></div><div class="line">	//现在signature中就存放了完整的签名的结果</div><div class="line"></div><div class="line">	//验签</div><div class="line">	digest = sha256.Sum256(message)</div><div class="line">	//获得公钥的字节长度</div><div class="line">	curveOrderBytes= publicKey.Curve.Params().P.BitLen()/8</div><div class="line"></div><div class="line">	//创建大整数类型保存rbyte,sbyte</div><div class="line">	r,s = new(big.Int),new(big.Int)</div><div class="line"></div><div class="line">	r.SetBytes(signature[:curveOrderBytes])</div><div class="line">	s.SetBytes(signature[curveOrderBytes:])</div><div class="line"></div><div class="line"></div><div class="line">	//开始认证</div><div class="line">	e:=ecdsa.Verify(&amp;publicKey,digest[:],r,s)</div><div class="line">	if e== true &#123;</div><div class="line">		fmt.Println(&quot;验签成功&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ESA&quot;&gt;&lt;a href=&quot;#ESA&quot; class=&quot;headerlink&quot; title=&quot;ESA&quot;&gt;&lt;/a&gt;ESA&lt;/h2&gt;&lt;p&gt;DSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。&lt;br&gt;在安全性上，DSA和RSA差不多，但是速度比RSA快很多。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ESA" scheme="http://gcblog/github.io/tags/ESA/"/>
    
      <category term="ECC" scheme="http://gcblog/github.io/tags/ECC/"/>
    
      <category term="签名" scheme="http://gcblog/github.io/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="验签" scheme="http://gcblog/github.io/tags/%E9%AA%8C%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>RSA签名验签</title>
    <link href="http://gcblog/github.io/2018/06/28/RSA%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE/"/>
    <id>http://gcblog/github.io/2018/06/28/RSA签名验签/</id>
    <published>2018-06-28T10:51:55.000Z</published>
    <updated>2018-06-28T10:54:08.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是数字签名"><a href="#什么是数字签名" class="headerlink" title="什么是数字签名"></a>什么是数字签名</h2><p>数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p>
<h2 id="签名的生成和验证"><a href="#签名的生成和验证" class="headerlink" title="签名的生成和验证"></a>签名的生成和验证</h2><h3 id="生成消息签名的行为"><a href="#生成消息签名的行为" class="headerlink" title="生成消息签名的行为"></a>生成消息签名的行为</h3><p>生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。</p>
<a id="more"></a>
<h3 id="验证消息签名的行为"><a href="#验证消息签名的行为" class="headerlink" title="验证消息签名的行为"></a>验证消息签名的行为</h3><p>验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。</p>
<h2 id="公钥密码与数字签名"><a href="#公钥密码与数字签名" class="headerlink" title="公钥密码与数字签名"></a>公钥密码与数字签名</h2><p>在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。</p>
<h3 id="公钥密码机制"><a href="#公钥密码机制" class="headerlink" title="公钥密码机制"></a>公钥密码机制</h3><p>公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有<br>用与之对应的私钥才能正确解密。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 <strong>私钥加密</strong> 相当于 <strong>生成签名</strong>，而用 <strong>公钥解密</strong> 则相当于<strong>验证签名</strong>。</p>
<h2 id="数字签名算法"><a href="#数字签名算法" class="headerlink" title="数字签名算法"></a>数字签名算法</h2><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。</p>
<h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><p>DSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。</p>
<h3 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h3><p>ECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字<br>签名算法( NIST FIPS 186-3 )。</p>
<h2 id="RSA算法实现签名和验签"><a href="#RSA算法实现签名和验签" class="headerlink" title="RSA算法实现签名和验签"></a>RSA算法实现签名和验签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	//生成私钥</div><div class="line">	pri,_ := rsa.GenerateKey(rand.Reader, 1024)</div><div class="line"></div><div class="line">	//生成公钥</div><div class="line">	pub := &amp;pri.PublicKey</div><div class="line"></div><div class="line"></div><div class="line">	plainTxt := []byte(&quot;hello world，你好&quot;)</div><div class="line"></div><div class="line">	//对原文进行hash散列</div><div class="line">	h := md5.New()</div><div class="line">	h.Write(plainTxt)</div><div class="line">	hashed := h.Sum(nil)</div><div class="line"></div><div class="line"></div><div class="line">	opts := rsa.PSSOptions&#123;rsa.PSSSaltLengthAuto, crypto.MD5&#125;</div><div class="line"></div><div class="line">	//实现签名</div><div class="line"></div><div class="line">	sign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&amp;opts)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(sign))</div><div class="line">	</div><div class="line"></div><div class="line">	//通过公钥实现验签</div><div class="line">	err:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &amp;opts)</div><div class="line"></div><div class="line">	//err 为空 及验签成功</div><div class="line">	fmt.Println(&quot;err:&quot;, err)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是数字签名&quot;&gt;&lt;a href=&quot;#什么是数字签名&quot; class=&quot;headerlink&quot; title=&quot;什么是数字签名&quot;&gt;&lt;/a&gt;什么是数字签名&lt;/h2&gt;&lt;p&gt;数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。&lt;/p&gt;
&lt;h2 id=&quot;签名的生成和验证&quot;&gt;&lt;a href=&quot;#签名的生成和验证&quot; class=&quot;headerlink&quot; title=&quot;签名的生成和验证&quot;&gt;&lt;/a&gt;签名的生成和验证&lt;/h2&gt;&lt;h3 id=&quot;生成消息签名的行为&quot;&gt;&lt;a href=&quot;#生成消息签名的行为&quot; class=&quot;headerlink&quot; title=&quot;生成消息签名的行为&quot;&gt;&lt;/a&gt;生成消息签名的行为&lt;/h3&gt;&lt;p&gt;生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="签名" scheme="http://gcblog/github.io/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="验签" scheme="http://gcblog/github.io/tags/%E9%AA%8C%E7%AD%BE/"/>
    
      <category term="RSA" scheme="http://gcblog/github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密RSA原理简介及使用</title>
    <link href="http://gcblog/github.io/2018/06/27/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86RSA%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://gcblog/github.io/2018/06/27/非对称加密RSA原理简介及使用/</id>
    <published>2018-06-27T10:54:38.000Z</published>
    <updated>2018-06-28T10:36:59.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RSA"><a href="#什么是RSA" class="headerlink" title="什么是RSA"></a>什么是RSA</h2><p>RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。</p>
<p>RSA可以被用于公钥密码和数字签名。</p>
<h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><p>在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：</p>
<p><strong>密文=明文<sup>E</sup> mod N</strong> (RSA加密)</p>
<p>RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将<br>明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。</p>
<p>加密公式中出现的两个数<code>E</code>和 <code>N</code>，到底都是什么数呢? RSA的加密是求明文的<br><code>E</code>次方mod <code>N</code>，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，<code>E</code> 和 <code>N</code>是RSA加密的密钥，也就是说，<code>E</code> 和 <code>N</code>的组合就是公钥。</p>
<a id="more"></a>
<h2 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h2><p>RSA的解密和加密一样简单，可以用下面的公式来表达:</p>
<p><strong>明文=密文 <sup>D</sup> mod N</strong> ( RSA解密)</p>
<p>表示密文的数字的D次方求 mod N就可以得到明文。</p>
<p>这里所使用的数字N和加密时使用的数字N是相同的。数 <code>D</code> 和数 <code>N</code> 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。</p>
<p>在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>
<h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>在RSA中，加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>
<p>由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。</p>
<h2 id="生成私钥公钥步骤"><a href="#生成私钥公钥步骤" class="headerlink" title="生成私钥公钥步骤"></a>生成私钥公钥步骤</h2><p>用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥）</p>
<p>1.生成 RSA 私钥（传统格式的）</p>
<p><code>openssl genrsa -out rsa_private_key.pem 1024</code></p>
<p>2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车</p>
<p><code>openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM</code></p>
<p>3.生成 RSA 公钥</p>
<p><code>openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</code></p>
<p>此时在系统根目录已经生成了两个文件。可以直接使用<code>cat</code>命令查看文件中的内容</p>
<h2 id="代码实现加密以及解密过程"><a href="#代码实现加密以及解密过程" class="headerlink" title="代码实现加密以及解密过程"></a>代码实现加密以及解密过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----</div><div class="line">MIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNL</div><div class="line">d7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0</div><div class="line">TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB</div><div class="line">AoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPew</div><div class="line">MtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaem</div><div class="line">UOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1</div><div class="line">ybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNA</div><div class="line">Jh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhw</div><div class="line">nfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrr</div><div class="line">t4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9</div><div class="line">T+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi</div><div class="line">57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtF</div><div class="line">IXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi</div><div class="line">-----END RSA PRIVATE KEY-----`)</div><div class="line"></div><div class="line">var publicKey = []byte(`-----BEGIN PUBLIC KEY-----</div><div class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0</div><div class="line">nBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWO</div><div class="line">jmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxx</div><div class="line">LjPiWq1HQhmywNv3BQIDAQAB</div><div class="line">-----END PUBLIC KEY-----`)</div><div class="line"></div><div class="line">func main()  &#123;</div><div class="line"></div><div class="line"></div><div class="line">	data := []byte(&quot;hello world&quot;)</div><div class="line"></div><div class="line">	cry := RSAEncrypt(data)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(cry))</div><div class="line"></div><div class="line"></div><div class="line">	ori := RSADecrypt(cry)</div><div class="line">	fmt.Println(string(ori))</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func RSAEncrypt(plaintxt []byte) []byte  &#123;</div><div class="line"></div><div class="line">	//公钥加密</div><div class="line">	block, _:= pem.Decode(publicKey)</div><div class="line"></div><div class="line">	//解析公钥</div><div class="line">	pubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)</div><div class="line"></div><div class="line">	//加载公钥</div><div class="line">	pub := pubInterface.(*rsa.PublicKey)</div><div class="line"></div><div class="line">	//加密明文</div><div class="line">	bits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt)</div><div class="line"></div><div class="line">	//bits为最终的密文</div><div class="line">	return bits</div><div class="line">&#125;</div><div class="line"></div><div class="line">func RSADecrypt(cryptTxt []byte) []byte  &#123;</div><div class="line"></div><div class="line">	block,_:= pem.Decode(privateKey)</div><div class="line"></div><div class="line">	priv,_:= x509.ParsePKCS1PrivateKey(block.Bytes)</div><div class="line"></div><div class="line">	bits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt)</div><div class="line"></div><div class="line">	return bits</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8a</div><div class="line">hello world</div></pre></td></tr></table></figure></p>
<h2 id="代码实现生成公钥私钥来加密和解密"><a href="#代码实现生成公钥私钥来加密和解密" class="headerlink" title="代码实现生成公钥私钥来加密和解密"></a>代码实现生成公钥私钥来加密和解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	prikey := CreatePrivateKey()</div><div class="line">	pubKey := CreatePublic(prikey)</div><div class="line">	</div><div class="line">	// 加密和解密</div><div class="line">	ori:=[]byte(&quot;hello world!!!&quot;)</div><div class="line">	//通过oaep函数实现公钥加密</div><div class="line">	//第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要</div><div class="line">	cipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &amp;pubKey, ori, nil)</div><div class="line"></div><div class="line">	fmt.Println(cipherTxt)</div><div class="line"></div><div class="line">	//解密</div><div class="line">	plainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil)</div><div class="line">	fmt.Println(string(plainTxt))</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 创建私钥</div><div class="line">func CreatePrivateKey() *rsa.PrivateKey  &#123;</div><div class="line"></div><div class="line">	// 长度为1024 位 的私钥</div><div class="line">	pri,_:= rsa.GenerateKey(rand.Reader, 1024)</div><div class="line">	return pri</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 生成公钥</div><div class="line">func CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey  &#123;</div><div class="line">	return prikey.PublicKey</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是RSA&quot;&gt;&lt;a href=&quot;#什么是RSA&quot; class=&quot;headerlink&quot; title=&quot;什么是RSA&quot;&gt;&lt;/a&gt;什么是RSA&lt;/h2&gt;&lt;p&gt;RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。&lt;/p&gt;
&lt;p&gt;RSA可以被用于公钥密码和数字签名。&lt;/p&gt;
&lt;h2 id=&quot;RSA加密&quot;&gt;&lt;a href=&quot;#RSA加密&quot; class=&quot;headerlink&quot; title=&quot;RSA加密&quot;&gt;&lt;/a&gt;RSA加密&lt;/h2&gt;&lt;p&gt;在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;密文=明文&lt;sup&gt;E&lt;/sup&gt; mod N&lt;/strong&gt; (RSA加密)&lt;/p&gt;
&lt;p&gt;RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将&lt;br&gt;明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。&lt;/p&gt;
&lt;p&gt;加密公式中出现的两个数&lt;code&gt;E&lt;/code&gt;和 &lt;code&gt;N&lt;/code&gt;，到底都是什么数呢? RSA的加密是求明文的&lt;br&gt;&lt;code&gt;E&lt;/code&gt;次方mod &lt;code&gt;N&lt;/code&gt;，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，&lt;code&gt;E&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt;是RSA加密的密钥，也就是说，&lt;code&gt;E&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt;的组合就是公钥。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="RSA" scheme="http://gcblog/github.io/tags/RSA/"/>
    
      <category term="非对称加密" scheme="http://gcblog/github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>对称加密算法AES原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/27/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95AES%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/27/对称加密算法AES原理及实现/</id>
    <published>2018-06-27T10:52:14.000Z</published>
    <updated>2018-06-27T10:53:55.826Z</updated>
    
    <content type="html"><![CDATA[<p>AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。<br>　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。<br>　　<br><a id="more"></a>
　　</p>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>AES中没有使用Feistel网络，其结构称为SPN结构。<br>　　<br>和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。<br>　　<br>AES总体结构示意图：<br>　　<br><img src="http://olgjbx93m.bkt.clouddn.com/201801010001.png" alt="结构示意图"></p>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>密码算法可以分为分组密码和流密码两种</p>
<ul>
<li><p><strong>分组密码（block cipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。</p>
<p>  例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。</p>
</li>
<li><p><strong>流密码（stream cipher）</strong>是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。</p>
</li>
</ul>
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。</p>
<ul>
<li>ECB模式：Electronic CodeBook mode（电子密码模式）</li>
<li>CBC模式：Cipher Block Chaining mode（密码分组链接模式）</li>
<li>CFB模式：Cipher FeedBack mode（密文反馈模式）</li>
<li>OFB模式：Output FeedBack mode（输出反馈模式）</li>
<li>CTR模式：CounTeR mode（计数器模式）</li>
</ul>
<p>ECB模式存在很高的风险，下面举例后面4中模式的使用.<br>加密的过程中使用了随机流，所以每次加密的密文都不一样</p>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line"></div><div class="line"></div><div class="line">	key := &quot;1234567890asdfgh&quot;</div><div class="line">	data := &quot;hollo, world!&quot;</div><div class="line"></div><div class="line">	cry := AesCBCEncrypt([]byte(data), []byte(key))</div><div class="line">	fmt.Println(hex.EncodeToString(cry))</div><div class="line"></div><div class="line">	oriData := AESCBCDECriypt(cry, []byte(key))</div><div class="line">	fmt.Println(string(oriData))</div><div class="line"></div><div class="line">&#125;</div><div class="line">// AES也是对称加密 AES 是 DES 的替代品</div><div class="line">// AES 密钥长度 只能是 16、24、32 字节</div><div class="line">//加密</div><div class="line">func AesCBCEncrypt(org []byte, key []byte) []byte  &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	//按照公钥长度 进行分组补码</div><div class="line">	org = PKCS7Padding(org, block.BlockSize())</div><div class="line"></div><div class="line">	//设置CBC的加密模式</div><div class="line">	blockMode := cipher.NewCBCEncrypter(block, key)</div><div class="line"></div><div class="line">	//加密处理</div><div class="line">	crypted := make([]byte, len(org))</div><div class="line">	blockMode.CryptBlocks(crypted, org)</div><div class="line"></div><div class="line">	return crypted</div><div class="line">&#125;</div><div class="line"></div><div class="line">//解密</div><div class="line">func AESCBCDECriypt(criptText []byte, key []byte) []byte  &#123;</div><div class="line"></div><div class="line">	//校验key的有效性</div><div class="line">	block,_:=aes.NewCipher(key)</div><div class="line">	//通过CBC模式解密</div><div class="line">	blockMode:=cipher.NewCBCDecrypter(block,key)</div><div class="line"></div><div class="line">	//实现解密</div><div class="line">	origData:=make([]byte,len(criptText))</div><div class="line">	blockMode.CryptBlocks(origData,criptText)</div><div class="line"></div><div class="line">	//去码</div><div class="line">	origData = PKCS7UnPadding(origData)</div><div class="line">	return origData</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//PKCS5 分组长度只能为8</div><div class="line">//PKCs7 分组长度 1- 255</div><div class="line"></div><div class="line">func PKCS7Padding(org []byte, blockSize int) []byte  &#123;</div><div class="line"></div><div class="line">	pad := blockSize-len(org)%blockSize</div><div class="line">	padArr := bytes.Repeat([]byte&#123;byte(pad)&#125;, pad)</div><div class="line">	return  append(org, padArr...)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func PKCS7UnPadding(cryptText []byte) []byte  &#123;</div><div class="line">	</div><div class="line">	length := len(cryptText)</div><div class="line">	lastByte := cryptText[length - 1]</div><div class="line">	return cryptText[:length-int(lastByte)]</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ffa22c136fd3e944255d43e255c98ecc</div><div class="line">hollo, world!</div></pre></td></tr></table></figure></p>
<h3 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line"></div><div class="line">	key := []byte(&quot;1234567890asdfgh&quot;)</div><div class="line">	data := []byte(&quot;abc hello world!&quot;)</div><div class="line">	cry := AESCFBEncrypt(data, key)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(cry))</div><div class="line">	//fmt.Println(base64.StdEncoding.EncodeToString(cry))</div><div class="line"></div><div class="line">	ori := AESCFBDecrypt(cry, key)</div><div class="line">	fmt.Println(string(ori))</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//CFB分组模式加密</div><div class="line">func AESCFBEncrypt(oriData []byte, key []byte) []byte  &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	//拆分iv和密文</div><div class="line">	cipherText := make([]byte, aes.BlockSize + len(oriData))</div><div class="line"></div><div class="line">	iv := cipherText[:aes.BlockSize]</div><div class="line"></div><div class="line">	//向iv切片数组初始化 reader（随机内存流）</div><div class="line">	io.ReadFull(rand.Reader, iv)</div><div class="line"></div><div class="line">	//设置加密模式CFB</div><div class="line">	stream := cipher.NewCFBEncrypter(block,iv)</div><div class="line"></div><div class="line">	//加密</div><div class="line">	stream.XORKeyStream(cipherText[aes.BlockSize:], oriData)</div><div class="line"></div><div class="line">	return  cipherText</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//解密</div><div class="line">func AESCFBDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	//拆分iv 和密文</div><div class="line">	iv := cryptText[:aes.BlockSize]</div><div class="line">	cipherText := cryptText[aes.BlockSize:]</div><div class="line"></div><div class="line"></div><div class="line">	//设置解密模式</div><div class="line">	stream := cipher.NewCFBDecrypter(block, iv)</div><div class="line"></div><div class="line">	var des = make([]byte, len(cipherText))</div><div class="line"></div><div class="line">	//解密</div><div class="line">	stream.XORKeyStream(des, cipherText)</div><div class="line"></div><div class="line">	return des</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">92e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513</div><div class="line">abc hello world!</div></pre></td></tr></table></figure></p>
<h3 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	key := []byte(&quot;1234567890asdfgh&quot;)</div><div class="line">	data := []byte(&quot;abcd hello world!&quot;)</div><div class="line">	cry := AESOFBEncrypt(data, key)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(cry))</div><div class="line"></div><div class="line">	ori := AESOFBDecrypt(cry, key)</div><div class="line">	fmt.Println(string(ori))</div><div class="line">&#125;</div><div class="line"></div><div class="line">//AES OFB分组加密模式  CTR也是一样</div><div class="line">func AESOFBEncrypt(plaintxt []byte, key []byte) []byte  &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	cipherText := make([]byte, aes.BlockSize + len(plaintxt))</div><div class="line"></div><div class="line">	iv := cipherText[:aes.BlockSize]</div><div class="line"></div><div class="line">	//向iv切片数组初始化 reader（随机内存流）</div><div class="line">	io.ReadFull(rand.Reader, iv)</div><div class="line"></div><div class="line">	//设置加密模式CFB</div><div class="line">	stream := cipher.NewOFB(block,iv)</div><div class="line"></div><div class="line">	//加密</div><div class="line">	stream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</div><div class="line"></div><div class="line">	return  cipherText</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//解密</div><div class="line">func AESOFBDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	//拆分iv 和 密文</div><div class="line">	iv := cryptText[:aes.BlockSize]</div><div class="line">	plaintxt := make([]byte, len(cryptText)-aes.BlockSize)</div><div class="line"></div><div class="line"></div><div class="line">	//设置解密模式</div><div class="line">	stream := cipher.NewOFB(block, iv)</div><div class="line"></div><div class="line">	//解密</div><div class="line">	stream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</div><div class="line"></div><div class="line">	return plaintxt</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">9ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4</div><div class="line">abcd hello world!</div></pre></td></tr></table></figure></p>
<h3 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	key := []byte(&quot;1234567890asdfgh&quot;)</div><div class="line">	data := []byte(&quot;abcd hello world!&quot;)</div><div class="line">	cry := AESCTREncrypt(data, key)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(cry))</div><div class="line"></div><div class="line">	ori := AESCTRDecrypt(cry, key)</div><div class="line">	fmt.Println(string(ori))</div><div class="line">&#125;</div><div class="line"></div><div class="line">//AES CTR分组加密模式</div><div class="line">func AESCTREncrypt(plaintxt []byte, key []byte) []byte  &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	cipherText := make([]byte, aes.BlockSize + len(plaintxt))</div><div class="line"></div><div class="line">	iv := cipherText[:aes.BlockSize]</div><div class="line"></div><div class="line">	//向iv切片数组初始化 reader（随机内存流）</div><div class="line">	io.ReadFull(rand.Reader, iv)</div><div class="line"></div><div class="line">	//设置加密模式CTR</div><div class="line">	stream := cipher.NewCTR(block,iv)</div><div class="line"></div><div class="line">	//加密</div><div class="line">	stream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</div><div class="line"></div><div class="line">	return  cipherText</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//解密</div><div class="line">func AESCTRDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block,_ := aes.NewCipher(key)</div><div class="line"></div><div class="line">	//拆分iv 和 密文</div><div class="line">	iv := cryptText[:aes.BlockSize]</div><div class="line">	plaintxt := make([]byte, len(cryptText)-aes.BlockSize)</div><div class="line"></div><div class="line"></div><div class="line">	//设置解密模式</div><div class="line">	stream := cipher.NewCTR(block, iv)</div><div class="line"></div><div class="line">	//解密</div><div class="line">	stream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</div><div class="line"></div><div class="line">	return plaintxt</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534</div><div class="line">abcd hello world!</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。&lt;br&gt;　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。&lt;br&gt;　　&lt;br&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="对称加密" scheme="http://gcblog/github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="AES" scheme="http://gcblog/github.io/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>对称加密算法DES原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/26/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95DES%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/26/对称加密算法DES原理及实现/</id>
    <published>2018-06-26T11:24:12.000Z</published>
    <updated>2018-06-27T10:50:44.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2><p>DES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。<br> <br>　　DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。<br>　　<br><a id="more"></a></p>
<h2 id="Feistel网络"><a href="#Feistel网络" class="headerlink" title="Feistel网络"></a>Feistel网络</h2><p>DES的基本结构，由IBM公司的Horst Feistel设计，因此称Feistel网络。在Feistel网络中，加密的每个步骤称为轮，经过初始置换后的64位明文，进行了16轮Feistel轮的加密过程，最后经过终结置换后形成最终的64位密文。如下为Feistel网络的示意图：</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/5f65e67ee5cbf1514c5614e944684cc1af2a4096.jpg" alt="">  </p>
<p>64位明文被分为左、右两部分处理，右侧数据和子密钥经过轮函数f生成用于加密左侧数据的比特序列，与左侧数据异或运算，运算结果输出为加密后的左侧，右侧数据则直接输出为右侧。<br>　　其中子密钥为本轮加密使用的密钥，每次Feistel均使用不同的子密钥。子密钥的计算，以及轮函数的细节，稍后下文介绍。由于一次Feistel轮并不会加密右侧，因此需要将上一轮输出后的左右两侧对调后，重复Feistel轮的过程，DES算法共计进行16次Feistel轮，最后一轮输出后左右两侧无需对调。</p>
<p>DES加密和解密的过程一致，均使用Feistel网络实现，区别仅在于解密时，密文作为输入，并逆序使用子密钥。</p>
<h2 id="DES-加密算法的使用"><a href="#DES-加密算法的使用" class="headerlink" title="DES 加密算法的使用"></a>DES 加密算法的使用</h2><p>在使用DES加密前，需要自己实现对明文的补码和去码操作</p>
<p>补码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//实现PKCS5Padding补码</div><div class="line">func PKCS5Padding(cipherTxt [] byte, blockSize int) []byte &#123;</div><div class="line">	//计算准备添加的数字</div><div class="line">	padding := blockSize - len(cipherTxt)%blockSize</div><div class="line"></div><div class="line">	//得到补码</div><div class="line">	padTxt := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding)</div><div class="line"></div><div class="line">	//拼接原文与补码</div><div class="line">	var byteTxt = append(cipherTxt, padTxt...)</div><div class="line"></div><div class="line">	return byteTxt</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>去码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//PKCS5Unpadding 去码</div><div class="line">func PKCS5UnPadding(cipherTxt []byte) []byte &#123;</div><div class="line">	var l = len(cipherTxt)</div><div class="line">	var txt = int(cipherTxt[l-1])</div><div class="line">	res := cipherTxt[:l-txt]</div><div class="line">	return res</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DES加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// key 必须为8位</div><div class="line">func EnDESEncrypt (origData []byte, key []byte) []byte &#123;</div><div class="line"></div><div class="line">	//校验密钥</div><div class="line">	block, _ := des.NewCipher(key)</div><div class="line">	//设置补码</div><div class="line">	origData = MyDES.PKCS5Padding(origData, block.BlockSize())</div><div class="line">	//设置CBC加密模式</div><div class="line">	blockMode := cipher.NewCBCEncrypter(block, key)</div><div class="line"></div><div class="line">	//加密明文</div><div class="line">	crypted := make([]byte, len(origData))</div><div class="line"></div><div class="line">	blockMode.CryptBlocks(crypted, origData)</div><div class="line"></div><div class="line">	return crypted</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DES解密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func DeDESCriypt(cript []byte, key []byte) []byte  &#123;</div><div class="line">	//校验key的有效性</div><div class="line">	block,_:=des.NewCipher(key)</div><div class="line">	//通过CBC模式解密</div><div class="line">	blockMode:=cipher.NewCBCDecrypter(block,key)</div><div class="line"></div><div class="line">	//实现解密</div><div class="line">	origData:=make([]byte,len(cript))</div><div class="line">	blockMode.CryptBlocks(origData,cript)</div><div class="line"></div><div class="line">	//去码</div><div class="line">	origData = MyDES.PKCS5UnPadding(origData)</div><div class="line">	return origData</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func main()  &#123;</div><div class="line"></div><div class="line">	key := []byte(&quot;aswedrfg&quot;)</div><div class="line">	var data =[]byte(&quot;hello world&quot;)</div><div class="line">	var cipherTxt = EnDESEncrypt(data,key)</div><div class="line">	fmt.Println(&quot;加密的结果：&quot;,hex.EncodeToString( cipherTxt))</div><div class="line"></div><div class="line">	var origData=DeDESCriypt(cipherTxt,key)</div><div class="line">	fmt.Println(&quot;解密后的结果为:&quot;,string(origData))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">加密的结果： 935ae7ca3229f6c707bb9de9db9693c7</div><div class="line">解密后的结果为: hello world</div></pre></td></tr></table></figure></p>
<h2 id="根据DES原理自己实现加密解密过程"><a href="#根据DES原理自己实现加密解密过程" class="headerlink" title="根据DES原理自己实现加密解密过程"></a>根据DES原理自己实现加密解密过程</h2><p>加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func EnCrypt(key string, data []byte) []byte &#123;</div><div class="line"></div><div class="line">	var sum = 0</div><div class="line">	for i := 0; i &lt; len(key); i++ &#123;</div><div class="line">		sum += int(key[i])</div><div class="line">	&#125;</div><div class="line">	// 对明文进行补码</div><div class="line">	var pad = PKCS5Padding(data, len(key))</div><div class="line">	//通过加法，实现简单加密</div><div class="line">	for i := 0;i&lt;len(pad);i++&#123;</div><div class="line">		pad[i] = pad[i]+byte(sum)</div><div class="line">	&#125;</div><div class="line">	return pad</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func Decrypt(cipherTxt []byte,key string) []byte &#123;</div><div class="line"></div><div class="line">	fmt.Println(&quot;???&quot;,cipherTxt)</div><div class="line">	//计算key的总和</div><div class="line">	var sum =0</div><div class="line">	for i:=0;i&lt;len(key);i++ &#123;</div><div class="line">		sum += int(key[i])</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//减法运算</div><div class="line">	for i:=0;i&lt;len(cipherTxt);i++&#123;</div><div class="line">		cipherTxt[i]=cipherTxt[i]-byte(sum)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(&quot;???&quot;,cipherTxt)</div><div class="line">	//去码</div><div class="line">	var p = PKCS5UnPadding(cipherTxt)</div><div class="line">	return p</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><h3 id="3DES加密"><a href="#3DES加密" class="headerlink" title="3DES加密"></a>3DES加密</h3><p>DES是一个经典的对称加密算法，但也缺陷明显，即56位的密钥安全性不足，已被证实可以在短时间内破解。为解决此问题，出现了3DES，也称Triple DES，3DES为DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。为了兼容普通的DES，3DES并没有直接使用 <code>加密-&gt;加密-&gt;加密</code> 的方式，而是采用了<code>加密-&gt;解密-&gt;加密</code> 的方式。</p>
<p><img src="http://oscd4dgpc.bkt.clouddn.com/00f3fb2538ec90b80eb9.jpg" alt=""></p>
<p>当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。</p>
<p><img src="http://oscd4dgpc.bkt.clouddn.com/7de5d8dfcd0bd221596384.jpg" alt=""></p>
<h3 id="3DES解密"><a href="#3DES解密" class="headerlink" title="3DES解密"></a>3DES解密</h3><p>3DES解密过程，与加密过程相反，即逆序使用密钥。是以密钥3、密钥2、密钥1的顺序执行 <code>解密-&gt;加密-&gt;解密</code>。</p>
<p><img src="http://oscd4dgpc.bkt.clouddn.com/WX20180216-083713.png" alt=""></p>
<p>相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DES加密算法&quot;&gt;&lt;a href=&quot;#DES加密算法&quot; class=&quot;headerlink&quot; title=&quot;DES加密算法&quot;&gt;&lt;/a&gt;DES加密算法&lt;/h2&gt;&lt;p&gt;DES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。&lt;br&gt; &lt;br&gt;　　DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。&lt;br&gt;　　&lt;br&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="对称加密" scheme="http://gcblog/github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="DES" scheme="http://gcblog/github.io/tags/DES/"/>
    
      <category term="3DES" scheme="http://gcblog/github.io/tags/3DES/"/>
    
  </entry>
  
  <entry>
    <title>hash算法</title>
    <link href="http://gcblog/github.io/2018/06/26/hash%E7%AE%97%E6%B3%95/"/>
    <id>http://gcblog/github.io/2018/06/26/hash算法/</id>
    <published>2018-06-26T11:00:51.000Z</published>
    <updated>2018-06-26T11:04:32.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-hash-算法"><a href="#什么是-hash-算法" class="headerlink" title="什么是 hash 算法"></a>什么是 hash 算法</h2><p>散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。</p>
<p>散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p>
<h2 id="Hash算法有什么特点"><a href="#Hash算法有什么特点" class="headerlink" title="Hash算法有什么特点"></a>Hash算法有什么特点</h2><p>一个优秀的 hash 算法，将能实现：</p>
<ul>
<li><p><strong>正向快速</strong>：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。</p>
</li>
<li><p><strong>逆向困难</strong>：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。</p>
</li>
<li><p><strong>输入敏感</strong>：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。</p>
</li>
<li><p><strong>冲突避免</strong>：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</p>
</li>
</ul>
<p>但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。<br><a id="more"></a></p>
<h2 id="几种常见的hash算法"><a href="#几种常见的hash算法" class="headerlink" title="几种常见的hash算法"></a>几种常见的hash算法</h2><ul>
<li>MD5</li>
<li>SHA-1</li>
<li>SHA-2</li>
<li>SHA-256</li>
<li>SHA-512</li>
<li>SHA-3</li>
<li>RIPEMD-160</li>
</ul>
<h2 id="MD5-加密使用"><a href="#MD5-加密使用" class="headerlink" title="MD5 加密使用"></a>MD5 加密使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func Md5(data string)  &#123;</div><div class="line"></div><div class="line">	fmt.Println(&quot;-----------Md5-----------&quot;)</div><div class="line">	mes := []byte(data)</div><div class="line"></div><div class="line">	// 1. 使用系统的包实现</div><div class="line">	// 密文为16进制的数字 16 *8 = 128位</div><div class="line">	by := md5.Sum(mes)</div><div class="line">	fmt.Printf(&quot;%x\n&quot;, by)</div><div class="line"></div><div class="line">	// 2. 第二种写法</div><div class="line">	m := md5.New()</div><div class="line">	m.Write(mes)</div><div class="line">	//将字节数组转换成字符串</div><div class="line">	s2:= hex.EncodeToString(m.Sum(nil))</div><div class="line">	fmt.Println(s2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Sha256加密使用"><a href="#Sha256加密使用" class="headerlink" title="Sha256加密使用"></a>Sha256加密使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func Sha256(data string)  &#123;</div><div class="line"></div><div class="line">	fmt.Println(&quot;--------sha256----------&quot;)</div><div class="line"></div><div class="line">	// 32字节 通用在公链中 32 * 8 = 256 位</div><div class="line">	// 2. 第一种写法</div><div class="line">	by := sha256.Sum256([]byte(data))</div><div class="line">	s := fmt.Sprintf(&quot;%x&quot;, by)</div><div class="line">	fmt.Println(s)</div><div class="line"></div><div class="line">  // 2. 第二种写法</div><div class="line">	m := sha256.New()</div><div class="line">	m.Write([]byte(data))</div><div class="line">	s2 := hex.EncodeToString(m.Sum(nil))</div><div class="line">	fmt.Println(s2)</div><div class="line"></div><div class="line"></div><div class="line">	//对文件中的数据进行加密</div><div class="line">	file, _ := os.Open(&quot;test.txt&quot;)</div><div class="line">	h := sha256.New()</div><div class="line">	//将file copy到 h中</div><div class="line">	io.Copy(h, file)</div><div class="line">	resu := h.Sum(nil)</div><div class="line"></div><div class="line">	fmt.Println(hex.EncodeToString(resu))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="rpemd160加密使用"><a href="#rpemd160加密使用" class="headerlink" title="rpemd160加密使用"></a>rpemd160加密使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//需要用到三方库 crypto</div><div class="line">func Ripem160(data string)  &#123;</div><div class="line"></div><div class="line">	fmt.Println(&quot;-------Ripem160--------&quot;)</div><div class="line">	rip := ripemd160.New()</div><div class="line">	rip.Write([]byte(data))</div><div class="line">	res := hex.EncodeToString(rip.Sum(nil))</div><div class="line"></div><div class="line">	fmt.Println(res)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="md5-实现原理"><a href="#md5-实现原理" class="headerlink" title="md5 实现原理"></a>md5 实现原理</h2><p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<ol>
<li><p><strong>填充</strong>：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；</p>
</li>
<li><p><strong>记录信息长度</strong>：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。</p>
</li>
<li><p><strong>装入标准的幻数（四个整数）</strong>：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476）</p>
</li>
<li><p>四轮循环运算</p>
</li>
</ol>
<h2 id="sha256-实现原理"><a href="#sha256-实现原理" class="headerlink" title="sha256 实现原理"></a>sha256 实现原理</h2><p>SHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。</p>
<ul>
<li><p><strong>附加填充比特</strong>：对报文进行填充使报文长度与448 模512 同余（长度=448 mod 512），填充的比特数范围是1 到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个 1，再加很多个0，直到长度 满足 mod 512=448.为什么是448，因为448+64=512. 第二步会加上一个 64bit的 原始报文的 长度信息。</p>
</li>
<li><p><strong>附加长度值</strong> 将用64-bit 表示的初始报文（填充前）的位长度附加在步骤1 的结果后（低位字节优先）。</p>
</li>
<li><p><strong>初始化缓存</strong>：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。 </p>
</li>
<li><strong>处理512-bit（16 个字）报文分组序列</strong>：该算法使用了六种基本逻辑函数，由64步迭代运算组成。每步都以256-bit 缓存值ABCDEFGH 为输入，然后更新缓存内容。 每步使用一个32-bit 常数值Kt 和一个32-bit Wt。 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-hash-算法&quot;&gt;&lt;a href=&quot;#什么是-hash-算法&quot; class=&quot;headerlink&quot; title=&quot;什么是 hash 算法&quot;&gt;&lt;/a&gt;什么是 hash 算法&lt;/h2&gt;&lt;p&gt;散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。&lt;/p&gt;
&lt;p&gt;散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。&lt;/p&gt;
&lt;h2 id=&quot;Hash算法有什么特点&quot;&gt;&lt;a href=&quot;#Hash算法有什么特点&quot; class=&quot;headerlink&quot; title=&quot;Hash算法有什么特点&quot;&gt;&lt;/a&gt;Hash算法有什么特点&lt;/h2&gt;&lt;p&gt;一个优秀的 hash 算法，将能实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;正向快速&lt;/strong&gt;：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;逆向困难&lt;/strong&gt;：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;输入敏感&lt;/strong&gt;：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;冲突避免&lt;/strong&gt;：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。&lt;br&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
      <category term="加密算法" scheme="http://gcblog/github.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="hash" scheme="http://gcblog/github.io/tags/hash/"/>
    
      <category term="MD5" scheme="http://gcblog/github.io/tags/MD5/"/>
    
      <category term="sha256" scheme="http://gcblog/github.io/tags/sha256/"/>
    
      <category term="rpemd160" scheme="http://gcblog/github.io/tags/rpemd160/"/>
    
  </entry>
  
  <entry>
    <title>slice</title>
    <link href="http://gcblog/github.io/2018/05/04/slice/"/>
    <id>http://gcblog/github.io/2018/05/04/slice/</id>
    <published>2018-05-04T03:45:23.000Z</published>
    <updated>2018-05-04T03:47:16.408Z</updated>
    
    <content type="html"><![CDATA[<p>切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。</p>
<h3 id="slice声明和创建"><a href="#slice声明和创建" class="headerlink" title="slice声明和创建"></a>slice声明和创建</h3><p>slice 本身不是数组，它指向数组的底层<br>作为变长数组饿替代方案，可以关联底层数组的全部或者局部<br>可以直接创建，一般用make(), 也可以从底层数组获取生成<br>如果多个slice 指向相同的底层数组，一个值的改变会影响全部</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">func sliceCreate() &#123;</div><div class="line"></div><div class="line">	//声明 slice 如果只是声明，只有指针初始地址，容量为0</div><div class="line">	var slice1 []int</div><div class="line"></div><div class="line">	fmt.Printf(&quot;slice1  %p\n&quot;, slice1)</div><div class="line"></div><div class="line">	//添加元素后，容量超出上限，内存地址重新分配</div><div class="line">	slice1 = []int&#123;1, 2, 3&#125;</div><div class="line"></div><div class="line">	fmt.Printf(&quot;slice1  %p\n&quot;, slice1)</div><div class="line"></div><div class="line">	//声明并赋值</div><div class="line"></div><div class="line">	var s2 = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class="line">	fmt.Println(s2)</div><div class="line"></div><div class="line">	var arr = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</div><div class="line">	fmt.Print(&quot;s2  \n&quot;, arr)</div><div class="line"></div><div class="line">	// 取第二个元素</div><div class="line">	slice2 := arr[1]</div><div class="line">	fmt.Println(slice2)</div><div class="line"></div><div class="line">	//取第5到10个元素</div><div class="line">	slice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间</div><div class="line">	fmt.Println(slice3)</div><div class="line"></div><div class="line">	//从第5个元素取到最后  的两种写法</div><div class="line">	slice4 := arr[5:len(arr)]</div><div class="line">	slice5 := arr[5:]</div><div class="line">	fmt.Println(slice4, slice5)</div><div class="line"></div><div class="line">	//取前5个元素</div><div class="line">	slice6 := arr[:5]</div><div class="line">	fmt.Print(&quot;\n&quot;, slice6)</div><div class="line"></div><div class="line">	//使用make 创建slice</div><div class="line">	//存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍</div><div class="line">	// 如果不给初始容量，默认的初始容量就是当前元素个数</div><div class="line">	s1 := make([]int, 3, 10)</div><div class="line">	fmt.Print(&quot;\n&quot;, len(s1), cap(s1))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">slice1  0x0</div><div class="line">slice1  0xc4200182c0</div><div class="line">[a b c]</div><div class="line">s2  </div><div class="line">[0 1 2 3 4 5 6 7 8 9]1</div><div class="line">[5 6 7 8 9]</div><div class="line">[5 6 7 8 9] [5 6 7 8 9]</div><div class="line"></div><div class="line">[0 1 2 3 4]</div><div class="line">3 10</div></pre></td></tr></table></figure>
<h3 id="ReSlice"><a href="#ReSlice" class="headerlink" title="ReSlice"></a>ReSlice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func ResliceTest() &#123;</div><div class="line">	</div><div class="line">	// reslice索引 以 被slice 为准</div><div class="line">	// 索引不可以超过cap值</div><div class="line"></div><div class="line">	var a = []byte&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;&#125;</div><div class="line"></div><div class="line">	// 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间</div><div class="line">	//取出 cde</div><div class="line">	var s1 = a[2:5]</div><div class="line">	fmt.Println(string(s1))</div><div class="line">	fmt.Println(len(s1), cap(s1))</div><div class="line"></div><div class="line">	//从 s1中取出de</div><div class="line">	var s2 = s1[1:3]</div><div class="line">	fmt.Print(&quot;\n&quot;, string(s2))</div><div class="line"></div><div class="line">	// 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾</div><div class="line"></div><div class="line">	var s3 = s1[0:cap(s1)]</div><div class="line">	fmt.Print(&quot;\n s3 = &quot;, string(s3))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cde</div><div class="line">3 6</div><div class="line"></div><div class="line">de</div><div class="line"> s3 = cdefgh</div></pre></td></tr></table></figure>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>可以在slice尾部追加元素<br>可以将一个slice追加到另一个slice<br>slice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func appendTest() &#123;</div><div class="line"></div><div class="line">	s1 := make([]int, 3, 6)</div><div class="line">	fmt.Printf(&quot;%p\n&quot;, s1)</div><div class="line"></div><div class="line">	s1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变</div><div class="line">	fmt.Printf(&quot;%v---%p\n&quot;, s1, s1)</div><div class="line"></div><div class="line">	s1 = append(s1, 9) //超出容量，内存地址改变</div><div class="line">	fmt.Printf(&quot;%v %p\n&quot;, s1, s1)</div><div class="line"></div><div class="line">	var arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class="line">	var slice2 = arr[2:5] //3, 4, 5</div><div class="line">	var slice3 = arr[1:3] //2, 3</div><div class="line"></div><div class="line">	fmt.Println(slice2, slice3) //重叠部分是3</div><div class="line"></div><div class="line">	slice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变</div><div class="line">	fmt.Println(arr, slice2, slice3)</div><div class="line"></div><div class="line">	slice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变</div><div class="line">	fmt.Println(slice3)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0xc42001c0c0</div><div class="line">[0 0 0 1 2 3]---0xc42001c0c0</div><div class="line">[0 0 0 1 2 3 9] 0xc420078060</div><div class="line">[3 4 5] [2 3]</div><div class="line">[1 2 9 4 5] [9 4 5] [2 9]</div><div class="line">[2 9 1 2 2 2 2 2]</div></pre></td></tr></table></figure>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func copyTest() &#123;</div><div class="line"></div><div class="line">	//copy 会把重叠部分的元素给覆盖</div><div class="line">	var s1 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class="line">	var s2 = []int&#123;7, 8, 9&#125;</div><div class="line">	// 短的copy到长的情况</div><div class="line">	copy(s1, s2) //把s2 copy 到s1 中</div><div class="line">	fmt.Println(&quot;s1---&quot;, s1)</div><div class="line"></div><div class="line">	// 长的copy到短的情况</div><div class="line">	var s3 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class="line">	var s4 = []int&#123;7, 8, 9&#125;</div><div class="line">	copy(s4, s3)</div><div class="line">	fmt.Println(&quot;s4---&quot;, s4)</div><div class="line"></div><div class="line">	var s5 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class="line">	var s6 = []int&#123;7, 8, 9&#125;</div><div class="line">	//将制定元素copy到指定位置</div><div class="line">	copy(s5[2:4], s6[1:3])</div><div class="line">	fmt.Println(&quot;s5---&quot;, s5)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s1--- [7 8 9 4 5 6 7]</div><div class="line">s4--- [1 2 3]</div><div class="line">s5--- [1 2 8 9 5 6 7]</div></pre></td></tr></table></figure>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>go官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func sliceDelete() &#123;</div><div class="line"></div><div class="line">	var slice = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;</div><div class="line"></div><div class="line">	fmt.Println(removeString(slice, 2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//删除函数</div><div class="line">func removeString(s []string, i int) []string &#123;</div><div class="line"></div><div class="line">	return append(s[:i], s[i+1:]...)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[a b d]</div></pre></td></tr></table></figure>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>官方还是没有提供插入的方法，需要自己实现，如果用<code>append</code>实现，<code>append</code>每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现<br>这里需要引入<code>reflect</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func silceInsert() &#123;</div><div class="line"></div><div class="line">	a := []int&#123;1, 2, 3, 4, 5&#125;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(&quot;插入元素后&quot;, Insert(a, 3, 0))</div><div class="line"></div><div class="line">	b := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(&quot;插入元素后&quot;, Insert(b, 3, &quot;x&quot;))</div><div class="line"></div><div class="line">	c := []interface&#123;&#125;&#123;1, &quot;a&quot;, true, 3.2, &apos;a&apos;&#125;</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(&quot;插入元素后&quot;, Insert(c, 3, false))</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func Insert(slice interface&#123;&#125;, pos int, value interface&#123;&#125;) interface&#123;&#125; &#123;</div><div class="line">	v := reflect.ValueOf(slice)</div><div class="line">	v = reflect.Append(v, reflect.ValueOf(value))</div><div class="line">	reflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len()))</div><div class="line">	v.Index(pos).Set(reflect.ValueOf(value))</div><div class="line">	return v.Interface()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1 2 3 4 5]</div><div class="line">插入元素后 [1 2 3 0 4 5]</div><div class="line">[a b c d e]</div><div class="line">插入元素后 [a b c x d e]</div><div class="line">[1 a true 3.2 97]</div><div class="line">插入元素后 [1 a true false 3.2 97]</div></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入<code>sort</code></p>
<h4 id="升序排序"><a href="#升序排序" class="headerlink" title="升序排序"></a>升序排序</h4><p>对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func sliceSort() &#123;</div><div class="line"></div><div class="line">	intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class="line">	float8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class="line">	stringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class="line"></div><div class="line">	sort.Ints(intList)</div><div class="line">	sort.Float64s(float8List)</div><div class="line">	sort.Strings(stringList)</div><div class="line"></div><div class="line">	fmt.Printf(&quot;%v\n%v\n%v\n&quot;, intList, float8List, stringList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[0 1 2 3 4 5 6 7 8 9]</div><div class="line">[3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9]</div><div class="line">[a b c d f i w x y z]</div></pre></td></tr></table></figure>
<h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p>int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。</p>
<p>go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func sliceSort2() &#123;</div><div class="line">	intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class="line">	float8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class="line">	stringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class="line"></div><div class="line">	sort.Sort(sort.Reverse(sort.IntSlice(intList)))</div><div class="line">	sort.Sort(sort.Reverse(sort.Float64Slice(float8List)))</div><div class="line">	sort.Sort(sort.Reverse(sort.StringSlice(stringList)))</div><div class="line"></div><div class="line">	fmt.Printf(&quot;%v\n%v\n%v\n&quot;, intList, float8List, stringList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[9 8 7 6 5 4 3 2 1 0]</div><div class="line">[99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14]</div><div class="line">[z y x w i f d c b a]</div></pre></td></tr></table></figure>
<h4 id="结构体类型的排序"><a href="#结构体类型的排序" class="headerlink" title="结构体类型的排序"></a>结构体类型的排序</h4><p>结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。</p>
<h5 id="1、模拟-IntSlice-排序"><a href="#1、模拟-IntSlice-排序" class="headerlink" title="1、模拟 IntSlice 排序"></a>1、模拟 IntSlice 排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name string</div><div class="line">    Age  int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 按照 Person.Age 从大到小排序</div><div class="line">type PersonSlice [] Person</div><div class="line"> </div><div class="line">func (a PersonSlice) Len() int &#123;    	 // 重写 Len() 方法</div><div class="line">    return len(a)</div><div class="line">&#125;</div><div class="line">func (a PersonSlice) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class="line">    a[i], a[j] = a[j], a[i]</div><div class="line">&#125;</div><div class="line">func (a PersonSlice) Less(i, j int) bool &#123;    // 重写 Less() 方法， 从大到小排序</div><div class="line">    return a[j].Age &lt; a[i].Age</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    people := [] Person&#123;</div><div class="line">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class="line">        &#123;&quot;li si&quot;, 30&#125;,</div><div class="line">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class="line">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(PersonSlice(people))    // 按照 Age 的逆序排序</div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(sort.Reverse(PersonSlice(people)))    // 按照 Age 的升序排序</div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。<br>这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。</p>
<h5 id="2、封装成-Wrapper"><a href="#2、封装成-Wrapper" class="headerlink" title="2、封装成 Wrapper"></a>2、封装成 Wrapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name string</div><div class="line">    Age  int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type PersonWrapper struct &#123;					//注意此处</div><div class="line">    people [] Person</div><div class="line">    by func(p, q * Person) bool</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func (pw PersonWrapper) Len() int &#123;    		// 重写 Len() 方法</div><div class="line">    return len(pw.people)</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class="line">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class="line">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    people := [] Person&#123;</div><div class="line">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class="line">        &#123;&quot;li si&quot;, 30&#125;,</div><div class="line">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class="line">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class="line">        return q.Age &lt; p.Age    // Age 递减排序</div><div class="line">    &#125;&#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class="line">        return p.Name &lt; q.Name    // Name 递增排序</div><div class="line">    &#125;&#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。</p>
<h5 id="3、进一步封装"><a href="#3、进一步封装" class="headerlink" title="3、进一步封装"></a>3、进一步封装</h5><p>感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name string</div><div class="line">    Age  int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type PersonWrapper struct &#123;</div><div class="line">    people [] Person</div><div class="line">    by func(p, q * Person) bool</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type SortBy func(p, q *Person) bool</div><div class="line"> </div><div class="line">func (pw PersonWrapper) Len() int &#123;    		// 重写 Len() 方法</div><div class="line">    return len(pw.people)</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Swap(i, j int)&#123;         // 重写 Swap() 方法</div><div class="line">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class="line">&#125;</div><div class="line">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class="line">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 封装成 SortPerson 方法</div><div class="line">func SortPerson(people [] Person, by SortBy)&#123;</div><div class="line">    sort.Sort(PersonWrapper&#123;people, by&#125;)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    people := [] Person&#123;</div><div class="line">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class="line">        &#123;&quot;li si&quot;, 30&#125;,</div><div class="line">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class="line">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class="line">        return q.Age &lt; p.Age    // Age 递减排序</div><div class="line">    &#125;&#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">    SortPerson(people, func (p, q *Person) bool &#123;</div><div class="line">        return p.Name &lt; q.Name    // Name 递增排序</div><div class="line">    &#125;)</div><div class="line"> </div><div class="line">    fmt.Println(people)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。</p>
<h5 id="4、另一种思路"><a href="#4、另一种思路" class="headerlink" title="4、另一种思路"></a>4、另一种思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sort&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">type Person struct &#123;</div><div class="line">    Name        string</div><div class="line">    Weight      int</div><div class="line">&#125;</div><div class="line"> </div><div class="line">type PersonSlice []Person</div><div class="line"> </div><div class="line">func (s PersonSlice) Len() int  &#123; return len(s) &#125;</div><div class="line">func (s PersonSlice) Swap(i, j int)     &#123; s[i], s[j] = s[j], s[i] &#125;</div><div class="line"> </div><div class="line">type ByName struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByName 中</div><div class="line"> </div><div class="line">func (s ByName) Less(i, j int) bool     &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125;    // 将 Less 绑定到 ByName 上</div><div class="line"> </div><div class="line"> </div><div class="line">type ByWeight struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByWeight 中</div><div class="line">func (s ByWeight) Less(i, j int) bool   &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125;    // 将 Less 绑定到 ByWeight 上</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    s := []Person&#123;</div><div class="line">        &#123;&quot;apple&quot;, 12&#125;,</div><div class="line">        &#123;&quot;pear&quot;, 20&#125;,</div><div class="line">        &#123;&quot;banana&quot;, 50&#125;,</div><div class="line">        &#123;&quot;orange&quot;, 87&#125;,</div><div class="line">        &#123;&quot;hello&quot;, 34&#125;,</div><div class="line">        &#123;&quot;world&quot;, 43&#125;,</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    sort.Sort(ByWeight&#123;s&#125;)</div><div class="line">    fmt.Println(&quot;People by weight:&quot;)</div><div class="line">    printPeople(s)</div><div class="line"> </div><div class="line">    sort.Sort(ByName&#123;s&#125;)</div><div class="line">    fmt.Println(&quot;\nPeople by name:&quot;)</div><div class="line">    printPeople(s)</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">func printPeople(s []Person) &#123;</div><div class="line">    for _, o := range s &#123;</div><div class="line">        fmt.Printf(&quot;%-8s (%v)\n&quot;, o.Name, o.Weight)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。</p>
<h3 id="取最值"><a href="#取最值" class="headerlink" title="取最值"></a>取最值</h3><p>这个取最大值和最小值也是需要自己实现, 引入包<code>math</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func sliceMinMax() &#123;</div><div class="line">	intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class="line"></div><div class="line">	fmt.Println(intList)</div><div class="line">	//取最大值</div><div class="line">	fmt.Println(&quot;maxValue = &quot;, getMaxValue(intList))</div><div class="line"></div><div class="line">	//取最小值</div><div class="line">	fmt.Println(&quot;minValue = &quot;, getMinValue(intList))</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func getMaxValue(slice []int) int &#123;</div><div class="line">	var maxValue float64 = float64(slice[0])</div><div class="line">	for _, v := range slice &#123;</div><div class="line">		maxValue = math.Max(float64(maxValue), float64(v))</div><div class="line">	&#125;</div><div class="line">	return int(maxValue)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func getMinValue(slice []int) int &#123;</div><div class="line">	var maxValue float64 = float64(slice[0])</div><div class="line">	for _, v := range slice &#123;</div><div class="line">		maxValue = math.Min(float64(maxValue), float64(v))</div><div class="line">	&#125;</div><div class="line">	return int(maxValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2 4 3 5 7 6 9 8 1 0]</div><div class="line">maxValue =  9</div><div class="line">minValue =  0</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。&lt;/p&gt;
&lt;h3 id=&quot;slice声明和创建&quot;&gt;&lt;a href=&quot;#slice声明和创建&quot; class=&quot;headerlink&quot; title=&quot;slice声明和创建&quot;&gt;&lt;/a&gt;slice声明和创建&lt;/h3&gt;&lt;p&gt;slice 本身不是数组，它指向数组的底层&lt;br&gt;作为变长数组饿替代方案，可以关联底层数组的全部或者局部&lt;br&gt;可以直接创建，一般用make(), 也可以从底层数组获取生成&lt;br&gt;如果多个slice 指向相同的底层数组，一个值的改变会影响全部&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
      <category term="slice" scheme="http://gcblog/github.io/tags/slice/"/>
    
      <category term="排序" scheme="http://gcblog/github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串操作</title>
    <link href="http://gcblog/github.io/2018/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    <id>http://gcblog/github.io/2018/04/26/字符串操作/</id>
    <published>2018-04-26T03:30:20.000Z</published>
    <updated>2018-04-27T08:06:16.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>本文列举关于字符串最常用的几个操作，都会举例说明</p>
<ul>
<li><a href="#0">字符串长度</a></li>
<li><a href="#1">查找</a></li>
<li><a href="#2">替换</a></li>
<li><a href="#3">分割</a></li>
<li><a href="#4">合并</a></li>
<li><a href="#5">前缀或后缀</a></li>
<li><a href="#6">截取</a></li>
<li><a href="#7">删除</a></li>
<li><a href="#8">插入</a></li>
<li><a href="#9">编码转换</a></li>
<li><a href="#10">转换数值类型</a></li>
<li><a href="#11">大小写转换</a></li>
<li><a href="#12">Trim操作</a></li>
<li><a href="#13">ASCII 转换</a></li>
<li><a href="#14">字符串重复几次</a></li>
<li><a href="#15">字符或子串在字符串中首次出现的位置或最后一次出现的位置</a></li>
</ul>
<p>字符串相关操作需要导入包<code>strings</code></p>
<a id="more"></a>
<h3 id="0">字符串长度</h3>    

<ul>
<li><code>len()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func strLength() &#123;</div><div class="line">	var str = &quot;abc&quot;</div><div class="line">	var length = len(str)</div><div class="line">	fmt.Println(length)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1">查找</h3>    

<ul>
<li><code>func Contains(s, substr string) bool</code> 子串substr在s中，返回true</li>
<li><code>func ContainsAny(s, chars string) bool</code>  chars中任何一个字符在s中，返回true</li>
<li><code>func ContainsRune(s string, r rune) bool</code>  Unicode代码点r在s中，返回true</li>
<li><code>func Count(s, sep string) int</code> sep 在s中重复出现的次数(不计算重叠)</li>
<li><code>func Index(s, sep string)</code> int 在字符串s中查找sep所在的位置, 找不到返回-1</li>
</ul>
<blockquote>
<p>在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。<br>另外，Count 是计算子串在字符串中出现的无重叠的次数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">func existSubStringOrChar() &#123;</div><div class="line"></div><div class="line">	var super = &quot;abcdef!&quot;</div><div class="line">	var suba = &quot;abc&quot;</div><div class="line">	var subb = &quot;ef!&quot;</div><div class="line"></div><div class="line">	var hasa = existSubString(super, suba)</div><div class="line">	var hasb = existSubChar(super, subb)</div><div class="line"></div><div class="line">	fmt.Println(hasa, hasb)</div><div class="line"></div><div class="line">	var s = &quot;fivevev&quot;</div><div class="line">	var sep1 = &quot;vev&quot;</div><div class="line">	var sep2 = &quot;adfd&quot;</div><div class="line"></div><div class="line">	var c1 = repeatCount(s, sep1)</div><div class="line">	var c2 = repeatCount(s, sep2)</div><div class="line">	fmt.Println(c1, c2)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 是否存在某个字符或子串</div><div class="line">func existSubString(superString string, substring string) bool &#123;</div><div class="line">	return strings.Contains(superString, substring)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//substring 是否含有superString 的任意一个字符</div><div class="line">func existSubChar(superString string, substring string) bool &#123;</div><div class="line">	return strings.ContainsAny(superString, substring)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//substring 的重复出现次数</div><div class="line">func repeatCount(superString string, substring string) int &#123;</div><div class="line">	return strings.Count(superString, substring)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true true</div><div class="line">1 0</div></pre></td></tr></table></figure>
<h3 id="2">替换</h3>    

<ul>
<li><code>strings.Replace(s, old, new, n)</code></li>
</ul>
<p><code>s</code>需要替换的字符串   <code>old</code>需要被替换掉的某个子串    <code>new</code>替换的值<br><code>n</code>  <code>n&lt;0</code>全部替换  <code>n==0</code>不替换 <code>n&gt;0</code>全部替换 如果<code>n</code>的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func strReplace() &#123;</div><div class="line"></div><div class="line">	var str = &quot;cabcdefgabc&quot;</div><div class="line">	var value = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, -1)</div><div class="line">	var value1 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 0)</div><div class="line">	var value2 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 1)</div><div class="line">	var value3 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 3)</div><div class="line"></div><div class="line">	fmt.Println(value, value1, value2, value3)</div><div class="line">	strings.Replace(s, old, new, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc</div></pre></td></tr></table></figure></p>
<h3 id="3">分割</h3>

<h4 id="Fields-和-FieldsFunc"><a href="#Fields-和-FieldsFunc" class="headerlink" title="Fields 和 FieldsFunc"></a>Fields 和 FieldsFunc</h4><ul>
<li>Fields 按空格切割</li>
<li>FieldsFunc 按照自己指定的方式切割</li>
</ul>
<p>实际上，Fields 函数就是调用 FieldsFunc 实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func Fields(s string) []string &#123;</div><div class="line">    return FieldsFunc(s, unicode.IsSpace)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func strCut() &#123;</div><div class="line"></div><div class="line">	var str = &quot;abc bde efg&quot;</div><div class="line"></div><div class="line">	var cut1 = strings.Fields(str)</div><div class="line"></div><div class="line">	var cut2 = strings.FieldsFunc(str, unicode.IsSpace)</div><div class="line"></div><div class="line">	fmt.Println(cut1, cut2)</div><div class="line"></div><div class="line">	s := &quot;ab*cd*ef&quot;</div><div class="line">	result := strings.FieldsFunc(s, func(c rune) bool &#123;</div><div class="line">		if c == &apos;h&apos; &#123;</div><div class="line">			return true</div><div class="line">		&#125;</div><div class="line">		return false</div><div class="line">	&#125;)</div><div class="line">	fmt.Println(result)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[abc bde efg] [abc bde efg]</div><div class="line">[ab*cd*ef]</div></pre></td></tr></table></figure></p>
<h4 id="Split-和-SplitAfter、-SplitN-和-SplitAfterN"><a href="#Split-和-SplitAfter、-SplitN-和-SplitAfterN" class="headerlink" title="Split 和 SplitAfter、 SplitN 和 SplitAfterN"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;</div><div class="line">func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;</div><div class="line">func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;</div><div class="line">func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep,len(sep), n)&#125;</div></pre></td></tr></table></figure>
<p>它们都调用了 genSplit 函数。<br>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(“abc”,””)，得到的是[a b c]。</p>
<h5 id="功能区分：after-会保留分隔符"><a href="#功能区分：after-会保留分隔符" class="headerlink" title="功能区分：after 会保留分隔符"></a>功能区分：after 会保留分隔符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</div><div class="line">[&quot;foo,&quot; &quot;bar,&quot; &quot;baz&quot;]</div></pre></td></tr></table></figure></p>
<h5 id="N的区别"><a href="#N的区别" class="headerlink" title="N的区别"></a>N的区别</h5><p><code>N</code> 用来控制分割的个数<br>当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割</p>
<p><code>fmt.Printf(&quot;%q\n&quot;, strings.SplitN(&quot;foo,bar,baz&quot;, &quot;,&quot;, 2))</code><br>输出：<br><code>[&quot;foo&quot; &quot;bar,baz&quot;]</code></p>
<p>另外看一下官方文档提供的例子，注意一下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))</div><div class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;))</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</div><div class="line">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</div><div class="line">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</div><div class="line">[&quot;&quot;]</div></pre></td></tr></table></figure></p>
<h5 id="split总结"><a href="#split总结" class="headerlink" title="split总结"></a>split总结</h5><p>关于字符串的分割，最常用的就是<code>Split</code>，其他几乎用不到</p>
<h3 id="4">合并</h3>

<p>将字符串数组（或slice）连接起来可以通过 Join 实现</p>
<ul>
<li><code>func Join(a []string, sep string) string</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func strJoin() &#123;</div><div class="line">	var arr = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class="line">	fmt.Println(arr)</div><div class="line">	// 用 ‘-’ 拼接</div><div class="line">	fmt.Println(strings.Join(arr, &quot;-&quot;))</div><div class="line">	// 直接拼接</div><div class="line">	fmt.Println(strings.Join(arr, &quot;&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[a b c]</div><div class="line">a-b-c</div><div class="line">abc</div></pre></td></tr></table></figure></p>
<h3 id="5">前缀或后缀</h3>    

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func presuf() &#123;</div><div class="line"></div><div class="line">	var str = &quot;abcdefg&quot;</div><div class="line">	//判断开始</div><div class="line">	var preA = strings.HasPrefix(str, &quot;a&quot;)</div><div class="line"></div><div class="line">	//判断结尾</div><div class="line">	var preG = strings.HasSuffix(str, &quot;g&quot;)</div><div class="line"></div><div class="line">	fmt.Println(preA, preG)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><code>true true</code></p>
<h3 id="6">截取</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func subString() &#123;</div><div class="line">	//strings 没有 截取字符串的方法</div><div class="line">	var str = &quot;abc中国defgh&quot;</div><div class="line">	// 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等</div><div class="line">	var strArr = string([]rune(str)[:4])</div><div class="line"></div><div class="line">	fmt.Println(strArr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abc中</div></pre></td></tr></table></figure></p>
<h3 id="7">删除</h3>

<p>strings 包中没有提供删除的方法，只能自己实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func deleteStrWithRange(s string, start int, end int) string &#123;</div><div class="line">if len(s) == 0 || end &gt; len(s) &#123;</div><div class="line">	return &quot;&quot;</div><div class="line">&#125;</div><div class="line">var str1 = string([]rune(s)[:start])</div><div class="line">var str2 = string([]rune(s)[end:])</div><div class="line">return str1 + str2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var sss = deleteStrWithRange(&quot;012345678&quot;, 1, 3)</div><div class="line">fmt.Println(sss)</div></pre></td></tr></table></figure>
<p>输出：<br><code>0345678</code></p>
<h3 id="8">插入</h3>

<p>go strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string</p>
<h3 id="9">编码转换</h3>

<p>字符串转换需要用到 <code>strconv</code></p>
<ul>
<li>Append 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte</li>
<li>Format 函数将给定的类型变量转换为string返回</li>
<li>Parse 函数将字符串转换为其他类型</li>
</ul>
<h4 id="unicode-与-中文-互转"><a href="#unicode-与-中文-互转" class="headerlink" title="unicode  与 中文 互转"></a>unicode  与 中文 互转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func chinaeseToUnicode() &#123;</div><div class="line">	sText := &quot;中文&quot;</div><div class="line">	textQuoted := strconv.QuoteToASCII(sText)</div><div class="line">	fmt.Println(textQuoted)</div><div class="line"></div><div class="line">	textUnquoted := textQuoted[1 : len(textQuoted)-1]</div><div class="line">	fmt.Println(textUnquoted)</div><div class="line"></div><div class="line">	sUnicodev := strings.Split(textUnquoted, &quot;\\u&quot;)</div><div class="line">	var context string</div><div class="line">	for _, v := range sUnicodev &#123;</div><div class="line">		if len(v) &lt; 1 &#123;</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		temp, err := strconv.ParseInt(v, 16, 32)</div><div class="line">		if err != nil &#123;</div><div class="line">			panic(err)</div><div class="line">		&#125;</div><div class="line">		context += fmt.Sprintf(&quot;%c&quot;, temp)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;\u4e2d\u6587&quot;</div><div class="line">\u4e2d\u6587</div><div class="line">中文</div></pre></td></tr></table></figure></p>
<h4 id="转码与解码"><a href="#转码与解码" class="headerlink" title="转码与解码"></a>转码与解码</h4><p>需要导入包 <code>net/url</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func encodeAndDecode() &#123;</div><div class="line">	var str = &quot;https://www.baidu.com/生活&quot;</div><div class="line"></div><div class="line">	//转码</div><div class="line">	var encode = url.QueryEscape(str)</div><div class="line"></div><div class="line">	fmt.Println(encode)</div><div class="line"></div><div class="line">	//解码</div><div class="line">	decodeurl, err := url.QueryUnescape(encode)</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(decodeurl)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BB</div><div class="line">https://www.baidu.com/生活</div></pre></td></tr></table></figure></p>
<h3 id="10">转换数值类型</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func strToValue() &#123;</div><div class="line"></div><div class="line">	// int 转 string</div><div class="line">	var intA int = 123</div><div class="line">	var stringA string = strconv.Itoa(intA)</div><div class="line">	fmt.Println(stringA, reflect.TypeOf(stringA))</div><div class="line"></div><div class="line">	// string 转 int</div><div class="line"></div><div class="line">	var stringB = &quot;45678&quot;</div><div class="line">	intB, err := strconv.Atoi(stringB)</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(intB, reflect.TypeOf(intB))</div><div class="line"></div><div class="line">	// string to float</div><div class="line">	var stringc = &quot;123.45678&quot;</div><div class="line">	floatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64,</div><div class="line">	if err != nil &#123;</div><div class="line">		panic(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(floatC, reflect.TypeOf(floatC))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">123 string</div><div class="line">45678 int</div><div class="line">123.45678 float64</div></pre></td></tr></table></figure></p>
<h3 id="11">大小写转换</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)</div><div class="line">func Title(s string) string</div><div class="line"></div><div class="line">// 所有字母转换为小写</div><div class="line">func ToLower(s string) string</div><div class="line"></div><div class="line">// 所有字母转换为大写</div><div class="line">func ToUpper(s string) string</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fmt.Println(strings.Title(&quot;her royal highness&quot;))  // Her Royal Highness</div><div class="line"></div><div class="line">fmt.Println(strings.ToLower(&quot;Gopher123&quot;))  // gopher123</div><div class="line"></div><div class="line">fmt.Println(strings.ToUpper(&quot;Gopher&quot;))  // GOPHER</div></pre></td></tr></table></figure>
<h3 id="12">Trim操作</h3>

<p>bytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。</p>
<p>在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。</p>
<ul>
<li><code>func Trim(s string, cutset string) string</code> 去除两边自定义字符</li>
<li><code>func TrimFunc(s string, f func(rune) bool) string</code> 自定义清除</li>
<li><code>func TrimLeft(s string, cutset string) string</code> 清除左边</li>
<li><code>func TrimPrefix(s, prefix string) string</code> 删除前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func strtrim() &#123;</div><div class="line">	var str = &quot;  ads!/  ;&apos;  jha   asdfhj   &quot;</div><div class="line"></div><div class="line">	// 去除首尾空格，一般这个最常用</div><div class="line">	var value1 = strings.Trim(str, &quot; &quot;)</div><div class="line">	fmt.Println(value1)</div><div class="line"></div><div class="line">	//自定义trim</div><div class="line">	fmt.Println(strings.TrimFunc(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, func(r rune) bool &#123;</div><div class="line">		if r == &apos;&amp;&apos; &#123;</div><div class="line">			return true</div><div class="line">		&#125;</div><div class="line">		return false</div><div class="line">	&#125;))</div><div class="line"></div><div class="line">	//trim 左侧 &amp; 右侧</div><div class="line">	fmt.Println(strings.TrimLeft(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class="line">	fmt.Println(strings.TrimRight(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class="line"></div><div class="line">	//去除前缀，后缀也一样</div><div class="line">	var str2 = &quot;xxx_abcd&quot;</div><div class="line">	if strings.HasPrefix(str2, &quot;xxx_&quot;) &#123;</div><div class="line">		fmt.Println(strings.TrimPrefix(str2, &quot;xxx_&quot;))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ads!/  ;&apos;  jha   asdfhj</div><div class="line">nihao</div><div class="line">nihao&amp;&amp;&amp;&amp;</div><div class="line">&amp;&amp;&amp;&amp;nihao</div><div class="line">abcd</div></pre></td></tr></table></figure>
<h3 id="13">ASCII 转换</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func strASCII() &#123;</div><div class="line"></div><div class="line">	//字符转ASCII</div><div class="line">	var c rune = &apos;a&apos;</div><div class="line">	var i1 = int(c)</div><div class="line">	fmt.Println(&quot;&apos;a&apos; convert to ASCII&quot;, i1)</div><div class="line"></div><div class="line">	//ASCII 转字符</div><div class="line">	var i int = 98</div><div class="line">	var c1 = rune(i)</div><div class="line">	fmt.Println(&quot;98 convert to string&quot;, string(c1))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;a&apos; convert to ASCII 97</div><div class="line">98 convert to string b</div></pre></td></tr></table></figure>
<h3 id="14">字符串重复几次</h3>

<ul>
<li><code>func Repeat(s string, count int) string</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func strRepeatCount() &#123;</div><div class="line">	fmt.Println(strings.Repeat(&quot;a&quot;, 2))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<p><code>aa</code></p>
<h3 id="15">字符或子串在字符串中首次出现的位置或最后一次出现的位置</h3>

<h4 id="4个查找第一次出现的位置"><a href="#4个查找第一次出现的位置" class="headerlink" title="4个查找第一次出现的位置"></a>4个查找第一次出现的位置</h4><p>// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引<br><code>func Index(s, sep string) int</code><br>// chars中任何一个Unicode代码点在s中首次出现的位置<br><code>func IndexAny(s, chars string) int</code><br>// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true<br><code>func IndexFunc(s string, f func(rune) bool) int</code><br>// Unicode 代码点 r 在 s 中第一次出现的位置<br><code>func IndexRune(s string, r rune) int</code></p>
<p>一般用<code>indexAny</code></p>
<h4 id="3个查找最后一次出现的位置"><a href="#3个查找最后一次出现的位置" class="headerlink" title="3个查找最后一次出现的位置"></a>3个查找最后一次出现的位置</h4><p><code>func LastIndex(s, sep string) int</code><br><code>func LastIndexAny(s, chars string) int</code><br><code>func LastIndexFunc(s string, f func(rune) bool) int</code></p>
<p>一般用<code>LastIndexAny</code>就行</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;本文列举关于字符串最常用的几个操作，都会举例说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0&quot;&gt;字符串长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;替换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;前缀或后缀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6&quot;&gt;截取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7&quot;&gt;删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8&quot;&gt;插入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9&quot;&gt;编码转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10&quot;&gt;转换数值类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11&quot;&gt;大小写转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12&quot;&gt;Trim操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#13&quot;&gt;ASCII 转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#14&quot;&gt;字符串重复几次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#15&quot;&gt;字符或子串在字符串中首次出现的位置或最后一次出现的位置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串相关操作需要导入包&lt;code&gt;strings&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
      <category term="strings" scheme="http://gcblog/github.io/tags/strings/"/>
    
      <category term="字符串操作" scheme="http://gcblog/github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>go数组</title>
    <link href="http://gcblog/github.io/2018/04/18/go%E6%95%B0%E7%BB%84/"/>
    <id>http://gcblog/github.io/2018/04/18/go数组/</id>
    <published>2018-04-18T06:59:13.000Z</published>
    <updated>2018-04-18T07:01:46.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。</li>
<li>定义数组的格式：var <varname> [n]<type>，n&gt;=0</type></varname></li>
<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型</li>
<li>注意区分指向数组的指针和指针数组</li>
<li>数组在Go中为值类型</li>
<li>数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt;(比较的前提是数组个数相同，并且元素类型相同)</li>
<li>可以使用new来创建数组，此方法返回一个指向数组的指针</li>
<li>Go支持多维数组</li>
</ul>
<a id="more"></a>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func createArr() &#123;</div><div class="line"></div><div class="line">	// 指定数组长度</div><div class="line">	// 创建数组如果给定数组长度，数组个数就不能超过这个长度</div><div class="line">	var arr1 = [5]int&#123;1, 3, 5, 2, 9&#125;</div><div class="line">	fmt.Println(arr1)</div><div class="line"></div><div class="line">	//不指定数组长度</div><div class="line">	//Go 语言会根据元素的个数来设置数组的大小</div><div class="line">	var arr2 = []int&#123;1, 2&#125;</div><div class="line">	var arr3 = [...]int&#123;2, 3, 4&#125;</div><div class="line">	fmt.Println(arr2)</div><div class="line">	fmt.Println(arr3)</div><div class="line"></div><div class="line">	//创建变量或者常量 可以简写</div><div class="line">	arr4 := []int&#123;5&#125;</div><div class="line">	fmt.Println(arr4)</div><div class="line">	//初始化对指定元素赋值</div><div class="line">	//第三个元素 初始化为1</div><div class="line">	var arr5 = [5]int&#123;3: 1&#125;</div><div class="line">	fmt.Println(arr5)</div><div class="line"></div><div class="line">	// 获取数组的长度和容量</div><div class="line">	fmt.Println(len(arr1))</div><div class="line">	fmt.Println(cap(arr1))</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[1 3 5 2 9]</div><div class="line">[1 2]</div><div class="line">[2 3 4]</div><div class="line">[5]</div><div class="line">[0 0 0 1 0]</div><div class="line">5</div><div class="line">5</div></pre></td></tr></table></figure></p>
<h4 id="编辑数组"><a href="#编辑数组" class="headerlink" title="编辑数组"></a>编辑数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func editArr() &#123;</div><div class="line"></div><div class="line">	var arr1 = []int&#123;1, 2&#125;</div><div class="line">	fmt.Print(len(arr1), cap(arr1))</div><div class="line">	fmt.Println(arr1)</div><div class="line"></div><div class="line">	// 给arr1 添加元素 3，4</div><div class="line">	var arr2 = append(arr1, 3, 4)</div><div class="line">	fmt.Println(&quot;arr1 = &quot;, arr1)</div><div class="line">	fmt.Println(&quot;arr2 = &quot;, arr2)</div><div class="line">	fmt.Print(len(arr1), cap(arr1))</div><div class="line"></div><div class="line">	//改变数组中元素的值</div><div class="line">	arr1[0] = 9</div><div class="line">	fmt.Println(arr1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2 2[1 2]</div><div class="line">[1 2 3 4]</div><div class="line">4 4[9 2 3 4]</div></pre></td></tr></table></figure></p>
<h4 id="指针-amp-数组"><a href="#指针-amp-数组" class="headerlink" title="指针&amp;数组"></a>指针&amp;数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func pointArr() &#123;</div><div class="line">	//数组指针   它是一个指针，指向数组的地址</div><div class="line">	a := []int&#123;5: 1&#125;</div><div class="line">	var p *[]int = &amp;a</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(p) //比a 多了一个取地址符</div><div class="line"></div><div class="line">	// 指针数组 数组里存放的是指针地址，不是实际的值</div><div class="line">	var x, y = 4, 5</div><div class="line">	arr := []*int&#123;&amp;x, &amp;y&#125;</div><div class="line">	fmt.Println(arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[0 0 0 0 0 1]</div><div class="line">&amp;[0 0 0 0 0 1]</div><div class="line">[0xc4200142b0 0xc4200142b8]</div></pre></td></tr></table></figure></p>
<h4 id="range遍历数组"><a href="#range遍历数组" class="headerlink" title="range遍历数组"></a>range遍历数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func rangeArr() &#123;</div><div class="line"></div><div class="line">	var arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class="line">	for i, v := range arr &#123;</div><div class="line">		fmt.Println(i, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div></pre></td></tr></table></figure></p>
<h4 id="new-关键字创建数组"><a href="#new-关键字创建数组" class="headerlink" title="new 关键字创建数组"></a>new 关键字创建数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func newarr() &#123;</div><div class="line"></div><div class="line">	var a = [5]int&#123;&#125;</div><div class="line">	a[1] = 2</div><div class="line">	fmt.Println(a)</div><div class="line"></div><div class="line">	p := new([5]int) //可以通过下标赋值</div><div class="line">	p[1] = 2</div><div class="line">	fmt.Println(p)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[0 2 0 0 0]</div><div class="line">&amp;[0 2 0 0 0]</div></pre></td></tr></table></figure></p>
<h4 id="数组传递"><a href="#数组传递" class="headerlink" title="数组传递"></a>数组传递</h4><p>在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func main() &#123;</div><div class="line"></div><div class="line">	var testArr = [5]int&#123;1, 2, 3, 4, 5&#125;</div><div class="line"></div><div class="line">	fmt.Println(testArr)</div><div class="line"></div><div class="line">	modifyarr(testArr)</div><div class="line"></div><div class="line">	fmt.Println(&quot;In main&quot;, testArr)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func modifyarr(arr [5]int) &#123;</div><div class="line">	arr[0] = 10</div><div class="line">	fmt.Println(&quot;In modify&quot;, arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1 2 3 4 5]</div><div class="line">In modify [10 2 3 4 5]</div><div class="line">In main [1 2 3 4 5]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。&lt;/li&gt;
&lt;li&gt;定义数组的格式：var &lt;varName&gt; [n]&lt;type&gt;，n&amp;gt;=0&lt;/li&gt;
&lt;li&gt;数组长度也是类型的一部分，因此具有不同长度的数组为不同类型&lt;/li&gt;
&lt;li&gt;注意区分指向数组的指针和指针数组&lt;/li&gt;
&lt;li&gt;数组在Go中为值类型&lt;/li&gt;
&lt;li&gt;数组之间可以使用==或!=进行比较，但不可以使用&amp;lt;或&amp;gt;(比较的前提是数组个数相同，并且元素类型相同)&lt;/li&gt;
&lt;li&gt;可以使用new来创建数组，此方法返回一个指向数组的指针&lt;/li&gt;
&lt;li&gt;Go支持多维数组&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="数组" scheme="http://gcblog/github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac下安装go及环境变量配置</title>
    <link href="http://gcblog/github.io/2018/04/04/mac%E4%B8%8B%E5%AE%89%E8%A3%85go%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://gcblog/github.io/2018/04/04/mac下安装go及环境变量配置/</id>
    <published>2018-04-04T09:10:56.000Z</published>
    <updated>2018-05-04T09:13:19.221Z</updated>
    
    <content type="html"><![CDATA[<p>以下命令都是直接在根目录下执行即可</p>
<h3 id="方法一：homebrew"><a href="#方法一：homebrew" class="headerlink" title="方法一：homebrew"></a>方法一：homebrew</h3><p><code>homebrew</code>是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装<code>homebrew</code></p>
<p>安装命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew update &amp;&amp; brew upgrade</div><div class="line">$ brew install go</div></pre></td></tr></table></figure></p>
<p>安装完输入 <code>go env</code> 查看环境信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">GOARCH=&quot;amd64&quot;</div><div class="line">GOBIN=&quot;&quot;</div><div class="line">GOCACHE=&quot;/Users/qianjianeng/Library/Caches/go-build&quot;</div><div class="line">GOEXE=&quot;&quot;</div><div class="line">GOHOSTARCH=&quot;amd64&quot;</div><div class="line">GOHOSTOS=&quot;darwin&quot;</div><div class="line">GOOS=&quot;darwin&quot;</div><div class="line">GOPATH=&quot;/Users/qianjianeng/go&quot;</div><div class="line">GORACE=&quot;&quot;</div><div class="line">GOROOT=&quot;/usr/local/Cellar/go/1.10/libexec&quot;</div><div class="line">GOTMPDIR=&quot;&quot;</div><div class="line">GOTOOLDIR=&quot;/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64&quot;</div><div class="line">GCCGO=&quot;gccgo&quot;</div><div class="line">CC=&quot;clang&quot;</div><div class="line">CXX=&quot;clang++&quot;</div><div class="line">CGO_ENABLED=&quot;1&quot;</div><div class="line">CGO_CFLAGS=&quot;-g -O2&quot;</div><div class="line">CGO_CPPFLAGS=&quot;&quot;</div><div class="line">CGO_CXXFLAGS=&quot;-g -O2&quot;</div><div class="line">CGO_FFLAGS=&quot;-g -O2&quot;</div><div class="line">CGO_LDFLAGS=&quot;-g -O2&quot;</div><div class="line">PKG_CONFIG=&quot;pkg-config&quot;</div><div class="line">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="方法二：pkg包安装"><a href="#方法二：pkg包安装" class="headerlink" title="方法二：pkg包安装"></a>方法二：pkg包安装</h3><p>直接去官方下载安装包，然后双击安装,之后同样地输入<code>go env</code>、<code>go version</code>等查看是否安装。</p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><h4 id="打开bash-profile"><a href="#打开bash-profile" class="headerlink" title="打开bash_profile"></a>打开<code>bash_profile</code></h4><p><code>$ open .bash_profile</code></p>
<h4 id="如果不存在创建bash-profile"><a href="#如果不存在创建bash-profile" class="headerlink" title="如果不存在创建bash_profile"></a>如果不存在创建bash_profile</h4><p><code>$ vim ~/.bash_profile</code></p>
<h4 id="添加go环境变量"><a href="#添加go环境变量" class="headerlink" title="添加go环境变量"></a>添加go环境变量</h4><p>如果是第一种安装方法，只需要指定一下GOPATH即可。为了让自己的程序编译之后在命令行任何地方能直接执行，再加入GOPATH下的bin即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#This is my personal bash_profile,when loaded at login.</div><div class="line">#===2015-08-15===</div><div class="line"></div><div class="line">#GOPATH</div><div class="line">export GOPATH=$HOME/Documents/go_workspace</div><div class="line"></div><div class="line">#GOPATH bin</div><div class="line">export PATH=$PATH:$GOPATH/bin</div></pre></td></tr></table></figure></p>
<p>但是第二种方法安装之后输入go可能会显示ommand not found: go，所以需要在.bash_profile中指定GOROOT下的bin：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#This is my personal bash_profile,when loaded at login.</div><div class="line">#===2015-08-15===</div><div class="line">#GOROOT</div><div class="line">export GOROOT=/usr/local/go</div><div class="line"></div><div class="line">#GOPATH</div><div class="line">export GOPATH=$HOME/Documents/go_workspace</div><div class="line"></div><div class="line">#GOROOT bin</div><div class="line">export PATH=$PATH:$GOROOT/bin</div><div class="line"></div><div class="line">#GOPATH bin</div><div class="line">export PATH=$PATH:$GOPATH/bin</div></pre></td></tr></table></figure></p>
<p>一般环境变量更改后，重启后生效。在重启终端的时候就会自动执行.bash_profile文件。<br>如果想立刻生效，则可执行下面的语句：</p>
<p><code>$ source .bash_profile</code></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中：</p>
<p><code>$ open .zshrc</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下命令都是直接在根目录下执行即可&lt;/p&gt;
&lt;h3 id=&quot;方法一：homebrew&quot;&gt;&lt;a href=&quot;#方法一：homebrew&quot; class=&quot;headerlink&quot; title=&quot;方法一：homebrew&quot;&gt;&lt;/a&gt;方法一：homebrew&lt;/h3&gt;&lt;p&gt;&lt;code&gt;homebrew&lt;/code&gt;是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装&lt;code&gt;homebrew&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ brew update &amp;amp;&amp;amp; brew upgrade&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ brew install go&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;安装完输入 &lt;code&gt;go env&lt;/code&gt; 查看环境信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;GOARCH=&amp;quot;amd64&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOBIN=&amp;quot;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOCACHE=&amp;quot;/Users/qianjianeng/Library/Caches/go-build&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOEXE=&amp;quot;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOHOSTARCH=&amp;quot;amd64&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOHOSTOS=&amp;quot;darwin&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOOS=&amp;quot;darwin&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOPATH=&amp;quot;/Users/qianjianeng/go&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GORACE=&amp;quot;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOROOT=&amp;quot;/usr/local/Cellar/go/1.10/libexec&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOTMPDIR=&amp;quot;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOTOOLDIR=&amp;quot;/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GCCGO=&amp;quot;gccgo&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CC=&amp;quot;clang&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CXX=&amp;quot;clang++&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CGO_ENABLED=&amp;quot;1&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CGO_CFLAGS=&amp;quot;-g -O2&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CGO_CPPFLAGS=&amp;quot;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CGO_CXXFLAGS=&amp;quot;-g -O2&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CGO_FFLAGS=&amp;quot;-g -O2&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CGO_LDFLAGS=&amp;quot;-g -O2&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PKG_CONFIG=&amp;quot;pkg-config&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GOGCCFLAGS=&amp;quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="go" scheme="http://gcblog/github.io/tags/go/"/>
    
      <category term="环境变量" scheme="http://gcblog/github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>PhotoBatch-图片去重(3)</title>
    <link href="http://gcblog/github.io/2017/12/22/PhotoBatch-%E5%9B%BE%E7%89%87%E5%8E%BB%E9%87%8D-3/"/>
    <id>http://gcblog/github.io/2017/12/22/PhotoBatch-图片去重-3/</id>
    <published>2017-12-22T04:36:51.000Z</published>
    <updated>2017-12-22T06:28:58.704Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html" target="_blank" rel="external">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></p>
<p>很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。</p>
<p>这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。</p>
<p>另外还找到了其他几种方法，这里是地址<br><a href="http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html</a></p>
<h2 id="第一步，缩小尺寸。"><a href="#第一步，缩小尺寸。" class="headerlink" title="第一步，缩小尺寸。"></a>第一步，缩小尺寸。</h2><p>将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。<br>在macOS，使用的是<code>NSImage</code>, 两者的一些操作很类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize</div><div class="line">&#123;</div><div class="line">    NSImage *sourceImage = image;</div><div class="line">    if (![sourceImage isValid])&#123;</div><div class="line">        NSLog(@&quot;Invalid Image&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];</div><div class="line">        [smallImage lockFocus];</div><div class="line">        [sourceImage setSize: reSize];</div><div class="line">        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];</div><div class="line">        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];</div><div class="line">        [smallImage unlockFocus];</div><div class="line">        return smallImage;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <a id="more"></a>
<h2 id="第二步，简化色彩。"><a href="#第二步，简化色彩。" class="headerlink" title="第二步，简化色彩。"></a>第二步，简化色彩。</h2><p>将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。</p>
<h2 id="第三步，计算平均值。"><a href="#第三步，计算平均值。" class="headerlink" title="第三步，计算平均值。"></a>第三步，计算平均值。</h2><p>计算所有64个像素的灰度平均值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">a[ArrSize] = 0;</div><div class="line">b[ArrSize] = 0;</div><div class="line">CGPoint point;</div><div class="line">for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class="line">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class="line">        point.x = i;</div><div class="line">        point.y = j;</div><div class="line">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class="line">        a[cursize * i + j] = grey;</div><div class="line">        a[ArrSize] += grey;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[ArrSize] /= (ArrSize - 1);//灰度平均值</div><div class="line">for (i = 0 ; i &lt; cursize; i++) &#123;//计算b的灰度</div><div class="line">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class="line">        point.x = i;</div><div class="line">        point.y = j;</div><div class="line">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]);</div><div class="line">        b[cursize * i + j] = grey;</div><div class="line">        b[ArrSize] += grey;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">b[ArrSize] /= (ArrSize - 1);//灰度平均值</div></pre></td></tr></table></figure></p>
<h2 id="第四步，比较像素的灰度。"><a href="#第四步，比较像素的灰度。" class="headerlink" title="第四步，比较像素的灰度。"></a>第四步，比较像素的灰度。</h2><p>将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">a[ArrSize] = 0;</div><div class="line">   b[ArrSize] = 0;</div><div class="line">   CGPoint point;</div><div class="line">   for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class="line">       for (j = 0; j &lt; cursize; j++) &#123;</div><div class="line">           point.x = i;</div><div class="line">           point.y = j;</div><div class="line">           grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class="line">           a[cursize * i + j] = grey;</div><div class="line">           a[ArrSize] += grey;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="第五步，计算哈希值。"><a href="#第五步，计算哈希值。" class="headerlink" title="第五步，计算哈希值。"></a>第五步，计算哈希值。</h2><p>将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。<br>得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算”汉明距离”（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。<br>实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。</p>
<p>这是一个比较耗时的操作，所以放在子线程中操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *totalArr = [NSMutableArray array];</div><div class="line">   </div><div class="line">   __weak __typeof(self)weakSelf = self;</div><div class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">       </div><div class="line">       for (NSString *filePath in allFiles) &#123;</div><div class="line">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理文件：%@&quot;, filePath];</div><div class="line">           &#125;);</div><div class="line">           if (totalArr.count == 0) &#123;</div><div class="line">               NSMutableArray *arr = [NSMutableArray array];</div><div class="line">               [arr addObject:filePath];</div><div class="line">               [totalArr addObject:arr];</div><div class="line">           &#125; else &#123;</div><div class="line">               </div><div class="line">               NSInteger groupCount = [[totalArr mutableCopy] count];</div><div class="line">               for (int i = 0; i &lt; groupCount; i++) &#123;</div><div class="line">                   NSMutableArray *arr = totalArr[i];</div><div class="line">                   NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject];</div><div class="line">                   NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath];</div><div class="line">                   Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb];</div><div class="line">                   if (simi &gt;= 0.9) &#123; //相似度比较接近</div><div class="line">                       [arr addObject:filePath];</div><div class="line">                       break;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       if (i == [[totalArr mutableCopy] count] - 1) &#123;  //已经遍历到最后一组，还没有找到相似图片，新建一组</div><div class="line">                           NSMutableArray *arr = [NSMutableArray array];</div><div class="line">                           [arr addObject:filePath];</div><div class="line">                           @synchronized(totalArr) &#123;</div><div class="line">                               [totalArr addObject:arr];</div><div class="line">                           &#125;</div><div class="line">                           break;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               </div><div class="line">               </div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       NSMutableArray *repeatArr = [NSMutableArray new];</div><div class="line">       for (NSArray *arr in totalArr) &#123;</div><div class="line">           if (arr.count &gt; 1) &#123;</div><div class="line">               [repeatArr addObject:arr];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">           weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理完成&quot;];</div><div class="line">           [self.checkRepeatView buildUIWithImageArr:repeatArr];</div><div class="line">       &#125;);</div><div class="line">       </div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>效果图：</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3_1.png" alt=""></p>
<p><a href="https://github.com/macOSApp/photoBatch" target="_blank" rel="external">demo地址:https://github.com/macOSApp/photoBatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;a href=&quot;http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html&quot;&gt;http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。&lt;/p&gt;
&lt;p&gt;这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。&lt;/p&gt;
&lt;p&gt;另外还找到了其他几种方法，这里是地址&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html&quot;&gt;http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一步，缩小尺寸。&quot;&gt;&lt;a href=&quot;#第一步，缩小尺寸。&quot; class=&quot;headerlink&quot; title=&quot;第一步，缩小尺寸。&quot;&gt;&lt;/a&gt;第一步，缩小尺寸。&lt;/h2&gt;&lt;p&gt;将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。&lt;br&gt;在macOS，使用的是&lt;code&gt;NSImage&lt;/code&gt;, 两者的一些操作很类似。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSImage *sourceImage = image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if (![sourceImage isValid])&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        NSLog(@&amp;quot;Invalid Image&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [smallImage lockFocus];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [sourceImage setSize: reSize];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [smallImage unlockFocus];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return smallImage;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return nil;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="macOS" scheme="http://gcblog/github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://gcblog/github.io/tags/macOS/"/>
    
      <category term="macOSApp" scheme="http://gcblog/github.io/tags/macOSApp/"/>
    
      <category term="图片去重" scheme="http://gcblog/github.io/tags/%E5%9B%BE%E7%89%87%E5%8E%BB%E9%87%8D/"/>
    
      <category term="图片相似查询" scheme="http://gcblog/github.io/tags/%E5%9B%BE%E7%89%87%E7%9B%B8%E4%BC%BC%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>PhotoBatch-文件重命名(2)</title>
    <link href="http://gcblog/github.io/2017/12/04/PhotoBatch-%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D-2/"/>
    <id>http://gcblog/github.io/2017/12/04/PhotoBatch-文件重命名-2/</id>
    <published>2017-12-04T08:50:20.000Z</published>
    <updated>2017-12-04T08:52:53.477Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名</p>
<h3 id="搭建界面"><a href="#搭建界面" class="headerlink" title="搭建界面"></a>搭建界面</h3><p>搭了个简单的界面，如下图：<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png" alt="布局用了purelayout框架"><br>我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。</p>
<h3 id="文件夹处理"><a href="#文件夹处理" class="headerlink" title="文件夹处理"></a>文件夹处理</h3><p>获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以<br><code>file://</code>开头，需要把前面的<code>file://</code>去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (void)dealFiles:(NSArray *)filepaths</div><div class="line">&#123;</div><div class="line">    self.dealingLabel.stringValue = [filepaths.firstObject description];</div><div class="line">    </div><div class="line">    NSMutableArray *arr = [NSMutableArray new];</div><div class="line">    // 对文件夹路径进行处理</div><div class="line">    for (NSString *path in filepaths) &#123;</div><div class="line">        if ([[path description] hasPrefix:@&quot;file:///&quot;]) &#123;</div><div class="line">            NSString *newpath = [[path description] substringFromIndex:7];</div><div class="line">            if ([newpath hasSuffix:@&quot;/&quot;]) &#123;</div><div class="line">                newpath  = [newpath substringToIndex:newpath.length - 1];</div><div class="line">            &#125;</div><div class="line">            [arr addObject:newpath];</div><div class="line">            </div><div class="line">        &#125; else &#123;</div><div class="line">            if ([[path description] hasSuffix:@&quot;/&quot;]) &#123;</div><div class="line">                NSString *tempStr = [path description];</div><div class="line">                [arr addObject:[tempStr substringToIndex:tempStr.length - 1]];</div><div class="line">            &#125; else &#123;</div><div class="line">                [arr addObject:[path description]];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.folderPaths = filepaths;</div><div class="line">    </div><div class="line">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class="line">    for (NSString *docuPath in self.folderPaths) &#123; // 遍历所有文件夹 获取所有文件个数</div><div class="line">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class="line">        [allFiles addObjectsFromArray:files];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSAlert *alert = [[NSAlert alloc] init];</div><div class="line">    [alert setMessageText:@&quot;文件获取成功&quot;];</div><div class="line">    [alert setInformativeText:[NSString stringWithFormat:@&quot;文件总数：%ld 个&quot;, allFiles.count]];</div><div class="line">    [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) &#123;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文件批量重命名"><a href="#文件批量重命名" class="headerlink" title="文件批量重命名"></a>文件批量重命名</h3><p>遍历所有文件夹下所有文件，<code>NSFileManager</code> 并没有重命名的方法，如果要保留原文件，则执行<code>copy</code>操作，如果不保留原文件，则执行<code>move</code>操作。下面是重命名代码的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">- (IBAction)StartAction:(NSButton *)sender &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class="line">    for (NSString *docuPath in self.folderPaths) &#123;</div><div class="line">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class="line">        for (NSString *filename in files) &#123;</div><div class="line">            [allFiles addObject:[NSString stringWithFormat:@&quot;%@/%@&quot;, docuPath, filename]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (allFiles.count == 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    NSString *resultFilePath = [NSString stringWithFormat:@&quot;%@/%@&quot;, self.folderPaths.firstObject, @&quot;result&quot;];</div><div class="line">    </div><div class="line">    NSError *err = nil;</div><div class="line">    [XCFileManager createDirectoryAtPath:resultFilePath error:&amp;err];</div><div class="line">    NSString *prefixName = _reNameView.prefixInput.stringValue;</div><div class="line">    if (!prefixName || prefixName.length == 0) &#123;</div><div class="line">        prefixName = @&quot;img_&quot;;</div><div class="line">    &#125;</div><div class="line">    NSString *suffixName = _reNameView.suffixInput.stringValue;</div><div class="line">    if(!suffixName || suffixName.length == 0) &#123;</div><div class="line">        suffixName = @&quot;&quot;;</div><div class="line">    &#125;</div><div class="line">    NSInteger index = 1;</div><div class="line">    NSString *suffix = @&quot;&quot;;</div><div class="line">    for (NSString *path in allFiles) &#123;</div><div class="line">//        // 如果遇到 没有文件名的文件，直接过滤</div><div class="line">        if ([path componentsSeparatedByString:@&quot;.&quot;].count &lt; 2) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (suffixName.length == 0) &#123;</div><div class="line">            suffix = [[path componentsSeparatedByString:@&quot;.&quot;].lastObject description];</div><div class="line">        &#125; else &#123;</div><div class="line">            suffix = suffixName;</div><div class="line">        &#125;</div><div class="line">        self.dealingLabel.stringValue = [path description];</div><div class="line">        </div><div class="line">        NSString *movePath = [NSString stringWithFormat:@&quot;%@/%@%ld.%@&quot;, resultFilePath, prefixName, index,suffix];</div><div class="line">        if (_reNameView.checkSaveBtn.state == 1) &#123;</div><div class="line">           [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO];</div><div class="line">        &#125; else &#123;</div><div class="line">            [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        index ++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.dealingLabel.stringValue = @&quot;处理完成&quot;;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/macOSApp/photoBatch" target="_blank" rel="external">demo地址:https://github.com/macOSApp/photoBatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名&lt;/p&gt;
&lt;h3 id=&quot;搭建界面&quot;&gt;&lt;a href=&quot;#搭建界面&quot; class=&quot;headerlink&quot; title=&quot;搭建界面&quot;&gt;&lt;/a&gt;搭建界面&lt;/h3&gt;&lt;p&gt;搭了个简单的界面，如下图：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png&quot; alt=&quot;布局用了purelayout框架&quot;&gt;&lt;br&gt;我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。&lt;/p&gt;
&lt;h3 id=&quot;文件夹处理&quot;&gt;&lt;a href=&quot;#文件夹处理&quot; class=&quot;headerlink&quot; title=&quot;文件夹处理&quot;&gt;&lt;/a&gt;文件夹处理&lt;/h3&gt;&lt;p&gt;获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以&lt;br&gt;&lt;code&gt;file://&lt;/code&gt;开头，需要把前面的&lt;code&gt;file://&lt;/code&gt;去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。&lt;/p&gt;
    
    </summary>
    
      <category term="macOS" scheme="http://gcblog/github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://gcblog/github.io/tags/macOS/"/>
    
      <category term="macOSApp" scheme="http://gcblog/github.io/tags/macOSApp/"/>
    
      <category term="文件重命名" scheme="http://gcblog/github.io/tags/%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>PhotoBatch-文件操作(1)</title>
    <link href="http://gcblog/github.io/2017/11/26/PhotoBatch-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1/"/>
    <id>http://gcblog/github.io/2017/11/26/PhotoBatch-文件操作-1/</id>
    <published>2017-11-26T08:02:41.000Z</published>
    <updated>2017-11-26T08:08:50.748Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。</p>
<h3 id="文件拖拽"><a href="#文件拖拽" class="headerlink" title="文件拖拽"></a>文件拖拽</h3><ul>
<li>需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径</li>
</ul>
<h4 id="新建-macOS-工程"><a href="#新建-macOS-工程" class="headerlink" title="新建 macOS 工程"></a>新建 macOS 工程</h4><p>跟新建iOS项目工程几乎一致。</p>
<p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png" alt="新建工程"><br><a id="more"></a></p>
<h4 id="自定义PBDragView"><a href="#自定义PBDragView" class="headerlink" title="自定义PBDragView"></a>自定义PBDragView</h4><p>在iOS中，最核心的的框架就是<code>Foundation</code>和<code>UIKit</code>, 在macOS中，就是<code>Foundation</code>和<code>AppKit</code>, 对于iOS中大部分控件，都是把前缀又<code>UI</code>换成了<code>NS</code>, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客<a href="https://www.objccn.io/issue-14-5" target="_blank" rel="external">从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5)</a>, 讲述了这两个框架的一些异同。</p>
<p>我们需要自定义一个 <code>PBDragView</code> 继承自<code>NSView</code>，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。</p>
<h4 id="注册支持的文件类型"><a href="#注册支持的文件类型" class="headerlink" title="注册支持的文件类型"></a>注册支持的文件类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)awakeFromNib</div><div class="line">&#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">    // 设置支持的文件类型</div><div class="line">    [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">#### 实现文件拖动的几个方法</div></pre></td></tr></table></figure>
<ul>
<li><p>(NSDragOperation)draggingEntered:(id<nsdragginginfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragEnter)]) {</nsdragginginfo></p>
<pre><code>[self.delegate dragEnter];
</code></pre><p>  }</p>
<p>  return NSDragOperationGeneric;<br>}</p>
</li>
<li><p>(void)draggingExited:(id<nsdragginginfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragExit)]) {</nsdragginginfo></p>
<pre><code>[self.delegate dragExit];
</code></pre><p>  }<br>}</p>
</li>
<li><p>(BOOL)performDragOperation:(id<nsdragginginfo>)sender<br>{<br>  // 获取所有的路径<br>  NSArray *arr =  [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];<br>  if (self.delegate &amp;&amp; arr.count &gt; 0 &amp;&amp; [self.delegate respondsToSelector:@selector(dragFileComplete:)]) {</nsdragginginfo></p>
<pre><code>[self.delegate dragFileComplete:arr];
</code></pre><p>  }<br>  return YES;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#### 在SB中使用PBDragView</div><div class="line"></div><div class="line">![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)</div><div class="line"></div><div class="line">运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。</div><div class="line"></div><div class="line"></div><div class="line">### 文件选择</div><div class="line"></div><div class="line">* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹</div><div class="line"></div><div class="line">#### 添加点击按钮</div><div class="line"></div><div class="line">在SB中添加按钮，然后添加点击事件</div><div class="line">![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)</div><div class="line"></div><div class="line"></div><div class="line">#### 文件选择功能实现</div></pre></td></tr></table></figure>
<p>  NSOpenPanel *openPanel = [NSOpenPanel openPanel];<br>  [openPanel setPrompt: @”打开”];<br>  [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹<br>  [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录<br>  [openPanel setCanChooseFiles:YES];  //设置允许打开文件<br>  [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹<br>  [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档<br>  [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档<br>  openPanel.allowedFileTypes = [NSArray arrayWithObjects: @”jpg”, @”doc”,@”txt”,@”jpeg”,@”png”,@”tiff”, nil]; //设置允许打开的文件类型<br>  [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) {</p>
<pre><code>NSArray *filePaths = [openPanel URLs];
NSLog(@&quot;-----%@&quot;, filePaths);
</code></pre><p>  }];<br>```<br>效果图：<br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/4.png" alt="弹出系统的文件选择框"></p>
</li>
</ul>
<p><a href="https://github.com/macOSApp/photoBatch" target="_blank" rel="external">demo地址:https://github.com/macOSApp/photoBatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。&lt;/p&gt;
&lt;h3 id=&quot;文件拖拽&quot;&gt;&lt;a href=&quot;#文件拖拽&quot; class=&quot;headerlink&quot; title=&quot;文件拖拽&quot;&gt;&lt;/a&gt;文件拖拽&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;新建-macOS-工程&quot;&gt;&lt;a href=&quot;#新建-macOS-工程&quot; class=&quot;headerlink&quot; title=&quot;新建 macOS 工程&quot;&gt;&lt;/a&gt;新建 macOS 工程&lt;/h4&gt;&lt;p&gt;跟新建iOS项目工程几乎一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png&quot; alt=&quot;新建工程&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="macOS" scheme="http://gcblog/github.io/categories/macOS/"/>
    
    
      <category term="macOS" scheme="http://gcblog/github.io/tags/macOS/"/>
    
      <category term="macOSApp" scheme="http://gcblog/github.io/tags/macOSApp/"/>
    
      <category term="文件处理" scheme="http://gcblog/github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Gif播放与暂停</title>
    <link href="http://gcblog/github.io/2017/11/14/Gif%E6%92%AD%E6%94%BE%E4%B8%8E%E6%9A%82%E5%81%9C/"/>
    <id>http://gcblog/github.io/2017/11/14/Gif播放与暂停/</id>
    <published>2017-11-14T02:13:08.000Z</published>
    <updated>2017-11-14T02:15:27.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gif播放的两种方式"><a href="#gif播放的两种方式" class="headerlink" title="gif播放的两种方式"></a>gif播放的两种方式</h2><h3 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h3><p>这应该是播放gif文件最简单的方式了，缺点：无法暂停播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//1. 把gif文件 转化成 data</div><div class="line">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class="line">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class="line"></div><div class="line">//2. 给UIWebView 设置data</div><div class="line">let webview = UIWebView()</div><div class="line">webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)</div><div class="line">webview.scalesPageToFit = true</div><div class="line">webview.load(gifData as Data, mimeType: &quot;image/gif&quot;, textEncodingName: String(), baseURL: NSURL() as URL)</div><div class="line">self.view.addSubview(webview)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h3><p>这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">let imageView = UIImageView()</div><div class="line">imageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)</div><div class="line">self.view.addSubview(imageView)</div><div class="line"></div><div class="line">// 1. 把gif文件 转化成 data</div><div class="line">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class="line">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class="line"></div><div class="line">// 2. 把data 转换成CGImageSource 对象</div><div class="line">guard let imageSource = CGImageSourceCreateWithData(gifData, nil) else &#123; return &#125;</div><div class="line">// 2.1 获取图片的个数</div><div class="line">let imageCount = CGImageSourceGetCount(imageSource)</div><div class="line"></div><div class="line">var images = [UIImage]()</div><div class="line">var gifDuration : TimeInterval = 0</div><div class="line">// 3. 遍历所有的图片</div><div class="line">for i in 0..&lt;imageCount &#123;</div><div class="line">    // 3.1 取出图片</div><div class="line">   guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil)  else &#123; return &#125;</div><div class="line"></div><div class="line">    let image = UIImage(cgImage: cgimage)</div><div class="line">    images.append(image)</div><div class="line">    if (i == 0) &#123;</div><div class="line">        imageView.image = image</div><div class="line">    &#125;</div><div class="line">    // 3.1 取出每张图片持续的时间</div><div class="line">    guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else &#123; continue &#125;</div><div class="line">    guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else &#123; continue &#125;</div><div class="line">    guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else &#123; continue &#125;</div><div class="line">    gifDuration += imageDuration.doubleValue</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 4.设置images属性</div><div class="line">imageView.animationImages = images</div><div class="line">imageView.animationDuration = gifDuration</div><div class="line">imageView.animationRepeatCount = 1</div><div class="line"></div><div class="line">// 5. 开始播放</div><div class="line">imageView.startAnimating()</div></pre></td></tr></table></figure>
<h2 id="Gif暂停实现"><a href="#Gif暂停实现" class="headerlink" title="Gif暂停实现"></a>Gif暂停实现</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gif播放的两种方式&quot;&gt;&lt;a href=&quot;#gif播放的两种方式&quot; class=&quot;headerlink&quot; title=&quot;gif播放的两种方式&quot;&gt;&lt;/a&gt;gif播放的两种方式&lt;/h2&gt;&lt;h3 id=&quot;UIWebView&quot;&gt;&lt;a href=&quot;#UIWebView&quot; class=&quot;headerlink&quot; title=&quot;UIWebView&quot;&gt;&lt;/a&gt;UIWebView&lt;/h3&gt;&lt;p&gt;这应该是播放gif文件最简单的方式了，缺点：无法暂停播放&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//1. 把gif文件 转化成 data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;guard let dataPath = Bundle.main.path(forResource: &amp;quot;demo&amp;quot;, ofType: &amp;quot;gif&amp;quot;) else &amp;#123; return &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;guard let gifData = NSData(contentsOfFile: dataPath) else &amp;#123; return &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//2. 给UIWebView 设置data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let webview = UIWebView()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webview.scalesPageToFit = true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webview.load(gifData as Data, mimeType: &amp;quot;image/gif&amp;quot;, textEncodingName: String(), baseURL: NSURL() as URL)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;self.view.addSubview(webview)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swfit" scheme="http://gcblog/github.io/categories/Swfit/"/>
    
    
      <category term="Swift" scheme="http://gcblog/github.io/tags/Swift/"/>
    
      <category term="Gif" scheme="http://gcblog/github.io/tags/Gif/"/>
    
      <category term="动画" scheme="http://gcblog/github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="runloop" scheme="http://gcblog/github.io/tags/runloop/"/>
    
      <category term="CADisplayLink" scheme="http://gcblog/github.io/tags/CADisplayLink/"/>
    
  </entry>
  
  <entry>
    <title>iOS三种录制视频方式详细对比</title>
    <link href="http://gcblog/github.io/2017/03/22/iOS%E4%B8%89%E7%A7%8D%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91%E6%96%B9%E5%BC%8F%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94/"/>
    <id>http://gcblog/github.io/2017/03/22/iOS三种录制视频方式详细对比/</id>
    <published>2017-03-21T16:24:33.000Z</published>
    <updated>2017-03-21T16:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先附上参考资料"><a href="#先附上参考资料" class="headerlink" title="先附上参考资料"></a>先附上参考资料</h3><p><a href="http://www.jianshu.com/p/16cb14f53933" target="_blank" rel="external">http://www.jianshu.com/p/16cb14f53933</a></p>
<p><a href="https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html" target="_blank" rel="external">https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html</a></p>
<p><a href="https://github.com/objcio/VideoCaptureDemo" target="_blank" rel="external">https://github.com/objcio/VideoCaptureDemo</a></p>
<p><a href="https://github.com/gsixxxx/DTSmallVideo" target="_blank" rel="external">https://github.com/gsixxxx/DTSmallVideo</a></p>
<p><a href="https://github.com/AndyFightting/VideoRecord" target="_blank" rel="external">https://github.com/AndyFightting/VideoRecord</a></p>
<h3 id="卷首吐槽语"><a href="#卷首吐槽语" class="headerlink" title="卷首吐槽语"></a>卷首吐槽语</h3><p>这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。</p>
<p>先附上dome <a href="https://github.com/suifengqjn/VideoRecord" target="_blank" rel="external">demo地址</a></p>
<h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p>方便大家对三中录制方式有一个大概的了解，看一下这张图片。<br><img src="https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true" alt="基本属性与类"><br>第一种采用系统的录制较为简单，详细介绍后面两种。<br><a id="more"></a></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c1.png" alt="1"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c2.png" alt="2"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c3.png" alt="3"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c4.png" alt="4"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c5.png" alt="5"> <img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c6.png" alt="6"></p>
<p>demo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。</p>
<h3 id="1-UIImagePickerController"><a href="#1-UIImagePickerController" class="headerlink" title="1.UIImagePickerController"></a>1.UIImagePickerController</h3><p>这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    if ([self isVideoRecordingAvailable]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.sourceType = UIImagePickerControllerSourceTypeCamera;</div><div class="line">    self.mediaTypes = @[(NSString *)kUTTypeMovie];</div><div class="line">    self.delegate = self;</div><div class="line">    </div><div class="line">    //隐藏系统自带UI</div><div class="line">    self.showsCameraControls = NO;</div><div class="line">    //设置摄像头</div><div class="line">    [self switchCameraIsFront:NO];</div><div class="line">    //设置视频画质类别</div><div class="line">    self.videoQuality = UIImagePickerControllerQualityTypeMedium;</div><div class="line">    //设置散光灯类型</div><div class="line">    self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;</div><div class="line">    //设置录制的最大时长</div><div class="line">    self.videoMaximumDuration = 20;</div><div class="line">&#125;</div><div class="line">- (BOOL)isVideoRecordingAvailable</div><div class="line">&#123;</div><div class="line">    if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])&#123;</div><div class="line">        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class="line">        if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie])&#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)switchCameraIsFront:(BOOL)front</div><div class="line">&#123;</div><div class="line">    if (front) &#123;</div><div class="line">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront])&#123;</div><div class="line">            [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear])&#123;</div><div class="line">            [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-AVCaptureSession-AVCaptureMovieFileOutput"><a href="#2-AVCaptureSession-AVCaptureMovieFileOutput" class="headerlink" title="2.AVCaptureSession+AVCaptureMovieFileOutput"></a>2.AVCaptureSession+AVCaptureMovieFileOutput</h3><p>流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 创建捕捉会话</div><div class="line">2. 设置视频的输入</div><div class="line">3. 设置音频的输入</div><div class="line">4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据</div><div class="line">5. 添加视频预览层</div><div class="line">6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div></pre></td></tr></table></figure></p>
<h4 id="0-创建捕捉会话"><a href="#0-创建捕捉会话" class="headerlink" title="0. 创建捕捉会话"></a>0. 创建捕捉会话</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.session = [[AVCaptureSession alloc] init];</div><div class="line">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class="line">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="1-视频的输入"><a href="#1-视频的输入" class="headerlink" title="1. 视频的输入"></a>1. 视频的输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   - (void)setUpVideo</div><div class="line">&#123;</div><div class="line">    // 1.1 获取视频输入设备(摄像头)</div><div class="line">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class="line">    </div><div class="line">    // 视频 HDR (高动态范围图像)</div><div class="line">    // videoCaptureDevice.videoHDREnabled = YES;</div><div class="line">    // 设置最大，最小帧速率</div><div class="line">    //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60);</div><div class="line">    // 1.2 创建视频输入源</div><div class="line">    NSError *error=nil;</div><div class="line">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class="line">    // 1.3 将视频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">        [self.session addInput:self.videoInput];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-音频的输入"><a href="#2-音频的输入" class="headerlink" title="2. 音频的输入"></a>2. 音频的输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 2.1 获取音频输入设备</div><div class="line">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class="line">    NSError *error=nil;</div><div class="line">    // 2.2 创建音频输入源</div><div class="line">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class="line">    // 2.3 将音频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class="line">        [self.session addInput:self.audioInput];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="3-输出源设置"><a href="#3-输出源设置" class="headerlink" title="3.输出源设置"></a>3.输出源设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)setUpFileOut</div><div class="line">&#123;</div><div class="line">    // 3.1初始化设备输出对象，用于获得输出数据</div><div class="line">    self.FileOutput=[[AVCaptureMovieFileOutput alloc]init];</div><div class="line">    </div><div class="line">    // 3.2设置输出对象的一些属性</div><div class="line">    AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class="line">    //设置防抖</div><div class="line">    //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</div><div class="line">    if ([captureConnection isVideoStabilizationSupported ]) &#123;</div><div class="line">        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;</div><div class="line">    &#125;</div><div class="line">    //预览图层和视频方向保持一致</div><div class="line">    captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation;</div><div class="line">    </div><div class="line">    // 3.3将设备输出添加到会话中</div><div class="line">    if ([_session canAddOutput:_FileOutput]) &#123;</div><div class="line">        [_session addOutput:_FileOutput];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-视频预览层"><a href="#4-视频预览层" class="headerlink" title="4. 视频预览层"></a>4. 视频预览层</h4><p>一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class="line">&#123;</div><div class="line">    CGRect rect = CGRectZero;</div><div class="line">    switch (type) &#123;</div><div class="line">        case Type1X1:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class="line">            break;</div><div class="line">        case Type4X3:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class="line">            break;</div><div class="line">        case TypeFullScreen:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    self.previewlayer.frame = rect;</div><div class="line">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-开始采集画面"><a href="#5-开始采集画面" class="headerlink" title="5. 开始采集画面"></a>5. 开始采集画面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.session startRunning];</div></pre></td></tr></table></figure>
<h4 id="6-开始录制"><a href="#6-开始录制" class="headerlink" title="6.开始录制"></a>6.开始录制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)writeDataTofile</div><div class="line">&#123;</div><div class="line">    NSString *videoPath = [self createVideoFilePath];</div><div class="line">    self.videoUrl = [NSURL fileURLWithPath:videoPath];</div><div class="line">    [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-AVCaptureSession-AVAssetWriter"><a href="#3-AVCaptureSession-AVAssetWriter" class="headerlink" title="3.AVCaptureSession+AVAssetWriter"></a>3.AVCaptureSession+AVAssetWriter</h3><p>流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 创建捕捉会话</div><div class="line">2. 设置视频的输入 和 输出</div><div class="line">3. 设置音频的输入 和 输出</div><div class="line">4. 添加视频预览层</div><div class="line">5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div><div class="line">6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。</div></pre></td></tr></table></figure></p>
<h4 id="1-创建捕捉会话"><a href="#1-创建捕捉会话" class="headerlink" title="1. 创建捕捉会话"></a>1. 创建捕捉会话</h4><p>需要确保在同一个队列，最好队列只创建一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.session = [[AVCaptureSession alloc] init];</div><div class="line">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class="line">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-设置视频的输入-和-输出"><a href="#2-设置视频的输入-和-输出" class="headerlink" title="2.设置视频的输入 和 输出"></a>2.设置视频的输入 和 输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)setUpVideo</div><div class="line">&#123;</div><div class="line">    // 2.1 获取视频输入设备(摄像头)</div><div class="line">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class="line">    // 2.2 创建视频输入源</div><div class="line">    NSError *error=nil;</div><div class="line">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class="line">    // 2.3 将视频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">        [self.session addInput:self.videoInput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.videoOutput = [[AVCaptureVideoDataOutput alloc] init];</div><div class="line">    self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES</div><div class="line">    [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class="line">    if ([self.session canAddOutput:self.videoOutput]) &#123;</div><div class="line">        [self.session addOutput:self.videoOutput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-设置音频的输入-和-输出"><a href="#3-设置音频的输入-和-输出" class="headerlink" title="3. 设置音频的输入 和 输出"></a>3. 设置音频的输入 和 输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)setUpAudio</div><div class="line">&#123;</div><div class="line">    // 2.2 获取音频输入设备</div><div class="line">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class="line">    NSError *error=nil;</div><div class="line">    // 2.4 创建音频输入源</div><div class="line">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class="line">    // 2.6 将音频输入源添加到会话</div><div class="line">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class="line">        [self.session addInput:self.audioInput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.audioOutput = [[AVCaptureAudioDataOutput alloc] init];</div><div class="line">    [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class="line">    if([self.session canAddOutput:self.audioOutput]) &#123;</div><div class="line">        [self.session addOutput:self.audioOutput];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-添加视频预览层"><a href="#4-添加视频预览层" class="headerlink" title="4. 添加视频预览层"></a>4. 添加视频预览层</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class="line">&#123;</div><div class="line">    CGRect rect = CGRectZero;</div><div class="line">    switch (type) &#123;</div><div class="line">        case Type1X1:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class="line">            break;</div><div class="line">        case Type4X3:</div><div class="line">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class="line">            break;</div><div class="line">        case TypeFullScreen:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            rect = [UIScreen mainScreen].bounds;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.previewlayer.frame = rect;</div><div class="line">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-开始采集画面-1"><a href="#5-开始采集画面-1" class="headerlink" title="5. 开始采集画面"></a>5. 开始采集画面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.session startRunning];</div></pre></td></tr></table></figure>
<h4 id="6-初始化AVAssetWriter"><a href="#6-初始化AVAssetWriter" class="headerlink" title="6. 初始化AVAssetWriter"></a>6. 初始化AVAssetWriter</h4><p>AVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setUpWriter</div><div class="line">&#123;</div><div class="line">    self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]];</div><div class="line">    self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType];</div><div class="line">    self.writeManager.delegate = self;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="7-拿到数据流后处理"><a href="#7-拿到数据流后处理" class="headerlink" title="7.拿到数据流后处理"></a>7.拿到数据流后处理</h4><p>视频数据和音频数据需要分开处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        //视频</div><div class="line">        if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) &#123;</div><div class="line">            </div><div class="line">            if (!self.writeManager.outputVideoFormatDescription) &#123;</div><div class="line">                @synchronized(self) &#123;</div><div class="line">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">                    self.writeManager.outputVideoFormatDescription = formatDescription;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                @synchronized(self) &#123;</div><div class="line">                    if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class="line">                        [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo];</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //音频</div><div class="line">        if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) &#123;</div><div class="line">            if (!self.writeManager.outputAudioFormatDescription) &#123;</div><div class="line">                @synchronized(self) &#123;</div><div class="line">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">                    self.writeManager.outputAudioFormatDescription = formatDescription;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            @synchronized(self) &#123;</div><div class="line">                </div><div class="line">                if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class="line">                    [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们拿到最原始的数据以后，可以对其进行各种参数的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (void)setUpWriter</div><div class="line">&#123;</div><div class="line">    self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil];</div><div class="line">    //写入视频大小</div><div class="line">    NSInteger numPixels = self.outputSize.width * self.outputSize.height;</div><div class="line">    //每像素比特</div><div class="line">    CGFloat bitsPerPixel = 6.0;</div><div class="line">    NSInteger bitsPerSecond = numPixels * bitsPerPixel;</div><div class="line">    </div><div class="line">    // 码率和帧率设置</div><div class="line">    NSDictionary *compressionProperties = @&#123; AVVideoAverageBitRateKey : @(bitsPerSecond),</div><div class="line">                                             AVVideoExpectedSourceFrameRateKey : @(30),</div><div class="line">                                             AVVideoMaxKeyFrameIntervalKey : @(30),</div><div class="line">                                             AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel &#125;;</div><div class="line">    </div><div class="line">    //视频属性</div><div class="line">    self.videoCompressionSettings = @&#123; AVVideoCodecKey : AVVideoCodecH264,</div><div class="line">                                       AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,</div><div class="line">                                       AVVideoWidthKey : @(self.outputSize.height),</div><div class="line">                                       AVVideoHeightKey : @(self.outputSize.width),</div><div class="line">                                       AVVideoCompressionPropertiesKey : compressionProperties &#125;;</div><div class="line"></div><div class="line">    _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];</div><div class="line">    //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据</div><div class="line">    _assetWriterVideoInput.expectsMediaDataInRealTime = YES;</div><div class="line">    _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0);</div><div class="line">    </div><div class="line">    </div><div class="line">    // 音频设置</div><div class="line">    self.audioCompressionSettings = @&#123; AVEncoderBitRatePerChannelKey : @(28000),</div><div class="line">                                       AVFormatIDKey : @(kAudioFormatMPEG4AAC),</div><div class="line">                                       AVNumberOfChannelsKey : @(1),</div><div class="line">                                       AVSampleRateKey : @(22050) &#125;;</div><div class="line">    </div><div class="line">    </div><div class="line">    _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings];</div><div class="line">    _assetWriterAudioInput.expectsMediaDataInRealTime = YES;</div><div class="line">    </div><div class="line">    </div><div class="line">    if ([_assetWriter canAddInput:_assetWriterVideoInput]) &#123;</div><div class="line">        [_assetWriter addInput:_assetWriterVideoInput];</div><div class="line">    &#125;else &#123;</div><div class="line">        NSLog(@&quot;AssetWriter videoInput append Failed&quot;);</div><div class="line">    &#125;</div><div class="line">    if ([_assetWriter canAddInput:_assetWriterAudioInput]) &#123;</div><div class="line">        [_assetWriter addInput:_assetWriterAudioInput];</div><div class="line">    &#125;else &#123;</div><div class="line">        NSLog(@&quot;AssetWriter audioInput Append Failed&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.writeState = FMRecordStateRecording;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。</p>
<h3 id="fileOut和writer的相同点和不同点"><a href="#fileOut和writer的相同点和不同点" class="headerlink" title="fileOut和writer的相同点和不同点"></a>fileOut和writer的相同点和不同点</h3><p>从上面的两个流程大致可以看出来，<br>相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。<br>不同点：<br>输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。<br>AVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。</p>
<p>可配参数不一致，AVAssetWriter可以配置更多的参数。</p>
<p>视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。</p>
<p>其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。</p>
<p><a href="https://github.com/suifengqjn/VideoRecord" target="_blank" rel="external">demo地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先附上参考资料&quot;&gt;&lt;a href=&quot;#先附上参考资料&quot; class=&quot;headerlink&quot; title=&quot;先附上参考资料&quot;&gt;&lt;/a&gt;先附上参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/16cb14f53933&quot;&gt;http://www.jianshu.com/p/16cb14f53933&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html&quot;&gt;https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/objcio/VideoCaptureDemo&quot;&gt;https://github.com/objcio/VideoCaptureDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gsixxxx/DTSmallVideo&quot;&gt;https://github.com/gsixxxx/DTSmallVideo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AndyFightting/VideoRecord&quot;&gt;https://github.com/AndyFightting/VideoRecord&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;卷首吐槽语&quot;&gt;&lt;a href=&quot;#卷首吐槽语&quot; class=&quot;headerlink&quot; title=&quot;卷首吐槽语&quot;&gt;&lt;/a&gt;卷首吐槽语&lt;/h3&gt;&lt;p&gt;这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。&lt;/p&gt;
&lt;p&gt;先附上dome &lt;a href=&quot;https://github.com/suifengqjn/VideoRecord&quot;&gt;demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;脑图&quot;&gt;&lt;a href=&quot;#脑图&quot; class=&quot;headerlink&quot; title=&quot;脑图&quot;&gt;&lt;/a&gt;脑图&lt;/h3&gt;&lt;p&gt;方便大家对三中录制方式有一个大概的了解，看一下这张图片。&lt;br&gt;&lt;img src=&quot;https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true&quot; alt=&quot;基本属性与类&quot;&gt;&lt;br&gt;第一种采用系统的录制较为简单，详细介绍后面两种。&lt;br&gt;
    
    </summary>
    
      <category term="iOS技术" scheme="http://gcblog/github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://gcblog/github.io/tags/iOS/"/>
    
      <category term="视频" scheme="http://gcblog/github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="录制视频" scheme="http://gcblog/github.io/tags/%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
