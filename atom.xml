<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code随手记</title>
  <subtitle>Practice from here</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gcblog/github.io/"/>
  <updated>2019-03-16T08:11:02.832Z</updated>
  <id>http://gcblog/github.io/</id>
  
  <author>
    <name>夜千寻墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tendermint多节点组网</title>
    <link href="http://gcblog/github.io/2019/03/16/tendermint%E5%A4%9A%E8%8A%82%E7%82%B9%E7%BB%84%E7%BD%91/"/>
    <id>http://gcblog/github.io/2019/03/16/tendermint多节点组网/</id>
    <published>2019-03-16T08:09:45.000Z</published>
    <updated>2019-03-16T08:11:02.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多节点组网概述"><a href="#多节点组网概述" class="headerlink" title="多节点组网概述"></a>多节点组网概述</h2><p>在之前的课程内容中，我们的关注点集中在单一节点上的状态机逻辑实现上，这是因为 状态机复制的问题，是由tendermint负责完成的：我们在任何一个节点提交的交易请求， tendermint可以透明地帮我们在多个节点间实现同步。</p>
<p>在这一章，我们将通过前面已经学习过的简单的ABCI计数应用来学习如何部署多个tendermint节点， 并进一步理解tendermint共识的建立过程。为了简化操作，我们将首先了解如何将ABCI 应用与tendermint库集成为单一可执行文件，然后利用这个单一完整的程序来部署4个 节点旳区块链：</p>
<p><img src="https://lh3.googleusercontent.com/-IQliQxXjyMM/XAiKyzlDVUI/AAAAAAAAEJE/_L0D3hPCKA4or_0B2M6bZAObHHabnLt_gCHMYCw/I/networking.png" alt="networking"></p>
<a id="more"></a>
<p>在tendermint节点组成的区块链中有两种节点：验证节点和观察节点，只有验证节点 参与共识的建立。在这一章，我们将同时学习如何部署验证节点和观察节点。</p>
<p>tendermint是拜占庭容错的共识机制，因此在3f+1个验证节点中，允许不超过f个节点 出现拜占庭错误。在活性与可靠性中tendermint选择了可靠性，因此当3f+1个节点中 超过f个节点出现拜占庭错误后，整个系统将停机，我们也将通过实验观察到这一点。</p>
<h2 id="实现abci接口"><a href="#实现abci接口" class="headerlink" title="实现abci接口"></a>实现abci接口</h2><p>使用go语言开发tendermint链上应用有一个额外的优势，就是可以将tendermint节点 与ABCI应用集成在单一程序内发布。</p>
<p>我们还是使用计数状态机作为ABCI应用示例，在多个节点之间维护单一的计数值：</p>
<p><img src="https://lh3.googleusercontent.com/-LdBVIwAtCoE/XAiKycP9UxI/AAAAAAAAEI4/B1Qm3FrafDgBd0iSK2jRhbAgGB9JxblkgCHMYCw/I/sm-counter.png" alt="sm-counte"></p>
<p>为简化问题，我们仅实现三个主要的ABCI接口 —— CheckTx、DeliverTx和Query， 同时，使用0x01~0x03分别表示递增、递减和复位交易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type App struct &#123;</span><br><span class="line">  types.BaseApplication</span><br><span class="line">  Value int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (app *App) CheckTx(tx []byte) (rsp types.ResponseCheckTx) &#123;</span><br><span class="line">  if tx[0] &lt; 0x04 &#123;  return &#125;</span><br><span class="line">  rsp.Code = 1</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (app *App) DeliverTx(tx []byte) (rsp types.ResponseDeliverTx) &#123;</span><br><span class="line">  switch tx[0] &#123;</span><br><span class="line">    case 0x01 : app.Value += 1</span><br><span class="line">    case 0x02 : app.Value -= 1</span><br><span class="line">    case 0x03 : app.Value = 0</span><br><span class="line">  &#125;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (app *App) Query(req types.RequestQuery) (rsp types.ResponseQuery) &#123;</span><br><span class="line">  rsp.Log = fmt.Sprintf(&quot;counter: %d&quot;,app.Value)</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以查看~/repo/go/src/hubwiz.com/c8/smr.go中的完整示例代码。</p>
<h2 id="命令行封装：cobra子命令"><a href="#命令行封装：cobra子命令" class="headerlink" title="命令行封装：cobra子命令"></a>命令行封装：cobra子命令</h2><p>Tendermint的命令行程序是基于spf13/cobra开发包开发的，每个子命令都对应着 一个cobra/Command结构的实例，例如，初始化节点子命令init对应着InitFilesCmd这个 对象，而RootCmd则对应着根命令：</p>
<p><img src="https://lh3.googleusercontent.com/-6-_bcE_nev0/XAiKyzyxyxI/AAAAAAAAEJA/UY8WkMKnBs4Hw5f_A5bZYyunJcUAaxpOQCHMYCw/I/cobra-commands.png" alt="cobra-commands"></p>
<p>因此我们可以利用这些封装好的cobra命令，非常快速地生成一个具有节点同样功能 的命令行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">  root := commands.RootCmd</span><br><span class="line"></span><br><span class="line">  root.AddCommand(commands.InitFilesCmd) </span><br><span class="line">  root.AddCommand(commands.ResetAllCmd)</span><br><span class="line"></span><br><span class="line">  exec := cli.PrepareBaseCmd(root,&quot;WIZ&quot;,&quot;.&quot;)</span><br><span class="line">  exec.Execute()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PrepareBaseCmd()方法将指定的Command实例转换为一个Executor对象，它进行 必要的环境变量设置（根据第二个参数指定的前缀），并确定命令行的默认工作目录 （第三个参数）。</p>
<p>在上面代码中，我们将默认工作目录设置为当前目录，这意味着在默认情况下， 当执行init子命令时，将在当前目录下生成data和config子目录。不过在RootCmd 中定义了全局标志–home，可以在命令行指定其他目录为节点工作目录。例如， 下面的代码将在当前目录下的n1子目录中执行初始化命令：</p>
<p>~/repo/go/src/hubwiz.com/c8$ go run smr.go init –home n1</p>
<h2 id="实现节点提供器"><a href="#实现节点提供器" class="headerlink" title="实现节点提供器"></a>实现节点提供器</h2><p>与其他cobra命令不同，用于启动节点旳node子命令对应于一个NewRunNodeCmd()方法， 它是一个构建cobra/Command实例的工厂方法，需要传入一个NodeProvider类型的变量：</p>
<p><img src="https://lh3.googleusercontent.com/-QIVWms97fOc/XAiKy3D_JqI/AAAAAAAAEJI/DWXhB9C_VbgqV4lIWlrtIh2KU4yzUacswCHMYCw/I/node-provider.png" alt="node-provide"></p>
<p>NodeProvider其实是返回节点实例的函数，其原型定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type NodeProvider func(config *cfg.Config, logger log.Logger) (*node.Node, error)</span><br></pre></td></tr></table></figure></p>
<p>其中，参数config（节点配置）和logger（日志）都是由tendermint框架在启动时传入的参数。</p>
<p>NodeProvider是基于具体的abci应用创建的。例如，下面的代码利用abci应用实例创建一个 NodeProvider实例，并最终得到cobra/Command实例添加到根命令中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app := NewApp()</span><br><span class="line">nodeProvider := makeNodeProvider(app)</span><br><span class="line">root.AddCommand(commands.NewRunNodeCmd(nodeProvider))</span><br></pre></td></tr></table></figure></p>
<p>makeNodeProvider()函数返回NodeProvider实例，其实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func makeNodeProvider(app types.Application) node.NodeProvider &#123;</span><br><span class="line">  return func(config *cfg.Config, logger log.Logger) (*node.Node, error) &#123;</span><br><span class="line">      nodeKey, err := p2p.LoadOrGenNodeKey(config.NodeKeyFile())</span><br><span class="line">      if err != nil &#123;  return nil, err &#125;</span><br><span class="line"></span><br><span class="line">      return node.NewNode(config,</span><br><span class="line">          privval.LoadOrGenFilePV(config.PrivValidatorFile()),</span><br><span class="line">          nodeKey,</span><br><span class="line">          proxy.NewLocalClientCreator(app),</span><br><span class="line">          node.DefaultGenesisDocProviderFunc(config),</span><br><span class="line">          node.DefaultDBProvider,</span><br><span class="line">          node.DefaultMetricsProvider(config.Instrumentation),</span><br><span class="line">          logger)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译安装</p>
<p>在整合了abci应用和cobra命令代码后，为了简化后续的键盘输入，我们将其 编译安装：</p>
<p>~/repo/go/src/hubwiz.com/c8$ go install smr.go<br>现在可以很简单地执行节点程序：</p>
<p>~/repo/go/hubwiz.com/c8$ smr</p>
<h2 id="单节点实验"><a href="#单节点实验" class="headerlink" title="单节点实验"></a>单节点实验</h2><p>Tendermint支持两种类型的节点：验证节点（Validator）和观察节点（Observer）。显然，对于 网络中的第一个节点而言，必须是一个验证节点 —— 否则没有办法出块了：</p>
<p><img src="https://lh3.googleusercontent.com/-J3veWjCNVXo/XAiKy6UgyhI/AAAAAAAAEJU/uionNNfOwAgpf5sxt1mMtgfbvsGPPYJ5ACHMYCw/I/node-provider-1.png" alt="node-provide"></p>
<p>第一个节点旳基本参数是：</p>
<p>P2P通信端口：26656<br>RPC服务端口：26657<br>节点目录：n1<br>节点初始化与启动</p>
<p>进入1#终端，执行init子命令初始化第一个节点，注意使用–home标志指定节点目录：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr init –home n1<br>执行show_node_id子命令显示并记录第一个节点旳ID：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr show_node_id –home n1<br>输出结果为节点旳ID，我们后续会用到，请记下来（你的ID应该与此不同）：</p>
<p>fd8debec2b97adfa0f6e8bae939c22a69cda9741<br>然后执行node子命令启动第一个节点：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr node –home n1<br>测试状态机交易</p>
<p>进入2#终端，执行如下交易并分别查询：</p>
<p>增加：</p>
<p>~$ curl localhost:26657/broadcast_tx_commit?tx=0x0101<br>~$ curl localhost:26657/abci_query<br>减少：</p>
<p>~$ curl localhost:26657/broadcast_tx_commit?tx=0x0201<br>~$ curl localhost:26657/abci_query<br>复位：</p>
<p>~$ curl localhost:26657/broadcast_tx_commit?tx=0x0301<br>~$ curl localhost:26657/abci_query</p>
<h2 id="添加观察节点"><a href="#添加观察节点" class="headerlink" title="添加观察节点"></a>添加观察节点</h2><p>现在我们在网络中添加一个观察节点，它不会参与到共识的建立：</p>
<p><img src="https://lh3.googleusercontent.com/-6FX6ojIAJGk/XAiKy3hhulI/AAAAAAAAEJQ/nbWe11We7jYcLFYjbDtnuWnBLDgLcQVywCHMYCw/I/two-node.png" alt="two-node"></p>
<p>第二个节点旳基本参数是：</p>
<p>P2P通信端口：36656<br>RPC服务端口：36657<br>节点目录：n2<br>节点初始化配置与启动</p>
<p>进入2#终端，执行init子命令初始化第二个节点：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr init –home n2<br>由于这个节点是观察节点，因此我们可以直接使用验证节点旳创世文件：</p>
<p>~/repo/go/src/hubwiz.com/c8$ cp n1/config/genesis.json n2/config/genesis.json<br>同时修改n2/config/config.toml，设置其rpc监听端口为36657，p2p监听端口为36656， 并使其主动连接第一个节点，其中fd8d…41为第一个节点旳ID（使用show_node_id 子命令获取）：</p>
<p>[rpc]<br>laddr = “tcp://0.0.0.0:36657”</p>
<p>[p2p]<br>laddr = “tcp://0.0.0.0:36656”<br>persistent_peers = “fd8debec2b97adfa0f6e8bae939c22a69cda9741@127.0.0.1:26656”<br>现在2#终端启动第二个节点：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr node –home n2<br>交易测试</p>
<p>无论利用哪个节点提交交易，都可以保证所有的节点状态同步。</p>
<p>首先在5#终端分别查看节点一和节点二的状态：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:26657/abci_query<br>~/repo/go/src/hubwiz.com/c8$ curl localhost:36657/abci_query<br>然后利用节点一的rpc接口提交交易：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:26657/broadcast_tx_commit?tx=0x01<br>再次查看节点一和节点二的状态，你可以观察到同样的最新状态</p>
<p>停机测试</p>
<p>由于我们只有一个验证节点，显然当该节点停机时，整个集群将无法达成共识。</p>
<p>首先在1#终端按ctrl+c停止smr的运行，然后在5#终端通过节点二提交交易：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:26657/broadcast_tx_commit?tx=0x01<br>该命令会一直挂起直至超时，因为交易始终无法确认。</p>
<h2 id="添加验证节点"><a href="#添加验证节点" class="headerlink" title="添加验证节点"></a>添加验证节点</h2><p>现在我们继续向网络中添加第三个节点，这次是一个验证节点：</p>
<p><img src="https://lh3.googleusercontent.com/-VYm-WaO9dHE/XAiKy1xsZ3I/AAAAAAAAEJM/9pNl8Dmi1U0-bQVpe9Kum7u0S7eSyx1egCHMYCw/I/three-node.png" alt="three-node"></p>
<p>第三个节点旳基本参数是：</p>
<p>P2P通信端口：46656<br>RPC服务端口：46657<br>节点目录：n3<br>节点初始化配置与启动</p>
<p>进入3#终端，执行init子命令初始化节点三的目录n3：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr init –home n3<br>由于这个节点是验证节点，因此我们需要在节点一现有的创世文件中添加该节点 的priv_validator.json文件中的公钥和地址，其中每个验证节点旳power值用来 表征其代表的权益：</p>
<p><img src="https://lh3.googleusercontent.com/-fXLrdNs4gFg/XAiKy2Jg0DI/AAAAAAAAEJY/T6ME5vG5RB8Bg55jhlYolz4J42uvRv7wgCHMYCw/I/validator-genesis.png" alt="validator-genesis"></p>
<p>在上面的配置中，由于每个节点旳power都是10，因此每个节点都有50%（10/(10+10)） 的机率出块。</p>
<p>然后将新的创世文件分发给节点二和节点三：</p>
<p>~/repo/go/src/hubwiz.com/c8$ cp n1/config/genesis.json n2/config/genesis.json<br>~/repo/go/src/hubwiz.com/c8$ cp n1/config/genesis.json n3/config/genesis.json<br>同时修改n3/config/config.toml，设置其rpc监听端口为46657，p2p监听端口为46656， 并使其主动连接第一个节点，其中fd8d…41为第一个节点旳ID（使用show_node_id 子命令获取）：</p>
<p>[rpc]<br>laddr = “tcp://0.0.0.0:46657”</p>
<p>[p2p]<br>laddr = “tcp://0.0.0.0:46656”<br>persistent_peers = “fd8debec2b97adfa0f6e8bae939c22a69cda9741@127.0.0.1:26656”<br>现在3#终端启动第二个节点：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr node –home n3<br>交易测试</p>
<p>无论利用哪个节点提交交易，都可以保证所有的节点状态同步。</p>
<p>首先在5#终端分别查看三个节点的状态：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:26657/abci_query<br>~/repo/go/src/hubwiz.com/c8$ curl localhost:36657/abci_query<br>然后利用节点一的rpc接口提交交易：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:26657/broadcast_tx_commit?tx=0x0101<br>再次查看三个节点的状态，你可以观察到同样的最新状态</p>
<p>停机测试</p>
<p>由于3f+1个验证节点中，才允许f个发生拜占庭故障，因此两个验证节点旳任一个 出现故障，整个集群都将停止共识。</p>
<p>首先在3#终端按ctrl+c停止smr的运行，然后在5#终端通过节点二提交交易：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:36657/broadcast_tx_commit?tx=0x0102<br>该命令会一直挂起直至超时，因为交易始终无法确认。</p>
<p>但是观测节点旳停机不会影响共识的达成。</p>
<h2 id="拜占庭容错实验"><a href="#拜占庭容错实验" class="headerlink" title="拜占庭容错实验"></a>拜占庭容错实验</h2><p>现在我们添加第四个节点，并将全部节点都设置为验证节点，来测试当其中某个 节点故障时，系统的容错能力：</p>
<p><img src="https://lh3.googleusercontent.com/-NpKjViMnInQ/XAiKy_bwM2I/AAAAAAAAEI8/XVKIhvA8Y4s_d6ctYlOUqyhDKkTEmIZaQCHMYCw/I/four-node.png" alt="four-node"></p>
<p>第四个节点旳基本参数是：</p>
<p>P2P通信端口：56656<br>RPC服务端口：56657<br>节点目录：n4<br>节点初始化配置与启动</p>
<p>进入1#终端，首先初始化第四个节点目录：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr init –home n4<br>修改节点一的创世文件，将其他三个节点的priv_validator.json文件中的公钥和地址 添加进去，然后将新的创世文件分发给其他节点</p>
<p>~/repo/go/src/hubwiz.com/c8$ cp n1/config/genesis.json n2/config/genesis.json<br>~/repo/go/src/hubwiz.com/c8$ cp n1/config/genesis.json n3/config/genesis.json<br>~/repo/go/src/hubwiz.com/c8$ cp n1/config/genesis.json n4/config/genesis.json<br>同时修改节点2/3/4的config/config.toml，设置其rpc监听端口分别为36657/46657/56657， p2p监听端口分别为36656/46656/56656，并使其主动连接第一个节点，其中fd8d…41为第一 个节点旳ID（使用show_node_id子命令获取）。以节点2为例：</p>
<p>[rpc]<br>laddr = “tcp://0.0.0.0:56657”</p>
<p>[p2p]<br>laddr = “tcp://0.0.0.0:56656”<br>persistent_peers = “fd8debec2b97adfa0f6e8bae939c22a69cda9741@127.0.0.1:26656”<br>分别在四个终端启动四个目录对应的节点，例如，在2#终端启动节点2：</p>
<p>~/repo/go/src/hubwiz.com/c8$ smr node –home n2<br>容错测试</p>
<p>由于3f+1个验证节点中，允许f个发生拜占庭故障，因此我们的四个节点旳小集群， 允许任一个出现拜占庭错误。</p>
<p>首先在1#终端按ctrl+c停止smr的运行，然后在5#终端通过节点二提交交易：</p>
<p>~/repo/go/src/hubwiz.com/c8$ curl localhost:36657/broadcast_tx_commit?tx=0x0101<br>可以观察到交易正常完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多节点组网概述&quot;&gt;&lt;a href=&quot;#多节点组网概述&quot; class=&quot;headerlink&quot; title=&quot;多节点组网概述&quot;&gt;&lt;/a&gt;多节点组网概述&lt;/h2&gt;&lt;p&gt;在之前的课程内容中，我们的关注点集中在单一节点上的状态机逻辑实现上，这是因为 状态机复制的问题，是由tendermint负责完成的：我们在任何一个节点提交的交易请求， tendermint可以透明地帮我们在多个节点间实现同步。&lt;/p&gt;
&lt;p&gt;在这一章，我们将通过前面已经学习过的简单的ABCI计数应用来学习如何部署多个tendermint节点， 并进一步理解tendermint共识的建立过程。为了简化操作，我们将首先了解如何将ABCI 应用与tendermint库集成为单一可执行文件，然后利用这个单一完整的程序来部署4个 节点旳区块链：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-IQliQxXjyMM/XAiKyzlDVUI/AAAAAAAAEJE/_L0D3hPCKA4or_0B2M6bZAObHHabnLt_gCHMYCw/I/networking.png&quot; alt=&quot;networking&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>tendermint多版本状态库</title>
    <link href="http://gcblog/github.io/2019/03/16/tendermint%E5%A4%9A%E7%89%88%E6%9C%AC%E7%8A%B6%E6%80%81%E5%BA%93/"/>
    <id>http://gcblog/github.io/2019/03/16/tendermint多版本状态库/</id>
    <published>2019-03-16T07:51:36.000Z</published>
    <updated>2019-03-16T07:54:01.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="平衡二叉树简介"><a href="#平衡二叉树简介" class="headerlink" title="平衡二叉树简介"></a>平衡二叉树简介</h2><p>在之前的课程中，我们简单地使用磁盘文件来保存状态，对于简单的学习或验证 而言没有问题，但在生产环境中，tendermint推荐我们使用其基于avl树实现的 多版本状态库。</p>
<p>avl树得名于发明者G. M. Adelson-Velsky和Evgenii Landis，它是一种 自平衡二叉检索树，这包括两个核心的思想：二叉、平衡。</p>
<p>二叉是指整棵树中每个节点最多有两个子节点，左侧的子节点值一定小于父节点值，而 右侧的子节点值一定大于父节点值，二叉树的主要用途是进行数据检索：当查找指定的数值时， 只需要逐层与节点值比较即可快速定位，因此被称为二叉检索树。</p>
<p>例如，下图就是一个典型的二叉检索树，每个节点列出了其表示的值：</p>
<p><img src="https://lh3.googleusercontent.com/-rHf4N7nhTT4/XAiKtnjwMUI/AAAAAAAAEIs/6z6NO6fWTgArP6et8QUQOwKDpDoFzuqEwCHMYCw/I/btree.png" alt="btree"></p>
<a id="more"></a>
<p>当我们需要在树中定位值为19的节点时，从根节点出发，只需要三次对比就可以定位：</p>
<p>10 &lt; 50，因此进入50的左侧子树继续搜索<br>19 &gt; 17，因此进入17的右侧子树继续搜索<br>19 &lt; 23，因此进入23的左侧子树继续搜索<br>19 == 19，定位成功<br>平衡是指树中任一节点旳左右两棵子树的高度差不超过1。例如，上面的树就不是平衡的， 该数据集对应的平衡树如下图所示：<br><img src="https://lh3.googleusercontent.com/-jFPbOluKdTw/XAiKtitKN9I/AAAAAAAAEIo/bSuESPU3WLcxYZilQGWodK64kHtcYR4ugCHMYCw/I/avl-tree.png" alt="avl-tree"></p>
<p>自平衡指的是树的形成算法：当一个新的节点加入树树中时，算法将通过旋转等手段使整棵树 始终处于平衡状态，因此看起来就树就是靠自己找到了平衡状态。</p>
<h2 id="多版本状态库-avl-merkle"><a href="#多版本状态库-avl-merkle" class="headerlink" title="多版本状态库 avl + merkle"></a>多版本状态库 avl + merkle</h2><p>为了快速计算状态集合的哈希以及进行默克尔验证，基于avl树和merkle树，tendermint实现了 多版本状态库iavl，它提供了类似于key/value数据库的操作接口：</p>
<p><img src="https://lh3.googleusercontent.com/-sFxNq1F_rOw/XAiKtoUzI7I/AAAAAAAAEIk/GqXQ9hPM4GE5vgLPR-4-06bfaUWy8cKEwCHMYCw/I/iavl-store.png" alt="iavl-store"></p>
<p>为了便于计算默克尔哈希，在tendermint的avl树实现中，只有在叶节点中才会保存实际的状态值， 中间节点仅用于key的比较和哈希的计算。由于在所有节点中已经预存了左右子节点的哈希，因此可以 快速获取整棵树的根节点哈希，即状态集合的哈希。</p>
<p>iavl支持同一个key值的多个版本，这通过在节点结构中引入version项来实现：当一个节点被新版本 的数据更新后，iavl会同时保留其历史版本，因此使用iavl可以快速回溯到任何状态的任意历史版本。</p>
<p>安装iavl：</p>
<p><code>~$ go get github.com/tendermint/iavl</code></p>
<h2 id="使用多版本状态库"><a href="#使用多版本状态库" class="headerlink" title="使用多版本状态库"></a>使用多版本状态库</h2><p><code>tendermint/iavl</code>软件包的主要模型包括可修改树（MutableTree）、只读树（ImmutableTree） 以及状态证据（RangeProof）等，其关系如下图所示：</p>
<p><img src="https://lh3.googleusercontent.com/-utrzL2D_xEo/XAiKtuuxMbI/AAAAAAAAEIw/BWqJlNQvztg8WARM_tuGBVYp2acu-HIBACHMYCw/I/iavl-uml.png" alt="iavl-um"></p>
<p>ImmutableTree是一个只读的二叉平衡哈希树，而MutableTree则提供了Set()方法来修改树 的节点构成并保证其处于平衡状态，RangeProof则是默克尔证据的封装结构。</p>
<p>加载状态库</p>
<p>iavl使用leveldb数据库保存节点以及其关系，例如，下面的代码从当前目录下的 counter数据库加载状态库，并使用Load()方法将载入最后版本的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb,_ := db.NewGoLevelDB(&quot;counter&quot;,&quot;.&quot;)</span><br><span class="line">tree := iavl.NewMutableTree(gdb,128)</span><br><span class="line">tree.Load()</span><br></pre></td></tr></table></figure></p>
<p>工作区</p>
<p>类似于git，iavl也有一个工作区的概念 —— 所有的修改操作都是在工作区完成的，而不是 直接操作状态库。可以使用Load()方法载入最后（新）版本的状态库到工作区，也可以使用 LoadVersion()方法载入指定版本的状态库到工作区。</p>
<p>一旦将状态载入工作区，我们就可以利用Set()方法设置指定的键/值对了。例如，下面的 代码设置键name的值为tommy：</p>
<p><code>tree.Set([]byte(&quot;name&quot;),[]byte(&quot;Tommy&quot;))</code><br>当我们调用Get()方法时，是从当前工作区中读取指定键的值，例如：</p>
<p><code>idx,val := tree.Get([]byte(&quot;name&quot;))</code><br>其中，返回的idx表示该键对应的叶节点在集合中的先后序号，val表示键对应的值。</p>
<p>如果需要从状态库中指定版本读取键值，可以使用GetVersioned()方法。例如， 下面的代码读取版本2的指定键值：</p>
<p><code>idx,val := tree.GetVersioned([]byte{&quot;name&quot;},2)</code><br>提交新版本</p>
<p>所有的修改完毕后，使用SaveVersion()方法将工作区的变更提交到库中，这将返回根节点 哈希和新的版本号：</p>
<p><code>hash,ver,err := tree.SaveVersion()</code><br>iavl库的版本号是从0开始，每个版本加1。</p>
<h2 id="封装iavl操作"><a href="#封装iavl操作" class="headerlink" title="封装iavl操作"></a>封装iavl操作</h2><p>为了简化iavl的操作，我们将编解码等繁琐的操作封装到一个单独的结构Store里：</p>
<p><img src="https://lh3.googleusercontent.com/-gYAQNNM3JvY/XAiKtnxjzlI/AAAAAAAAEI0/3fDXRZgHpAI07GrntscK1XVw-34-Qn-nQCHMYCw/I/store.png" alt="store"></p>
<p>Store的结构声明如下，除了iavl库，额外的两个成员分别记录状态的最后版本号以及最后 状态的默克尔哈希：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Store struct &#123;</span><br><span class="line">  tree *iavl.MutableTree  //iavl库</span><br><span class="line">  LastVersion int64           //状态的最后版本号</span><br><span class="line">  LastHash []byte             //最后版本状态的根哈希</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GetBalance()方法获取指定地址的当前（最后版本）余额：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (store *Store) GetBalance(addr crypto.Address) (int,error) &#123;</span><br><span class="line">  _,bz := store.tree.Get(addr)</span><br><span class="line">  if bz == nil &#123; return 0,errors.New(&quot;account not found&quot;) &#125;  </span><br><span class="line">  var val int</span><br><span class="line">  err := codec.UnmarshalBinary(bz,&amp;val)</span><br><span class="line">  if err !=nil &#123; return 0,errors.New(&quot;decode error&quot;)&#125;</span><br><span class="line">  return val,nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetBalanceVersoined()方法获取特定版本的指定地址余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (store *Store) GetBalanceVersioned(addr crypto.Address,version int64) (int,error) &#123;</span><br><span class="line">  _,bz := store.tree.GetVersioned(addr,version)</span><br><span class="line">  if bz == nil &#123; return 0,errors.New(&quot;account not found on this version&quot;) &#125;  </span><br><span class="line">  var val int</span><br><span class="line">  err := codec.UnmarshalBinary(bz,&amp;val)</span><br><span class="line">  if err !=nil &#123; return 0,errors.New(&quot;decode error&quot;)&#125;</span><br><span class="line">  return val,nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SetBalance()方法修改指定地址的余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (store *Store) SetBalance(addr crypto.Address,value int) error &#123;</span><br><span class="line">  bz,err := codec.MarshalBinary(value)</span><br><span class="line">  if err != nil &#123; return err &#125;</span><br><span class="line">  store.tree.Set(addr,bz)</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Commit()提交当前工作区的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (store *Store) Commit() &#123;</span><br><span class="line">  hash,ver,err := store.tree.SaveVersion()</span><br><span class="line">  if err != nil &#123; panic(err) &#125;</span><br><span class="line">  store.LastVersion = ver</span><br><span class="line">  store.LastHash = hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="升级代币状态机"><a href="#升级代币状态机" class="headerlink" title="升级代币状态机"></a>升级代币状态机</h2><p>基于Store的封装，很容易为代币状态机加入iavl的支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TokenApp struct &#123;</span><br><span class="line">  types.BaseApplication</span><br><span class="line">  store *Store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转账交易<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) transfer(from,to crypto.Address,value int) error &#123;</span><br><span class="line">  fromBalance,_ := app.store.GetBalance(from)</span><br><span class="line">  if fromBalance &lt; value &#123;return errors.New(&quot;no enough balance&quot;)&#125;</span><br><span class="line">  toBalance,_ := app.GetBalance(to)</span><br><span class="line">  app.SetBalance(from,fromBalance - val)</span><br><span class="line">  app.SetBalance(to,toBalance + val)</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发行交易<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) issue(issuer,to crypto.Address,value int) error &#123;</span><br><span class="line">  if !bytes.Equal(issuer,SYSTEM_ISSUER) return &#123; errors.New(&quot;invalid issuer&quot;) &#125;</span><br><span class="line">  toBalance,_ := app.store.GetBalance(to)</span><br><span class="line">  app.SetBalance(to,toBalance + val)</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现Commit()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) Commit() types.ResponseCommit&#123;</span><br><span class="line">  hash,ver,_ := app.store.Commit()</span><br><span class="line">  app.Version = ver</span><br><span class="line">  app.Hash = hash</span><br><span class="line">  return types.ResponseCommit&#123;Data:hash&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查询状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (app *AccountApp) Query(req types.RequestQuery) types.ResponseQuery&#123;</span><br><span class="line">  if len(req.Data) == 0 &#123;</span><br><span class="line">    return types.ResponseQuery&#123;Code:1,Info:&quot;no address specified&quot;&#125;</span><br><span class="line">  &#125; </span><br><span class="line">  addr := cryto.Address(req.Data)</span><br><span class="line">  val,_:= app.store.GetBalance(addr)</span><br><span class="line">  return types.ResponseQuery&#123;Key:addr,Value:val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;平衡二叉树简介&quot;&gt;&lt;a href=&quot;#平衡二叉树简介&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树简介&quot;&gt;&lt;/a&gt;平衡二叉树简介&lt;/h2&gt;&lt;p&gt;在之前的课程中，我们简单地使用磁盘文件来保存状态，对于简单的学习或验证 而言没有问题，但在生产环境中，tendermint推荐我们使用其基于avl树实现的 多版本状态库。&lt;/p&gt;
&lt;p&gt;avl树得名于发明者G. M. Adelson-Velsky和Evgenii Landis，它是一种 自平衡二叉检索树，这包括两个核心的思想：二叉、平衡。&lt;/p&gt;
&lt;p&gt;二叉是指整棵树中每个节点最多有两个子节点，左侧的子节点值一定小于父节点值，而 右侧的子节点值一定大于父节点值，二叉树的主要用途是进行数据检索：当查找指定的数值时， 只需要逐层与节点值比较即可快速定位，因此被称为二叉检索树。&lt;/p&gt;
&lt;p&gt;例如，下图就是一个典型的二叉检索树，每个节点列出了其表示的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-rHf4N7nhTT4/XAiKtnjwMUI/AAAAAAAAEIs/6z6NO6fWTgArP6et8QUQOwKDpDoFzuqEwCHMYCw/I/btree.png&quot; alt=&quot;btree&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>tendermint默克尔树</title>
    <link href="http://gcblog/github.io/2019/03/16/tendermint%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/"/>
    <id>http://gcblog/github.io/2019/03/16/tendermint默克尔树/</id>
    <published>2019-03-16T05:47:08.000Z</published>
    <updated>2019-03-16T05:49:28.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="默克尔树概述"><a href="#默克尔树概述" class="headerlink" title="默克尔树概述"></a>默克尔树概述</h2><p>在ABCI应用响应Commit请求消息时，需要计算并返回当前状态的哈希，以便Tendermint 将其打包到下一个区块头里（app_hash字段）。</p>
<p>但是，如果我们还按原来的方法计算一个总体哈希，例如：hash: = tmhash.Sum(state)， 就存在一个问题 —— 当查询某个特定账户的状态数据时，如何验证该状态是未被篡改的？</p>
<p>显然，单独返回整个状态的哈希是不够的，但是我们也不可能将整个账户表提供给 客户端以便其重算哈希进行验证，因为其中包含了其他用户的账户信息。</p>
<p>这就是默克尔树（Merkle Tree）的用武之地：不需要提供完整的数据（例如整个账户表）， 就可以验证某个数据（例如账户A的状态）是否属于该数据集。</p>
<p>在默克尔树中，叶节点对应于各状态的哈希值，根节点则对应于整个状态的哈希， 中间各层的节点则分别由前一层节点两两结对后计算哈希得到。</p>
<p>例如，下图给出了4个账户状态时的默克尔树的构成：</p>
<p><img src="https://i.imgur.com/9WsMy8l.png" alt="merkle-tree"></p>
<a id="more"></a>
<p>基于默克尔树的生成过程，我们只需要这个树的一部分节点，就可以验证某个状态（例如账户A 的状态）与整体哈希（Hash(ABCD)）的对应关系，这部分节点就被称为默克尔证据/Merkle Proot。 例如上图中，对于账户A的状态而言，Hash(B)和Hash(CD)就是其证据 —— 因为利用账户A本身的数据， 以及证据节点，就可以重算出根节点，从而确认指定账户状态与给定状态哈希的对应关系。</p>
<h2 id="计算默克尔哈希"><a href="#计算默克尔哈希" class="headerlink" title="计算默克尔哈希"></a>计算默克尔哈希</h2><p>在tendermint中内置了默克尔树的一个简单实现，可以计算有序集合（切片）和无序集合（映射表） 的默克尔树根哈希：</p>
<p><img src="https://i.imgur.com/ShIjNqv.png" alt="merkle-tree"></p>
<p>Hasher接口</p>
<p>使用<code>crypto/merkle</code>包计算数据集合的默克尔哈希，要求集合中的成员实现Hasher接口。例如， 我们使用下面的结构来满足这一需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type sh struct&#123;</span><br><span class="line">  value string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h sh) Hash() []byte &#123;</span><br><span class="line">  return tmhash.Sum([]byte(h.value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以根据集合是有序还是无序，来分别计算其默克尔哈希了。</p>
<p>有序集合的哈希计算</p>
<p>有序集合（例如：切片）中各成员有确定性的先后顺序，因此可以直接使用<code>SimpleHashFromHashers()</code> 方法进行计算。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data := []merkle.Hasher&#123; &amp;sh&#123;&quot;one&quot;&#125;,&amp;sh&#123;&quot;two&quot;&#125;,&amp;sh&#123;&quot;three&quot;&#125;,&amp;sh&#123;&quot;four&quot;&#125; &#125;</span><br><span class="line">hash := merkle.SimpleHashFromHashers(data)</span><br><span class="line">fmt.Printf(&quot;root hash =&gt; %x\n&quot;,hash)</span><br></pre></td></tr></table></figure></p>
<p>无序集合的哈希计算</p>
<p>无序集合（例如：映射表）的各成员没有确定性的先后顺序，因此需要首先进行确定排序，重组为有序 集合后才能使用SimpleHashFromHashers()方法计算该集合的默克尔哈希。对于键类型为string、值类型 为Hasher的映射表而言，可以直接使用SimpleHashFromMap()方法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data := map[string]merkle.Hasher&#123;</span><br><span class="line">  &quot;tom&quot;:&amp;sh&#123;&quot;actor&quot;&#125;,</span><br><span class="line">  &quot;mary&quot;:&amp;sh&#123;&quot;teacher&quot;&#125;,</span><br><span class="line">  &quot;linda&quot;:&amp;sh&#123;&quot;scientist&quot;&#125;,</span><br><span class="line">  &quot;luke&quot;:&amp;sh&#123;&quot;fisher&quot;&#125;&#125;</span><br><span class="line">hash := merkle.SimpleHashFromMap(data)</span><br><span class="line">fmt.Printf(&quot;root hash =&gt; %x\n&quot;,hash)</span><br></pre></td></tr></table></figure></p>
<h2 id="状态的默克尔证据"><a href="#状态的默克尔证据" class="headerlink" title="状态的默克尔证据"></a>状态的默克尔证据</h2><p>在使用默克尔树时，如果需要验证某个数据是否属于一个特定的集合，除了待验证的数据自身， 还需要以下数据：</p>
<p>数据集合的根哈希：表征特定的数据集合<br>数据的默克尔证据：配合待验证数据重算根哈希，以便于给定的根哈希比较<br>tendermint的<code>crypto/merkle</code>包提供了简单的方法返回集合中每个成员对应的默克尔 证据以及集合的根哈希：</p>
<p><img src="https://i.imgur.com/ShIjNqv.png" alt="merkle-tree"><br>数据聚合中每个成员对应的默克尔证据就是一个SimpleProof实例，因此可以直接调用 其Verify()方法进行验证。</p>
<p>同样，获取数据成员的默克尔证据也分为有序集合与无序集合两种情况。</p>
<p>有序集合成员的默克尔证据</p>
<p>使用SimpleProofsFromHashers()方法获取有序集合（例如：切片）中各成员的默克尔证据， 成员必须实现Hasher接口，该方法返回两个值：根哈希以及默克尔证据数组。</p>
<p>还是利用前一节的sh类型，下面的代码展示了如何获取切片中各成员的默克尔证据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data := []sh&#123;sh(&quot;one&quot;),sh(&quot;two&quot;),sh(&quot;three&quot;),sh(&quot;four&quot;)&#125;</span><br><span class="line">root,proofs := merkle.SimpleProofsFromHashers(data)</span><br><span class="line">fmt.Printf(&quot;proof for one =&gt; %+v\n&quot;,proofs[0])</span><br></pre></td></tr></table></figure></p>
<p>在返回结果中的默克尔证据数组，其成员顺序与输入数据一致。</p>
<p>一旦获取了某个数据的默克尔证据、结合数据集合的根哈希，就可以验证这个数据是否属于 给定的根哈希对应的数据集合了。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valid := proofs[0].Verify(</span><br><span class="line">    0,              // 要验证的数据在集合中的序号</span><br><span class="line">    4,              // 集合成员总数</span><br><span class="line">    data[0].Hash(), // 要验证的数据的哈希</span><br><span class="line">    root           // 集合的根哈希)</span><br><span class="line">fmt.Printf(&quot;data[0] is valid? =&gt; %t\n&quot;,valid)</span><br></pre></td></tr></table></figure></p>
<p>无序集合成员的默克尔证据</p>
<p>同样，没有确定性成员顺序的映射表，需要使用SimpleProofsFromMap()方法计算每个 成员的默克尔证据，其返回结果是三个值：根哈希、成员默克尔证据映射表和排序后的 成员键。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data := map[string]sh&#123;</span><br><span class="line">  &quot;tom&quot;:sh(&quot;actor&quot;),</span><br><span class="line">  &quot;mary&quot;:sh(&quot;teacher&quot;),</span><br><span class="line">  &quot;linda&quot;:sh(&quot;scientist&quot;),</span><br><span class="line">  &quot;luke&quot;:sh(&quot;fisher&quot;)&#125;</span><br><span class="line">root,proofs,keys := merkle.SimpleProofsFromMap(data)</span><br><span class="line">fmt.Printf(&quot;proof for tom =&gt; %+v\n&quot;,proofs[&quot;tom&quot;])</span><br></pre></td></tr></table></figure></p>
<p>由于在计算映射表的默克尔证据时首先将无序的键值对转化为了KVPair结构并 进行排序，因此其成员时，也需要首先将其转换为KVPair类型，而不能仅使用键值对 中的值部分：</p>
<p><code>kvpair := merkle.KVPair{Key:[]byte(&quot;tom&quot;),Value: data[&quot;tom&quot;].Hash()}</code><br>然后根据该成员在排序后的顺序号（keys中的位置），进行验证，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valid := proofs[key].Verify(</span><br><span class="line">    3,            // 要验证的数据键在keys中的序号</span><br><span class="line">    4,              // 集合成员总数</span><br><span class="line">    kvpair.Hash(), // 要验证的数据的哈希</span><br><span class="line">    root           // 集合的根哈希)</span><br><span class="line">fmt.Printf(&quot;data[&quot;tom&quot;] is valid? =&gt; %t\n&quot;,valid)</span><br></pre></td></tr></table></figure></p>
<h2 id="升级代币状态机"><a href="#升级代币状态机" class="headerlink" title="升级代币状态机"></a>升级代币状态机</h2><p>基于默克尔树，我们可以升级代币状态机，在hash.go代码中实现与默克尔计算相关 的三个方法：</p>
<p><img src="https://i.imgur.com/RbOVPmV.png" alt="merkle-hash-support"></p>
<p>首先扩展int类型，实现Hasher接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Balance int</span><br><span class="line"></span><br><span class="line">func (b Balance) Hasher() []byte &#123;</span><br><span class="line">  v,_ := codec.MarshalBinary(b)</span><br><span class="line">  return tmhash.Sum(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stateToHasherMap()方法将应用的状态集合转换为Hasher映射表，以便进行默克尔计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) stateToHasherMap() map[string]merkle.Hasher &#123;</span><br><span class="line">  hashers := map[string]merkle.Hasher&#123;&#125;</span><br><span class="line">  for addr,val := range app.Accounts &#123; </span><br><span class="line">    balance := Balance(val)</span><br><span class="line">    hashers[addr] = &amp;balance</span><br><span class="line">  &#125;</span><br><span class="line">  return hashers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getRootHash()方法计算应用状态的默克尔哈希：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) getRootHash() []byte &#123;</span><br><span class="line">  hashers := app.stateToHasherMap()</span><br><span class="line">  return merkle.SimpleHashFromMap(hashers)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getProofBytes()</code>方法获取指定地址状态的默克尔证据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) getProofBytes(addr string) []byte &#123;</span><br><span class="line">  hashers := app.stateToHasherMap()</span><br><span class="line">  _,proofs,_ := merkle.SimpleProofsFromMap(hashers)</span><br><span class="line">  bz,err := codec.MarshalBinary(proofs[addr])</span><br><span class="line">  if err != nil  &#123; return  []byte&#123;&#125; &#125;</span><br><span class="line">  return bz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当提交状态修改时，我们可以利用这些方法向tendermint返回根哈希：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) Commit() (rsp types.ResponseCommit)&#123;</span><br><span class="line">  rsp.Data = app.getRootHash()</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当查询状态时，也可以利用这些方法返回状态的证据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) Query(req types.RequestQuery) (rsp types.ResponseQuery) &#123;</span><br><span class="line">  addr := crypto.Address(req.Data)</span><br><span class="line">  rsp.Key = req.Data</span><br><span class="line">  rsp.Value,_ = codec.MarshalBinary(app.Accounts[addr.String()])</span><br><span class="line">  rsp.Proof = app.getProofBytes(addr.String())</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;默克尔树概述&quot;&gt;&lt;a href=&quot;#默克尔树概述&quot; class=&quot;headerlink&quot; title=&quot;默克尔树概述&quot;&gt;&lt;/a&gt;默克尔树概述&lt;/h2&gt;&lt;p&gt;在ABCI应用响应Commit请求消息时，需要计算并返回当前状态的哈希，以便Tendermint 将其打包到下一个区块头里（app_hash字段）。&lt;/p&gt;
&lt;p&gt;但是，如果我们还按原来的方法计算一个总体哈希，例如：hash: = tmhash.Sum(state)， 就存在一个问题 —— 当查询某个特定账户的状态数据时，如何验证该状态是未被篡改的？&lt;/p&gt;
&lt;p&gt;显然，单独返回整个状态的哈希是不够的，但是我们也不可能将整个账户表提供给 客户端以便其重算哈希进行验证，因为其中包含了其他用户的账户信息。&lt;/p&gt;
&lt;p&gt;这就是默克尔树（Merkle Tree）的用武之地：不需要提供完整的数据（例如整个账户表）， 就可以验证某个数据（例如账户A的状态）是否属于该数据集。&lt;/p&gt;
&lt;p&gt;在默克尔树中，叶节点对应于各状态的哈希值，根节点则对应于整个状态的哈希， 中间各层的节点则分别由前一层节点两两结对后计算哈希得到。&lt;/p&gt;
&lt;p&gt;例如，下图给出了4个账户状态时的默克尔树的构成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9WsMy8l.png&quot; alt=&quot;merkle-tree&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>tendermint发行代币</title>
    <link href="http://gcblog/github.io/2019/01/06/tendermint%E5%8F%91%E8%A1%8C%E4%BB%A3%E5%B8%81/"/>
    <id>http://gcblog/github.io/2019/01/06/tendermint发行代币/</id>
    <published>2019-01-06T14:31:38.000Z</published>
    <updated>2019-01-06T14:32:33.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发行自己的代币"><a href="#发行自己的代币" class="headerlink" title="发行自己的代币"></a>发行自己的代币</h1><h2 id="代币发行概述"><a href="#代币发行概述" class="headerlink" title="代币发行概述"></a>代币发行概述</h2><p>状态机模型是一种图灵完备的计算模型，理论上你可以用它来实现任何应用， 代币也不例外。例如，我们可以借鉴以太坊的账户模型，设计出自己的账户 状态机：</p>
<p><img src="https://lh3.googleusercontent.com/-1FgpvG7AFCY/XAiKngG59mI/AAAAAAAAEIY/q_xfvLxbQVQyTOj1dK1xYQ2uBul6tTFkACHMYCw/I/sm-account.png" alt="sm-account"></p>
<p>出于简化问题考虑，我们假设系统只发行一种代币，因此在账户模型中只需要 记录每个账户的余额即可。所有账户及其余额是整个系统的状态，只有当交易 发生时，这一状态才会发生变化。</p>
<p>例如，假设账户tommy有1000个代币，那么当发生一笔从mary到tommy 的500个币的转账交易后，tommy的余额将增加500个代币，同时mary的余额将 减少500个代币，这意味着整个系统在这笔交易后进入了一个新的状态。</p>
<p>基于我们之前的学习，很容易将账户采用哈希地址来表示，同时通过非对称 加密技术进行身份验证，从而实现一个去中心化的代币账户状态机。<br><a id="more"></a></p>
<h2 id="状态机实现"><a href="#状态机实现" class="headerlink" title="状态机实现"></a>状态机实现</h2><p>账户状态机的主要成员，包括记录系统状态的成员变量Accounts，以及表征交易的 成员函数issue()和transfer()：</p>
<p><img src="https://lh3.googleusercontent.com/-wPRofw9uocU/XAiKm1b7zYI/AAAAAAAAEIM/_7p0xWRoWwAwWZquVHXZ9nckYkaOYfscQCHMYCw/I/token-sm.png" alt="token-s"></p>
<p>TokenApp的结构声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type  TokenApp struct &#123;</span><br><span class="line">  types.BaseApplication</span><br><span class="line">  Accounts map[string]int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用一个映射来表示系统的整个状态，其中键为哈希地址，值为账户余额。 由于crypto.Address类型其实是一个字节切片，因此我们采用其16进制表示 作为账户映射表的键。</p>
<p>发行交易将向指定的地址发行一定数量的代币，显然，只允许系统设定的发行人 SYSTEM_ISSUER执行该交易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) issue(issuer,to crypto.Address,value int) error &#123;</span><br><span class="line">  if !bytes.Equal(issuer,SYSTEM_ISSUER) return &#123; errors.New(&quot;invalid issuer&quot;) &#125;</span><br><span class="line">  app.accounts[to] += value</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转账交易从转出账户减去一定数量的代币，再向转入账户增加一定数量的代币， 因此我们需要先保证转出账户有足量的余额：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) transfer(from,to crypto.Address,value int) error &#123;</span><br><span class="line">  if app.accounts[from] &lt; value &#123;return errors.New(&quot;no enough balance&quot;)&#125;</span><br><span class="line">  app.accounts[from] -= value</span><br><span class="line">  app.accounts[to] += value</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="简单钱包实现"><a href="#简单钱包实现" class="headerlink" title="简单钱包实现"></a>简单钱包实现</h2><p>为了避免琐碎的密钥/地址管理，我们使用一个简单的钱包结构来管理一组私钥：</p>
<p><img src="https://lh3.googleusercontent.com/-mvk6yRKXjTk/XAiKm9yf4ZI/AAAAAAAAEII/yGNwzSguf5wGUrd_2G319GxTA3AMXnPUQCHMYCw/I/wallet.png" alt="wallet"></p>
<p>为了避免输入冗长难记的地址，我们使用字符串标识钱包中的不同私钥，因此得到 如下的结构定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Wallet struct &#123;</span><br><span class="line">  Keys map[string]crypto.PrivKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>钱包应该可以随时创建新的私钥，因此我们实现GenPrivKey()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (wallet *Wallet) GenPrivKey(label string) crypto.PrivKey &#123;</span><br><span class="line">  priv := kf.GenPrivKey()</span><br><span class="line">  wallet.Keys[label] = priv</span><br><span class="line">  return priv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GenPrivKey()方法需要传入一个字符串作为私钥的标识，以便我们可以在 以后使用该标识获取该私钥，或者该私钥对应的公钥或地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (wallet *Wallet) GetPrivKey(label string) crypto.PrivKey &#123;</span><br><span class="line">  return wallet.Keys[label]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，还需要提供一个方法将钱包保存到硬盘上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (wallet *Wallet) Save(wfn string)&#123;</span><br><span class="line">  bz,err := codec.MarshalJSON(wallet)</span><br><span class="line">  if err != nil &#123; panic(err) &#125;</span><br><span class="line">  ioutil.WriteFile(wfn,bz,0644)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者载入硬盘的钱包文件获得一个钱包实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func LoadWallet(wfn string) *Wallet&#123;</span><br><span class="line">  var wallet Wallet</span><br><span class="line">  bz,err := ioutil.ReadFile(wfn)</span><br><span class="line">  if err != nil &#123; panic(err) &#125;</span><br><span class="line">  err = codec.UnmarshalJSON(bz,&amp;wallet)</span><br><span class="line">  if err != nil &#123; panic(err) &#125;</span><br><span class="line">  return &amp;wallet  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="交易结构设计与实现"><a href="#交易结构设计与实现" class="headerlink" title="交易结构设计与实现"></a>交易结构设计与实现</h2><p>由于我们使用非对称密钥进行身份标识，因此在交易中需要包含身份校验所需要的 信息，例如签名、公钥和消息序列号：</p>
<p><img src="https://lh3.googleusercontent.com/-ot6g87ztbro/XAiKnp-91oI/AAAAAAAAEIU/Xp6ldO3EiV07P12L56nF1pusSHh_d_SHQCHMYCw/I/tx-struct.png" alt="tx-struct"></p>
<p>我们使用一个统一的Tx结构来表示所有的交易，其中交易载荷指向一个Payload接口的 实现，该接口的三个方法可用于接收方的签名验证与交易路由：</p>
<p>GetSigner()：获取交易发起方地址<br>GetSignBytes()：获取交易载荷中用于签名的数据<br>GetType()：获取交易类别，状态机根据该调用返回值执行相应的动作<br>在账户状态机应用中，我们需要两种类型的交易：发行交易、转账交易，分别用于 向指定账户发行代币，以及在指定账户之间转移代币。不同的交易对应不同的Payload 接口实现，例如对于转账交易，其对应的TransferPayload结构的接口实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *TransferPayload) GetSigner() crypto.Address&#123;   return p.From  &#125;</span><br><span class="line">func (p *TranferPayload) GetSignBytes() []byte &#123;   return json.Marshal(p) &#125;</span><br><span class="line">func (p *TransferPayload)  GetType() string&#123;   return &quot;transfer&quot; &#125;</span><br></pre></td></tr></table></figure></p>
<p>交易核验</p>
<p>在接收端，首先应当检查交易结构中公钥的有效性，这通过校验公钥与交易发起方地址 是否一致来实现，然后则通过重算交易签名来确认签名的有效性，只有有效的交易，我们 才进行后续处理。例如，下面的代码展示了交易的验证逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (app *AccountApp) validateTx(tx *Tx) error &#123;</span><br><span class="line">  addr := tx.PubKey.Address()</span><br><span class="line">  if !bytes.Equals(addr,tx.Payload.GetSigner()) &#123; return errors.New(&quot;pubkey / signer mismatch&quot;) &#125;</span><br><span class="line">  valid := tx.PubKey.VerifyBytes(tx.Payload.GetSignBytes(),tx.Signature)</span><br><span class="line">  if !valid  &#123; errors.New(&quot;bad signature&quot;) &#125;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>交易路由</p>
<p>一旦交易验证有效，状态就可以根据交易类别进行分别处理了。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch tx.Payload.GetType()&#123;</span><br><span class="line">  case &quot;transfer&quot;:  </span><br><span class="line">    pld := tx.Payload.(TransferPayload)</span><br><span class="line">    app.transfer(pld.From,pld.To,pld.Value)</span><br><span class="line">  case &quot;issue&quot;:  </span><br><span class="line">    pld := tx.Payload.(IssuePayload)</span><br><span class="line">    app.issue(pld.Issuer,pld.To,pld.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="交易的编解码处理"><a href="#交易的编解码处理" class="headerlink" title="交易的编解码处理"></a>交易的编解码处理</h2><p>根据我们定义的交易结构，显然在RPC客户端提交交易之前，需要首先串行化为 16进制码流，在ABCI应用中同时也需要相应的解码：</p>
<p><img src="https://lh3.googleusercontent.com/-afcL-yNBO0c/XAiKnuKkykI/AAAAAAAAEIc/Ruug_ukvbuIF-lOzAhkZICvku0En8g98wCHMYCw/I/tx-codec.png" alt="tx-code"></p>
<p>tendermint官方推荐的编解码器是其自产的go-amino，它类似于protobuf，最大的特点是支持 解码到接口类型 —— 这就是我们可以在Tx结构中使用接口类型的原因。</p>
<p>amino通过在编码码流中加入标识序列来区分不同的接口实现结构，因此解码接口之前，首先 需要注册接口以及对应的实现结构及标识名，例如，在下面的代码中，我们注册Payload接口， 然后注册其两个实现结构TransferPayload和IssuePayload，并分别使用tx/transfer 和tx/issue来标识这两个Payload接口的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">codec := amino.NewCodec()</span><br><span class="line">codec.RegisterInterface((*Payload)(nil),nil)</span><br><span class="line">codec.RegisterConcrete(*TransferPayload&#123;&#125;,&quot;tx/transfer&quot;,nil)</span><br><span class="line">codec.RegisterConcrete(*IssuePayload&#123;&#125;,&quot;tx/issue&quot;,nil)</span><br></pre></td></tr></table></figure></p>
<p>需要指出的是，当你使用amino时，并不是所有的自定义类型都需要在codec中注册，只有那些 需要解码到接口类型的结构，才需要进行注册。</p>
<p>现在，接收端可以对接收到的二进制码流bz进行解码了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (app *AccountApp) decodeTx(bz []byte) (*Tx,error)&#123;</span><br><span class="line">  var tx Tx</span><br><span class="line">  err := codec.UnmarshalBinary(bz,&amp;tx)</span><br><span class="line">  return &amp;tx,err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ABCI协议实现"><a href="#ABCI协议实现" class="headerlink" title="ABCI协议实现"></a>ABCI协议实现</h2><p>有了基本的状态机、钱包、交易结构以及序列化手段，现在我们可以实现状态机的ABCI接口了：</p>
<p><img src="https://lh3.googleusercontent.com/-Q2P78SG_soU/XAiKm3FLwdI/AAAAAAAAEIQ/IecHrp48bQECoWV5XuhmjqaySYMQWUFQACHMYCw/I/token-abci.png" alt="token-abci"></p>
<p>交易检查：CheckTx</p>
<p>在CheckTx()方法实现中检查交易的有效性，只有解码正确并且检查有效的交易才允许 进入交易内存池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) CheckTx(bz []byte) types.ResponseCheckTx &#123;</span><br><span class="line">  var tx Tx</span><br><span class="line">  err := codec.UnmarshalBinary(bz,&amp;tx)</span><br><span class="line">  if err !=nil &#123; return types.ResponseCheckTx&#123;Code:1,Info: err.Error()&#125;&#125;</span><br><span class="line">  err = app.validateTx(tx)</span><br><span class="line">  if err !=nil &#123; return types.ResponseCheckTx&#123;Code:2,Info:err.Error()&#125;&#125;</span><br><span class="line">  return types.ResponseCheckTx&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交易执行：DeliverTx</p>
<p>在DeliverTx()方法中判断交易类型，然后执行相应的状态迁移：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) DeliverTx(bz []byte) (rsp types.ResponseDeliverTx)&#123;</span><br><span class="line">  var tx Tx</span><br><span class="line">  codec.UnmarshalBinary(bz,&amp;tx)</span><br><span class="line">  switch tx.Payload.GetType() &#123;</span><br><span class="line">    case &quot;transfer&quot;: </span><br><span class="line">      pld := tx.Payload.(TransferPayload)</span><br><span class="line">      app.transfer(pld.From,pld.To,pld.Value)     </span><br><span class="line">    case &quot;issue&quot;: </span><br><span class="line">      pld := tx.Payload.(IssuePayload)</span><br><span class="line">      app.issue(pld.Issuer,pld.To,pld.Value) </span><br><span class="line">    default: rsp.Code = 1</span><br><span class="line">  &#125;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态查询</p>
<p>在Query()方法中返回指定账户的余额：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *TokenApp) Query(req types.RequestQuery) types.ResponseQuery&#123;</span><br><span class="line">  addr := crypto.Address(req.Data)</span><br><span class="line">  bal, _ := codec.MarshalBinary(app.Accounts[addr.String()])</span><br><span class="line">  desc: = fmt.Sprintf(&quot;balance : %v =&gt; %v&quot;,addr,app.Accounts[addr.String])</span><br><span class="line">  return types.ResponseQuery&#123;Key:req.Data,Value:bal,Log:desc&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RPC客户端开发"><a href="#RPC客户端开发" class="headerlink" title="RPC客户端开发"></a>RPC客户端开发</h2><p>tendermint内置了RPC开发接口的API封装包rpc/client，极大地简化了客户端的 开发难度：</p>
<p><img src="https://lh3.googleusercontent.com/-8AunBudQiis/XAiKnq_aegI/AAAAAAAAEIg/0CBgl7HKYEwgX40PXWW17L8udbqEnnRQwCHMYCw/I/rpc-client.png" alt="rpc-client"></p>
<p>使用rpc/client包的NewHTTP()方法，我们可以得到一个HTTP实例：</p>
<p><code>cli := client.NewHTTP(&quot;http://localhost:26657&quot;,&quot;&quot;)</code><br>HTTP结构实现了tendermint中所有的RPC客户端接口，例如ABCI客户端接口 （ABCIClient）、历史数据访问接口（HistoryClient）等，因此我们可以直接 利用其方法向abci应用提交交易。</p>
<p>首先构造一个发行交易，并利用发行人私钥签名交易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paylod := NewIssuePayload(issuerAddr,receiverAddr,value)</span><br><span class="line">tx := NewTx(payload)</span><br><span class="line">tx.Sign(issuerPrivKey)</span><br></pre></td></tr></table></figure></p>
<p>然后将交易实例序列化：</p>
<p><code>rawtx,_ := codec.MarshalBinary(tx)</code><br>最后使用HTTP实例的BroadcastTxCommit()方法提交给节点，并 打印输出响应结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret,_ := cli.BroadcastTxCommit(rawtx)</span><br><span class="line">fmt.Printf(&quot;ret =&gt; %+v\n&quot;,ret)</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;发行自己的代币&quot;&gt;&lt;a href=&quot;#发行自己的代币&quot; class=&quot;headerlink&quot; title=&quot;发行自己的代币&quot;&gt;&lt;/a&gt;发行自己的代币&lt;/h1&gt;&lt;h2 id=&quot;代币发行概述&quot;&gt;&lt;a href=&quot;#代币发行概述&quot; class=&quot;headerlink&quot; title=&quot;代币发行概述&quot;&gt;&lt;/a&gt;代币发行概述&lt;/h2&gt;&lt;p&gt;状态机模型是一种图灵完备的计算模型，理论上你可以用它来实现任何应用， 代币也不例外。例如，我们可以借鉴以太坊的账户模型，设计出自己的账户 状态机：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-1FgpvG7AFCY/XAiKngG59mI/AAAAAAAAEIY/q_xfvLxbQVQyTOj1dK1xYQ2uBul6tTFkACHMYCw/I/sm-account.png&quot; alt=&quot;sm-account&quot;&gt;&lt;/p&gt;
&lt;p&gt;出于简化问题考虑，我们假设系统只发行一种代币，因此在账户模型中只需要 记录每个账户的余额即可。所有账户及其余额是整个系统的状态，只有当交易 发生时，这一状态才会发生变化。&lt;/p&gt;
&lt;p&gt;例如，假设账户tommy有1000个代币，那么当发生一笔从mary到tommy 的500个币的转账交易后，tommy的余额将增加500个代币，同时mary的余额将 减少500个代币，这意味着整个系统在这笔交易后进入了一个新的状态。&lt;/p&gt;
&lt;p&gt;基于我们之前的学习，很容易将账户采用哈希地址来表示，同时通过非对称 加密技术进行身份验证，从而实现一个去中心化的代币账户状态机。&lt;br&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>tendermint加密算法</title>
    <link href="http://gcblog/github.io/2018/12/18/tendermint%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://gcblog/github.io/2018/12/18/tendermint加密算法/</id>
    <published>2018-12-18T08:59:32.000Z</published>
    <updated>2018-12-20T05:42:59.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="身份识别机制概述"><a href="#身份识别机制概述" class="headerlink" title="身份识别机制概述"></a>身份识别机制概述</h2><p>无论是中心化系统，还是去中心化系统，都有一个基本的问题：如何表征与验证用户的身份。</p>
<p>在中心化系统中，这一问题是基于统一存储的用户表来实现的：每个用户在表中都有 一条对应的记录，而系统则通过验证用户输入的用户名和口令是否与用户表中的记录一致来识别 用户的身份：</p>
<p><img src="https://lh3.googleusercontent.com/-rw73ACdT8sI/XAiJ0GfZ27I/AAAAAAAAEGQ/QFDJDZxLhCgFLYmTBzLjBAf825oBFzAAACHMYCw/I/id-plan-compare-1.png" alt="id-plan-compare"></p>
<p>区块链则采用了另外一种不需要集中存储的方案来解决这一问题：每个用户由一对公/私钥来 标识，可以将公钥视为用户名，而私钥视为用户的口令。当用户提交数据时，必须使用自己 的私钥进行签名，这样其他人就可以利用其公钥验证签名数据是否真的来自于该用户。</p>
<p>不过由于公钥比较长，通常会对公钥进行一定的哈希计算，并进行必要的截短，作为区块链上 用户的标识，即我们通常所说的地址。</p>
<p>tendermint提供了两种非对称加密算法的实现：比特币/以太坊采用的secp256k1椭圆曲线算法， 以及tendermint推荐的相对较新的ed25519加密算法，在我们的应用中都可以用来实现身份识别。<br><a id="more"></a></p>
<h2 id="经典算法secp256k1"><a href="#经典算法secp256k1" class="headerlink" title="经典算法secp256k1"></a>经典算法secp256k1</h2><p>Secp256k1是指比特币中使用的ECDSA(椭圆曲线数字签名算法)曲线的参数，公/私钥就对应于 该曲线上的点。</p>
<p>在比特币流行之前secp256k1几乎无人使用，但现在已经是无人不知了。secp256k1的参数由于 是精心选择的，因此它的计算会比随机参数的曲线快30%，具有较短的密钥，同时也能显著降低 算法中存在后门的风险。</p>
<p>tendermint内置了secp256k1的实现包crypto/secp256k1，其中的PrivKeySecp256k1和 PubKeySecp256k1分别实现了私钥和公钥接口：</p>
<p><img src="https://lh3.googleusercontent.com/-1VROJMF7QdQ/XAiJ0KcyefI/AAAAAAAAEGc/NPEtkVID1QEGILwfbcXPuGzUSPZ_KUN5gCHMYCw/I/key-address.png" alt="key-address"></p>
<p>私钥对应于曲线上点的X坐标。使用secp256k1包的GenPrivKey()方法可以生成一个32 字节长的随机私钥，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priv := secp256k1.GenPrivKey()</span><br><span class="line">fmt.Printf(&quot;private key =&gt; %v\n&quot;,priv)</span><br></pre></td></tr></table></figure></p>
<p>或者将一个特定的密文转换为私钥，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priv := secp256k1.GenPrivKeySecp256k1([]byte(&quot;your secret byte slice&quot;))</span><br><span class="line">fmt.Printf(&quot;private key =&gt; %v\n&quot;,priv)</span><br></pre></td></tr></table></figure></p>
<p>公钥对应与曲线上点的Y坐标，因此从私钥可以推导出公钥，调用私钥的GetPubKey() 方法获得其对应的公钥实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub := priv.GetPubKey()</span><br><span class="line">fmt.Printf(&quot;public key =&gt; %v\n&quot;,pub)</span><br></pre></td></tr></table></figure></p>
<p>tendermint的实现是返回压缩公钥，因此公钥长度是32+1=33字节 —— 额外的1个字节标识Y 在上部还是下部。 地址的计算方法和比特币一样，都是对公钥进行两重哈希运算（sha256-&gt;ripemd160）， 最后得到20字节长的地址，但tendermint的地址没有像比特币那样添加网络前缀。</p>
<p>调用公钥实例的Address()方法获取公钥对应的地址，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr := pub.Address()</span><br><span class="line">fmt.Printf(&quot;address =&gt; %v\n&quot;,addr)</span><br></pre></td></tr></table></figure></p>
<p>尽管secp256k1在区块链领域已经非常流行，但是它也有一些问题。</p>
<p>首先是计算效率的问题。Montgomery ladder是一种可以快速简捷地进行椭圆曲线计算的 方法，但是secp256k1不支持，这使得它的计算效率无法通过采用该算法得到提升。</p>
<p>其次是secp256k1不具备数理完备性。在某些边界情况下，secp256k1有可能产生错误的结果， 因此这要求在算法实现时非常小心。</p>
<p>最后是secp256k1对扭曲攻击的抵抗力不够强。扭曲攻击是指攻击者从类似的曲线上抽点 来欺骗算法。secp256k1必须在签名和验证过程中检查攻击者提供的点是否真的在曲线上， 这使得安全性和效率打了折扣。</p>
<h2 id="下一代算法ed25519"><a href="#下一代算法ed25519" class="headerlink" title="下一代算法ed25519"></a>下一代算法ed25519</h2><p>tendermint推荐的ed25519算法属于下一代的EdDSA签名算法，与secp256k1相比，ed25519 的计算能快30%，安全性更高，密钥和签名也更短一些。下表列出了两者的对比：</p>
<p>类型    Secp256k1    Ed25519<br>私钥长度    32 字节    64 字节<br>公钥长度    33 字节    32 字节<br>签名长度    ~71 字节    64 字节<br>安全目标    2128    2128<br>安全测试通过率    7/11    11/11</p>
<p>tendermint的ed25519实现包是crypto/ed25519，其中的PrivKeyEd25519和 PubKeyEd25519分别实现了私钥和公钥接口：</p>
<p><img src="https://lh3.googleusercontent.com/-HPN4U1hdDS8/XAiJ0A61uPI/AAAAAAAAEGU/pgqGTicZKvIv2N6Dqz4gKJPWxMtsRm9VwCHMYCw/I/ed25519.png" alt="ed25519"></p>
<p>使用ed25519包的GenPrivKey()方法可以生成一个64字节长的随机私钥，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priv := ed25519.GenPrivKey()</span><br><span class="line">fmt.Printf(&quot;private key =&gt; %v\n&quot;,priv)</span><br></pre></td></tr></table></figure></p>
<p>或者将一个特定的密文转换为私钥，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priv := ed25519.GenPrivKeyFromSecret([]byte(&quot;your secret byte slice&quot;))</span><br><span class="line">fmt.Printf(&quot;private key =&gt; %v\n&quot;,priv)</span><br></pre></td></tr></table></figure></p>
<p>调用私钥的GetPubKey()方法获得其对应的公钥实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub := priv.GetPubKey()</span><br><span class="line">fmt.Printf(&quot;public key =&gt; %v\n&quot;,pub)</span><br></pre></td></tr></table></figure></p>
<p>地址的计算方法，就是对公钥进行sha256哈希计算，然后截取前20个字节。 调用公钥实例的Address()方法获取公钥对应的地址，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr := pub.Address()</span><br><span class="line">fmt.Printf(&quot;address =&gt; %v\n&quot;,addr)</span><br></pre></td></tr></table></figure></p>
<h2 id="数据签名与认证"><a href="#数据签名与认证" class="headerlink" title="数据签名与认证"></a>数据签名与认证</h2><p>非对称密钥有一个很有用的特性，就是私钥签名，可以用公钥进行认证：</p>
<p><img src="https://lh3.googleusercontent.com/-s0CFT2YZEEc/XAiJ0BCdgaI/AAAAAAAAEGY/-z0-4GYH2JITtRD6GmB279nTYqnStLblACHMYCw/I/key-verify.png" alt="key-verify"></p>
<p>发送方首先使用私钥签名要发送的数据，例如msg的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privTommy := secp256k1.GenPrivKey()</span><br><span class="line">msg := []byte(&quot;some text to send&quot;)</span><br><span class="line">sig := privTommy.Sign(msg)</span><br></pre></td></tr></table></figure></p>
<p>由于secp256k1和ed25519都实现了PrivKey接口，因此你可以任选其一生成 你的私钥。</p>
<p>Sign()方法返回的是一个字节切片，通常和被签名的数据一起发送出去， 当然，接收方不一定持有发送方的公钥，因此通常也会把公钥一并发过去。</p>
<p>例如，我们可以使用如下的结构来声明要发送的签名数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Letter struct &#123;</span><br><span class="line">  Msg []byte</span><br><span class="line">  Signature []byte</span><br><span class="line">  PubKey secp256k1.PubKeySecp256k1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将签名数据序列化为字节码流，然后通过网络发送出去，或者拷贝给接收方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letter := Letter&#123;msg,sig,pubSender.(kf.PubKeySecp256k1)&#125;</span><br><span class="line">bz,err := json.Marshal(letter)</span><br><span class="line">if err !=nil &#123; panic(err) &#125;</span><br><span class="line">fmt.Printf(&quot;encoded letter =&gt; %x\n&quot;,bz)</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们使用了json编码器，当然你可以使用任何其他可用的编解码器， 例如gob。</p>
<p>接收方首先解码接收到的字节码流：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var received Letter</span><br><span class="line">err = json.Unmarshal(bz,&amp;received)</span><br><span class="line">if err !=nil &#123; panic( err)&#125;</span><br><span class="line">fmt.Printf(&quot;decoded letter =&gt; %+v\n&quot;,received)</span><br></pre></td></tr></table></figure></p>
<p>然后就可以使用信件中发送方的公钥验证签名了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valid := received.PubKey.VerifyBytes(received.Msg,received.Signature)</span><br><span class="line">fmt.Printf(&quot;validated =&gt; %t\n&quot;,valid)</span><br></pre></td></tr></table></figure></p>
<h2 id="获得配套代码资料"><a href="#获得配套代码资料" class="headerlink" title="获得配套代码资料"></a>获得配套代码资料</h2><p>关注微信公众号<code>区块链001</code>, 回复<code>tendermint</code>获得</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;身份识别机制概述&quot;&gt;&lt;a href=&quot;#身份识别机制概述&quot; class=&quot;headerlink&quot; title=&quot;身份识别机制概述&quot;&gt;&lt;/a&gt;身份识别机制概述&lt;/h2&gt;&lt;p&gt;无论是中心化系统，还是去中心化系统，都有一个基本的问题：如何表征与验证用户的身份。&lt;/p&gt;
&lt;p&gt;在中心化系统中，这一问题是基于统一存储的用户表来实现的：每个用户在表中都有 一条对应的记录，而系统则通过验证用户输入的用户名和口令是否与用户表中的记录一致来识别 用户的身份：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-rw73ACdT8sI/XAiJ0GfZ27I/AAAAAAAAEGQ/QFDJDZxLhCgFLYmTBzLjBAf825oBFzAAACHMYCw/I/id-plan-compare-1.png&quot; alt=&quot;id-plan-compare&quot;&gt;&lt;/p&gt;
&lt;p&gt;区块链则采用了另外一种不需要集中存储的方案来解决这一问题：每个用户由一对公/私钥来 标识，可以将公钥视为用户名，而私钥视为用户的口令。当用户提交数据时，必须使用自己 的私钥进行签名，这样其他人就可以利用其公钥验证签名数据是否真的来自于该用户。&lt;/p&gt;
&lt;p&gt;不过由于公钥比较长，通常会对公钥进行一定的哈希计算，并进行必要的截短，作为区块链上 用户的标识，即我们通常所说的地址。&lt;/p&gt;
&lt;p&gt;tendermint提供了两种非对称加密算法的实现：比特币/以太坊采用的secp256k1椭圆曲线算法， 以及tendermint推荐的相对较新的ed25519加密算法，在我们的应用中都可以用来实现身份识别。&lt;br&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
      <category term="secp256k1" scheme="http://gcblog/github.io/tags/secp256k1/"/>
    
      <category term="ed25519" scheme="http://gcblog/github.io/tags/ed25519/"/>
    
  </entry>
  
  <entry>
    <title>三状态机与ABCI</title>
    <link href="http://gcblog/github.io/2018/12/17/%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8EABCI/"/>
    <id>http://gcblog/github.io/2018/12/17/状态机与ABCI/</id>
    <published>2018-12-17T11:13:21.000Z</published>
    <updated>2018-12-17T11:21:47.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态机与ABCI"><a href="#状态机与ABCI" class="headerlink" title="状态机与ABCI"></a>状态机与ABCI</h1><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>tendermint采用的分布式计算模型为状态机复制（State Machine Replication），其基本 思路就是通过在多个节点间通过同步输入序列来保证各节点状态机的同步。</p>
<p>状态机是一种在通信软件、游戏、工业控制等领域应用非常广泛的计算模型，用来抽象地表示一个 系统的演化过程。状态机由一组（有限或无限的）状态以及激发状态迁移的外部输入组成， 对于确定性状态机而言，在某一个时刻一定处于一个确定的状态，而在一个状态下 针对特定输入的状态迁移也是确定的。</p>
<p>现在让我们看一个计数器的状态以及其变化情况，在某一个特定时刻其状态为特定的数值：</p>
<p>counter state machine<br><img src="https://lh3.googleusercontent.com/-4X19ZKNBNgA/XAiKDw17mvI/AAAAAAAAEGg/xhsVl_BXkwwJLl3Qq_RkCiJvZTCXqr7KQCHMYCw/I/sm-counter.png" alt="sm-counte"></p>
<p>显然，计数器有无限个状态（1,2,3…），但只有三个触发动作：</p>
<ul>
<li>inc - 递增</li>
<li>dec - 递减 </li>
<li>reset - 复位<a id="more"></a>
当涉及到区块链时，这些来自状态机外部的触发动作通常被称为交易/Transaction， 将被永久性地保存在区块链上，成为区块链不可篡改特性的一个基石。</li>
</ul>
<h2 id="状态机复制"><a href="#状态机复制" class="headerlink" title="状态机复制"></a>状态机复制</h2><p>状态机复制是指在多个节点中的状态机保持一致，彼此互为副本，无论客户端访问哪一个 节点，都能得到同样的状态；无论客户端向哪一个节点提交交易，也都能保证各节点可以 最终过渡到一致的新状态。</p>
<p>尽管是显而易见的，但依然值得指出，只有确定性状态机才可以利用状态机 复制模型实现分布式共识。</p>
<p>显然，当任意一个节点收到交易请求时，首先需要与其他节点进行协调，确认达成一致意见后， 再分别于不同的节点执行同样的交易序列 —— 状态机复制就是通过在各节点之间保持交易序列 （状态机的外部输入）的一致次序来保证最终状态的一致性的，而节点间协调的过程，就是我们 所说的共识算法。</p>
<p>下图反映了tendermint作为共识引擎时，RPC客户端、tendermint程序和abci应用 三者之间（简化）的交互时序：<br><img src="https://lh3.googleusercontent.com/-dG1enIwN3nU/XAiKEeUnSUI/AAAAAAAAEGo/tXTtVMIQimk5ZPU3I2xWEBbkzy72UyCAgCHMYCw/I/sm-replica.png" alt="sm-replica"></p>
<p>当RPC客户端提交一个新的交易后，该交易首先进入tendermint的交易池，然后tendermint将与 其他节点就要执行哪些交易的问题通过p2p协议进行协调，达成共识后，tendermint才会通知应用状态机 执行交易更新状态。</p>
<p>显然，在整个状态机复制模型中，作为状态机的ABCI应用是被动的，它只需要响应来自共识引擎 的ACBI消息，并执行相应的动作即可。 </p>
<h2 id="ABCI-接口概述"><a href="#ABCI-接口概述" class="headerlink" title="ABCI 接口概述"></a>ABCI 接口概述</h2><p>tendermint将ABCI协议交互过程进行了封装，开发者只需要实现Application接口，等待tendermint 在合适的时机调用就可以了：</p>
<p><img src="https://lh3.googleusercontent.com/-z6DvEYgdtCk/XAiKPjuPYHI/AAAAAAAAEG0/T9OJLxTPJUgMZ0YVSGaK956aEPIn8aavQCHMYCw/I/uml-abci-application.png" alt="uml-abci-application"></p>
<p>上图列出了Application接口约定的方法，每个方法对应于一个特定的ABCI消息：</p>
<p>Info：当tendermint与ABCI应用建立初始连接时，将发送Info请求消息尝试获取应用状态对应的区块 高度、状态哈希等信息，以确定是否需要重放（replay）区块交易。</p>
<p>Query：当Rpc客户端发出abci_query调用时，tendermint将通过Query请求消息转发给ABCI应用，并 将响应结果转发回Rpc客户端。</p>
<p>CheckTx：当tendermint从Rpc接口或p2p端口收到新的交易时，首先会通过CheckTx请求消息提给ABCI应用 进行初步检查，确认该交易是否合规。只有ABCI应用确认有效的消息才会进入tendermint的交易 池等待下一步的共识确认。</p>
<p>InitChain：当创建创世块时，tendermint会发送InitChain请求消息给ABCI应用，可以在此刻进行 应用状态机的状态初始化。</p>
<p>BeginBlock/EndBlock：当tendermint就新区块交易达成共识后，将通过BeginBlock请求开始启动ABCI应用 的交易执行流程，并以EndBlock请求作为交易执行流程的结束。</p>
<p>DeliverTx：在BeginBlock和EndBlock请求之间，tendermint会为区块中的每一个交易向ABCI应用 发出一个DeliverTx请求消息，这是应用状态机更新的时机。</p>
<p>Commit：作为执行交易的最后一步，tendermint会发送Commit请求，并在获取响应后持久化区块状态。</p>
<h2 id="交易检查：CheckTx"><a href="#交易检查：CheckTx" class="headerlink" title="交易检查：CheckTx"></a>交易检查：CheckTx</h2><p>为了减轻共识环节的工作负担，对于通过rpc接口提交的交易，tendermint引入了 交易检查环节，只有检查成功的交易才能够进入交易池等待确认，否则直接拒绝：</p>
<p><img src="https://lh3.googleusercontent.com/-1-zUz1B_UnY/XAZR4IstqJI/AAAAAAAAEEs/MO9w6CYPll407QDP_NhoTBMIWvpDi8-mgCHMYCw/I/abci-checktx.png" alt="abci-checktx"></p>
<p>例如，下面的代码检查交易是否为指定的三种交易之一（0x01 - inc，0x02 - dec ,0x03 - reset）， 否则拒绝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *EzApp) CheckTx(tx []byte) types.ResponseCheckTx&#123;</span><br><span class="line">  if tx[0]  &lt; 0x04 &#123; </span><br><span class="line">    return types.ResponseCheckTx&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return types.ResponseCheckTx&#123;Code:1,Log:&quot;bad tx rejected&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>CheckTx()</code>方法返回的是一个ResponseCheckTx结构，其组成与ResponseDeliverTx 相同：</p>
<p><img src="https://lh3.googleusercontent.com/-aKE1lVKJtVs/XAZR4DggZUI/AAAAAAAAEEo/-uX8irWbscQIALtcyIZAMVabCFEmaUFMACHMYCw/I/rps-checktx.png" alt="rps-checktx"></p>
<p>同样，结构中只有Code是必须的，为0值时表示交易执行成功，不同的非0值的失败含义由 应用自行定义。</p>
<p>现在，当我们对修改过的ABCI应用试图提交如下的交易时，将发生错误：</p>
<p><code>~$ curl http://localhost:26657/broadcast_tx_commit?tx=0x78</code><br>结果如下：</p>
<p><img src="https://lh3.googleusercontent.com/-p5rpZCNDpXQ/XAZR4Bqmi3I/AAAAAAAAEEw/XZZ6X7rbiwktKB8FvreKmHOpxjkKcfTbQCHMYCw/I/rsp-checktx.png" alt="rsp-checktx"></p>
<p>交易的唯一性要求</p>
<p>为了对抗重放攻击，以及避免节点间反弹的重复消息引起共识过程死循环，tendermint在 触发CheckTx()之前会使用一个缓存拒绝近期已经出现过的交易。因此当你试图重复提交 一个交易时，将提示该交易已经存在的错误：tx already exists in cache。</p>
<p>解决的办法就是为交易附加一个序列号，以保证交易的唯一性。例如，当我们使用0x01表示 inc交易时，可以如下的方式多次提交交易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ curl http://localhost:26657/broadcast_tx_commit?tx=0x0101</span><br><span class="line">~$ curl http://localhost:26657/broadcast_tx_commit?tx=0x0102</span><br><span class="line">~$ curl http://localhost:26657/broadcast_tx_commit?tx=0x0103</span><br></pre></td></tr></table></figure></p>
<p>交易序列号的设计完全取决于特定的应用，tendermint只是简单地拒绝已经在缓存中的交易。</p>
<h2 id="交易执行：DeliverTx"><a href="#交易执行：DeliverTx" class="headerlink" title="交易执行：DeliverTx"></a>交易执行：DeliverTx</h2><p>计数器应用只有一个要维护的状态（计数值），因此第一版的实现很简单，我们 只需要在DeliverTx方法中检查交易类型，然后增减或复位成员变量Value即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type CounterApp struct&#123;</span><br><span class="line">  types.BaseApplication</span><br><span class="line">  Value int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (app *CounterApp) DeliverTx(tx []byte) types.ResponseDeliverTx&#123;</span><br><span class="line">  switch tx[0] &#123;</span><br><span class="line">    case 0x01: app.Value += 1</span><br><span class="line">    case 0x02: app.Value -= 1</span><br><span class="line">    case 0x03: app.Value = 0</span><br><span class="line">    default: return types.ResponseDeliverTx&#123;Code:0,Log:&quot;bad tx&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  info := fmt.Printf(&quot;value updated : %v&quot;,app.Value)</span><br><span class="line">  return types.ResponseDeliverTx&#123;Info: info&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>DeliverTx()</code>方法的返回结果是一个ResponseDeliverTx结构，其定义如下：</p>
<p><img src="https://lh3.googleusercontent.com/-_ExelDcyWOk/XAiKQiZg7fI/AAAAAAAAEHI/g5CtcJs0p0M2SIajwa5OL7UYFSOK9q4bwCHMYCw/I/rsp-delivertx.png" alt="rsp-delivertx"></p>
<p>结构中只有Code是必须的，为0值时表示交易执行成功，不同的非0值的失败含义由 应用自行定义。</p>
<h3 id="状态初始化：InitChain"><a href="#状态初始化：InitChain" class="headerlink" title="状态初始化：InitChain"></a>状态初始化：InitChain</h3><p>当tendermint准备构建创始区块时，将向abci应用发送InitChain消息，同时在该消息 请求中可以携带创世文件genesis.json中应用特定的初始化状态数据（app_byte）， 因此是应用进行状态初始化的好时机：</p>
<p><img src="https://lh3.googleusercontent.com/-rlJ2-JdfY1M/XAiKPuw9QXI/AAAAAAAAEG4/QBHZ5JLZ56wxCnmJRHjgr3LF3ecxOWh7wCHMYCw/I/req-initchain.png" alt="req-initchain"></p>
<p>例如，下面的代码将计数状态从100开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) InitChain(req types.RequestInitChain) types.ResponseInitChain&#123;</span><br><span class="line">  app.Value = 100</span><br><span class="line">  return types.ResponseInitChain&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中我们直接在InitChain()实现中设定了技术初始值100，这当然是可以的，不过 更好的办法是借助于创世文件genesis.json，在该文件中声明应用状态的初始值。</p>
<p>例如，下面展示了genesis.json中的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;genesis_time&quot;: &quot;2018-10-30T00:42:47.699648591Z&quot;,</span><br><span class="line">  &quot;chain_id&quot;: &quot;test-chain-wx5RA8&quot;,</span><br><span class="line">  ...</span><br><span class="line">  &quot;app_hash&quot;: &quot;&quot;,</span><br><span class="line">  &quot;app_state&quot;: &#123;&quot;counter&quot;:100&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>app_state字段的内容将以原始字节码的形式在InitChain请求的AppStateBytes字段传入， 因此，我们改为如下的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) InitChain(req types.RequestInitChain) types.ResponseInitChain&#123;</span><br><span class="line">  var state map[string]int</span><br><span class="line">  json.Unmarshal(req.AppStateBytes,&amp;state)</span><br><span class="line">  app.Value = state[&quot;counter&quot;]</span><br><span class="line">  return types.ResponseInitChain&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用状态查询：Query"><a href="#应用状态查询：Query" class="headerlink" title="应用状态查询：Query"></a>应用状态查询：Query</h2><p>RPC客户端可以利用节点旳abci_query调用查询ABCI应用维护的状态，该调用允许在请求 中设定查询条件，以过滤潜在的查询结果：</p>
<p><img src="https://lh3.googleusercontent.com/-42MySWeNchA/XAiKQ-oU3WI/AAAAAAAAEHs/07MlHJ9VlM8_00OFFixEwi0nrAgemzo_wCHMYCw/I/abci-query.png" alt="abci-query"></p>
<p>对于我们的计数状态机而言，由于只有一个状态Value，因此直接返回它的当前值即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Query(req types.RequestQuery) types.ResponseQuery&#123;</span><br><span class="line">  val := fmt.Sprintf(&quot;%d&quot;,app.Value)</span><br><span class="line">  return types.ResponseQuery&#123;Value: []byte(val)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Query()的参数是一个RequestQuery结构，用来指定查询条件，由于我们只有一个状态 值得返回，因此暂时先忽略它。</p>
<p>Query()的返回结果是一个ResponseQuery结构，其定义如下：</p>
<p><img src="https://lh3.googleusercontent.com/-i6Jt3CF9RYI/XAiKQ1TWBiI/AAAAAAAAEHg/l60WYvZogpsb53SY2J7gfDPPELU8EOIbgCHMYCw/I/rsp-query.png" alt="rsp-query"></p>
<p>同样，结构中只有Code是必须的，为0值时表示交易执行成功，不同的非0值的失败含义由 应用自行定义即可。对于计数应用，我们使用Value字段来返回当前状态值。</p>
<p>现在可以使用abci_query来查询应用状态了：</p>
<p><code>~$ curl http://localhost:26657/abci_query</code><br>abci_query返回的value是base64编码的：</p>
<p><img src="https://lh3.googleusercontent.com/-Coi53j0PGeg/XAiKP9CoWQI/AAAAAAAAEG8/xZGmjD4j_IkZP5IttfLO3_eqiMqO9817wCHMYCw/I/rsp-query-base64.png" alt="rsp-query-base64"></p>
<p>我们可以用base64解码value字段的值：</p>
<p><code>~$ echo MQ== |  base64 -d</code></p>
<h2 id="应用状态的历史"><a href="#应用状态的历史" class="headerlink" title="应用状态的历史"></a>应用状态的历史</h2><p>现在观察RequestQuery的结构，注意其Height字段：</p>
<p><img src="https://lh3.googleusercontent.com/-B1cLCas3Egw/XAiKQbzFnrI/AAAAAAAAEHE/-EbkrsVWayAdEhI0NbfWs8TAxh4PrNVzgCHMYCw/I/req-query.png" alt="req-query"></p>
<p>对于状态机而言，当一个新的区块产生，其中的交易就会导致状态的迁移，因此状态是 与区块存在着对应关系 —— 在不同的区块高度，对应着状态机的不同状态：</p>
<p><img src="https://lh3.googleusercontent.com/-PMaNN5xMr5c/XAiKQZxy1gI/AAAAAAAAEHA/R6v9EUgQVSQNTNAcmAXCJ59MTUzTY8ACACHMYCw/I/state-and-block.png" alt="state-and-block"></p>
<p>因此对于ABCI应用而言，应当记录状态的历史变化，每一个区块高度，对应着不同版本的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type CounterApp struct &#123;</span><br><span class="line">  types.BaseApplication</span><br><span class="line">  Value int64</span><br><span class="line">  Version int64</span><br><span class="line">  History map[int64]int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在Commit()方法中递增Version（以便和区块高度保持一致），并记录状态历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Commit() types.ResponseCommit&#123;</span><br><span class="line">  app.Version += 1</span><br><span class="line">  app.History[app.Version] = app.Value</span><br><span class="line">  return types.ResponseCommit&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以根据RequestQuery中的Height值来返回对应版本的状态了，高度0意味着要 返回最新区块的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Query(req types.RequestQuery) types.ResponseQuery &#123;  </span><br><span class="line">  height := req.Height</span><br><span class="line">  if req.Height == 0 &#123;  height = app.Version &#125;</span><br><span class="line">  val := fmt.Sprintf(&quot;%d&quot;,app.History[height])</span><br><span class="line">  return types.ResponseQuery&#123;Value: []byte(val),Height: height&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在可以查询历史状态了：</p>
<p><code>$ curl http://localhost:26657/abci_query?height=1</code><br>结果如下：</p>
<p><img src="https://lh3.googleusercontent.com/-iaqEjfZ3gwU/XAiKQwD8ksI/AAAAAAAAEHk/4UdFTnR0u5EnV9NJPCOo19a0y3igU5AXQCHMYCw/I/rsp-query-version.png" alt="rsp-query-version"></p>
<h2 id="应用-区块链握手机制"><a href="#应用-区块链握手机制" class="headerlink" title="应用/区块链握手机制"></a>应用/区块链握手机制</h2><p>现在我们的计数应用已经在区块链中有了一些交易记录，也实现了基本的状态更新逻辑， 那么思考一个问题：如果重新启动节点（及ABCI应用），然后再次查询最后区块的状态值， 结果是8还是0？</p>
<p><img src="https://lh3.googleusercontent.com/-DYs7pd3LHbg/XAiKQ9lLU5I/AAAAAAAAEHc/c0fhZwbSepkIylfq9sCYoyQeDyP2QnUygCHMYCw/I/block-replay.png" alt="block-replay"></p>
<p>这个问题是有意义的，毕竟我们只是在内存里记录了状态值以及其历史，重新启动后， 内存中的状态数据已经丢失了。</p>
<p>你可以自己尝试一下，不出意外的话，还是会和重新启动之前一样，你得到的状态值 依然是8。</p>
<p>这是因为当tendermint节点连接ABCI应用后，会有一个握手同步的处理，tendermint会 向ABCI应用发送Info消息获取应用状态的最后区块高度，如果ABCI应用返回的区块高度 小于tendermint节点旳最后区块高度，tendermint就会认为ABCI应用漏掉了这些区块并 进行重放：</p>
<p><img src="https://lh3.googleusercontent.com/-w86qK175SHk/XAiKQojIWsI/AAAAAAAAEHQ/dr8Sp4Cl52ELAii04ICZmYFJC7LSKbkygCHMYCw/I/abci-handshake.png" alt="abci-handshake"></p>
<p>显然，由于我们没有明确处理Info消息，因此握手时tendermint会认为我们的计数应用 的区块高度为0，所以它会重放所有的区块，这意味着当重放结束，我们的计数器值还是 会回到8。</p>
<p>容易理解，我们不期望每次重新启动节点（及ABCI应用）都重放所有区块，那会非常耗时 并且体验很差。因此我们可以在Info()方法中返回状态机处理过的最后区块高度，你知道 它对应于我们的Version成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Info(req types.RequestInfo) types.ResponseInfo&#123;</span><br><span class="line">  return types.ResponseInfo&#123;LastBlockHeight:app.Version&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Info()的返回值是一个ResponseInfo结构，其成员如下：</p>
<p><img src="https://lh3.googleusercontent.com/-ibUWynGaIbg/XAiKQm0WlNI/AAAAAAAAEHM/SJmTwgZLEDkoY1E4j20t6lE5QF-q8mJaQCHMYCw/I/rsp-info.png" alt="rsp-info"></p>
<h2 id="应用状态的哈希值"><a href="#应用状态的哈希值" class="headerlink" title="应用状态的哈希值"></a>应用状态的哈希值</h2><p>根据tendermint的约定，ABCI应用在Commit()调用时返回当前状态的哈希，会由tendermint 写入下一个区块头中的app_hash部分，作为区块链状态的一部分：</p>
<p><img src="https://lh3.googleusercontent.com/-5_t-Zmml6MI/XAiKQsWX1wI/AAAAAAAAEHU/LpjL2tceE9werlFhK0Lgv8KyMU5ekkC2gCHMYCw/I/app-hash.png" alt="app-hash"></p>
<p>apphash用来表示某个区块时的应用状态特征，哈希函数自然是一个很好的选择，但tendermint 只要求这个值能够表达状态，因此我们理论上可以使用任何与状态相关的确定性的值。例如， 对于计数应用而言，我们可以直接使用计数器的值，因为这个状态本身很简单，不需要提取指纹了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Commit() types.ResponseCommit&#123;</span><br><span class="line">  app.Version += 1</span><br><span class="line">  app.Hash = []byte(fmt.Sprintf(&quot;%d&quot;,app.Value))</span><br><span class="line">  app.History[app.Version] = app.Value  </span><br><span class="line">  return types.ResponseCommit&#123;Data:app.Hash&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与此同时，在tendermint与abci应用握手时，如果涉及到区块重放，也会检查区块头记录的AppHash 与前一区块的Commit()返回的结果是否一致，因此，我们调整Info()来返回记录的当前状态的哈希：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Info(req types.RequestInfo) types.ResponseInfo&#123;</span><br><span class="line">  return types.ResponseInfo&#123;LastBlockHeight:app.Version,LastBlockAppHash:app.Hash &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="应用状态持久化"><a href="#应用状态持久化" class="headerlink" title="应用状态持久化"></a>应用状态持久化</h3><p>到目前位置，我们的应用状态都是保存在内存里，每次重新启动都会从零开始。 现在考虑把状态持久化到硬盘上。这包括两部分工作：在Commit()中保存状态到硬盘、 在创建应用实例时载入硬盘保存的状态。</p>
<p>理论上你可以使用任何存储机制，例如SQL数据库、NoSQL数据库、文件系统等等。 不过为了便于观察，我们采用JSON格式的平文件记录计数值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (app *CounterApp) Commit() types.ResponseCommit&#123;</span><br><span class="line">  app.Version += 1</span><br><span class="line">  app.History[app.Version] = app.Value</span><br><span class="line">  state,err := json.Marshal(app) </span><br><span class="line">  if err !=nil &#123; panic(err) &#125;</span><br><span class="line">  ioutil.WriteFile(&quot;./counter.state&quot;,state,0644)</span><br><span class="line">  return types.ResponseCommit&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，我们在实例化计数应用时，载入之前的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func NewCounterApp() *CounterApp &#123;</span><br><span class="line">  app := CounterApp&#123; History:map[int64]int&#123;&#125; &#125;</span><br><span class="line">  state, err := ioutil.ReadFile(&quot;./counter.state&quot;)</span><br><span class="line">  if err != nil &#123; return &amp;app &#125;</span><br><span class="line">  err = json.Unmarshal(state,&amp;app)</span><br><span class="line">  if err != nil &#123; return &amp;app &#125;</span><br><span class="line">  return &amp;app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们的状态已经持久化，可以查看一下counter.state的内容：</p>
<p><img src="https://lh3.googleusercontent.com/-vuFW5-Wup34/XAiKQxixafI/AAAAAAAAEHY/4nywQ_HUvAo-nD8jEznbHoG2V0QyP7qJwCHMYCw/I/state-persist.png" alt="state-persist"></p>
<h2 id="获得配套代码资料"><a href="#获得配套代码资料" class="headerlink" title="获得配套代码资料"></a>获得配套代码资料</h2><p>关注微信公众号<code>区块链001</code>, 回复<code>tendermint</code>获得</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;状态机与ABCI&quot;&gt;&lt;a href=&quot;#状态机与ABCI&quot; class=&quot;headerlink&quot; title=&quot;状态机与ABCI&quot;&gt;&lt;/a&gt;状态机与ABCI&lt;/h1&gt;&lt;h2 id=&quot;状态机&quot;&gt;&lt;a href=&quot;#状态机&quot; class=&quot;headerlink&quot; title=&quot;状态机&quot;&gt;&lt;/a&gt;状态机&lt;/h2&gt;&lt;p&gt;tendermint采用的分布式计算模型为状态机复制（State Machine Replication），其基本 思路就是通过在多个节点间通过同步输入序列来保证各节点状态机的同步。&lt;/p&gt;
&lt;p&gt;状态机是一种在通信软件、游戏、工业控制等领域应用非常广泛的计算模型，用来抽象地表示一个 系统的演化过程。状态机由一组（有限或无限的）状态以及激发状态迁移的外部输入组成， 对于确定性状态机而言，在某一个时刻一定处于一个确定的状态，而在一个状态下 针对特定输入的状态迁移也是确定的。&lt;/p&gt;
&lt;p&gt;现在让我们看一个计数器的状态以及其变化情况，在某一个特定时刻其状态为特定的数值：&lt;/p&gt;
&lt;p&gt;counter state machine&lt;br&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-4X19ZKNBNgA/XAiKDw17mvI/AAAAAAAAEGg/xhsVl_BXkwwJLl3Qq_RkCiJvZTCXqr7KQCHMYCw/I/sm-counter.png&quot; alt=&quot;sm-counte&quot;&gt;&lt;/p&gt;
&lt;p&gt;显然，计数器有无限个状态（1,2,3…），但只有三个触发动作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inc - 递增&lt;/li&gt;
&lt;li&gt;dec - 递减 &lt;/li&gt;
&lt;li&gt;reset - 复位
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
      <category term="状态机" scheme="http://gcblog/github.io/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
      <category term="ABCI" scheme="http://gcblog/github.io/tags/ABCI/"/>
    
  </entry>
  
  <entry>
    <title>tendermint初识</title>
    <link href="http://gcblog/github.io/2018/12/16/temdermint%E5%88%9D%E8%AF%86/"/>
    <id>http://gcblog/github.io/2018/12/16/temdermint初识/</id>
    <published>2018-12-16T14:29:43.000Z</published>
    <updated>2019-03-16T08:03:02.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>tendermint虽然定位于引擎，但它其实是一个完整的区块链实现。在这一部分 的课程中，我们将使用一个最小化的ABCI应用，来熟悉tendermint的主要组成 部分，以及使用tendermint进行去中心化应用开发的主要流程和工具。</p>
<p>下图列出了tendermint应用的主要构成部分：</p>
<p><img src="https://lh3.googleusercontent.com/-9h1wL3AOaT0/XAiI0CiYoSI/AAAAAAAAEFY/GhAg0H7tV28RgTVW-kATnVCc3CJ0zFiWwCHMYCw/I/td-arch.png" alt="td-arch"></p>
<p>tendermint提供了一个预构建的同名可执行程序，我们将学习如何使用这个程序 来初始化节点配置文件并启动节点。这个程序是完整的节点实现，除了通过P2P协议 与其他节点交换共识，同时还提供了RPC接口供客户端提交交易或者查询应用状态。</p>
<p>我们将创建一个最小化的ABCI应用，tendermint可执行程序通过ABCI接口与 应用程序交互，例如要求应用执行交易、或者转发来自RPC接口的状态查询请求。<br><a id="more"></a></p>
<h2 id="2-2-节点初始化"><a href="#2-2-节点初始化" class="headerlink" title="2.2 节点初始化"></a>2.2 节点初始化</h2><p>tendermint节点程序的行为非常依赖于配置文件，使用其init子命令 可以获得一组默认的初始化文件。 例如，在1#终端输入如下命令创建初始化文件：</p>
<p><code>~$ tendermint init</code><br>init子命令将在~/.tendermint目录下创建两个子目录data和config，分别用于 保存区块链数据和配置文件。</p>
<p>在data目录下将包含如下的数据文件，均为leveldb格式：</p>
<p>blockstore.db：区块链数据库<br>evidence.db：节点行为数据<br>state.db：区块链状态数据<br>tx_index.db：交易索引数据，<br>在config子目录下将包含如下的配置文件：</p>
<p>config.toml：节点软件配置文件<br>node_key.json：节点密钥文件，用于p2p通信加密<br>priv_validator.json：验证节点密钥文件，用于共识签名<br>genesis.json：创世文件<br>节点配置文件config.toml用来设置节点软件的运行参数，例如RPC监听端口等。 我们修改consensus.create_empty_blocks为false，即不出无交易的空块：</p>
<p>[consensus]<br><code>create_empty_blocks = false</code><br>重新初始化</p>
<p>在我们开发ABCI应用的过程中，往往需要对应用中的状态结构等信息进行调整，再次重新启动 后就可能导致原有的链数据和新的状态结构不兼容，因此需要时不时地重新初始化区块链数据。</p>
<p>当然你可以完全删除~/.tendermint目录，然后重新执行tendermint init命令。不过官方 的建议是使用unsafe_reset_all子命令来做这个事情，这个命令可以保留现有的配置而仅删除 数据文件。例如：</p>
<p><code>~$ tendermint unsafe_reset_all</code></p>
<h2 id="2-3-节点启动与停止"><a href="#2-3-节点启动与停止" class="headerlink" title="2.3 节点启动与停止"></a>2.3 节点启动与停止</h2><p>初始化之后，我们就可以启动节点了。在1#终端执行node子命令启动tendermint节点：</p>
<p><code>~$ tendermint node</code><br>可以看到tendermint在反复尝试abci应用的默认监听地址tcp://127.0.0.1:26658：</p>
<p><img src="https://lh3.googleusercontent.com/-86l_z4_4cOI/XAiI0AAqovI/AAAAAAAAEFc/CSAySg1umpQuUUlxharp6lXx3fqsjxm6wCHMYCw/I/try-abci.png" alt="try-abci"></p>
<p>显然，tendermint要求一个配套的abci应用才能正常工作，我们将在下一节解决这个 问题。</p>
<p>在目前这种状态下，如果需要退出tendermint的执行，可以切换到2#终端，使用pkill 命令终止其运行：</p>
<p><code>~$ pkill -9 tendermint</code></p>
<h2 id="2-4-编写最小化应用"><a href="#2-4-编写最小化应用" class="headerlink" title="2.4 编写最小化应用"></a>2.4 编写最小化应用</h2><p>tendermint开发包中已经包含了一个基本的ABCI应用实现类BaseApplication， 可以完成与tendermint节点旳基本交互：</p>
<p><img src="https://lh3.googleusercontent.com/-K-O5r4n20WY/XAiI0EFf2KI/AAAAAAAAEFU/VLxjrV5m3bwWOdn6p_BJRqmAhC0Q9WbWACHMYCw/I/abci-server.png" alt="abci-serve"></p>
<p>tendermint节点程序可以通过socket通信访问ABCI应用，因此我们使用abci/server 包的NewServer()函数创建一个SocketServer实例来启动这个应用。</p>
<p>例如，下面的代码在tendermint尝试连接的默认端口26658启动abci应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;github.com/tendermint/tendermint/abci/types&quot;</span><br><span class="line">  &quot;github.com/tendermint/tendermint/abci/server&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">  app := types.NewBaseApplication()</span><br><span class="line">  svr,err := server.NewServer(&quot;:26658&quot;,&quot;socket&quot;,app)</span><br><span class="line">  if err != nil &#123; panic(err) &#125;</span><br><span class="line">  svr.Start()</span><br><span class="line">  defer svr.Stop()</span><br><span class="line">  fmt.Println(&quot;abci server started&quot;)</span><br><span class="line">  select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将上述代码保存为~/repo/go/src/diy/c2/mini-app.go，然后在2#终端 进入c2目录并启动该应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ cd ~/repo/go/src/diy/c2</span><br><span class="line">~/repo/go/src/diy/c2$ go run mini-app.go</span><br></pre></td></tr></table></figure></p>
<p>现在回到1#终端重新启动tendermint节点：</p>
<p><code>~$ tendermint node</code><br>你可以看到这次tendermint节点启动成功了：</p>
<p><img src="https://lh3.googleusercontent.com/-y7rXlpkNGqw/XAiI0na91uI/AAAAAAAAEFw/TdIknhDNvl4mqDdgwlmiOn4cuONHG9XaACHMYCw/I/node-started.png" alt="node-started"></p>
<p>由于我们只有一个节点，因此tendermint会抱怨连接不到其他的节点，it‘s ok。</p>
<h2 id="2-5-RPC开发接口"><a href="#2-5-RPC开发接口" class="headerlink" title="2.5 RPC开发接口"></a>2.5 RPC开发接口</h2><p>在一个典型的（非理想化的）去中心化应用的开发中，除了需要开发链上应用 （例如ABCI应用或者以太坊中的智能合约），往往还需要开发传统的网页应用 /桌面应用/手机应用，以方便那些不可能自己部署节点旳用户：</p>
<p><img src="https://lh3.googleusercontent.com/-ecRo-qEvcKo/XAiI0c0ZmxI/AAAAAAAAEFg/toYaNUzLpYIaCYH4dA_Gyn4zPo2BZeBDwCHMYCw/I/light-user-case.png" alt="light-user-case"></p>
<p>和以太坊一样，tendermint的节点也提供了RPC接口供这些传统应用代码访问节点功能， 例如提交交易或者查询节点状态，其默认的RPC监听端口是26657。</p>
<p>首先确保1#终端和2#终端分别运行着tendermint和abci应用，然后我们切换到3# 终端，输入如下命令提交交易0x68656c6c6f —— 对应于字符串hello的16进制表示：</p>
<p><code>~$ curl http://localhost:26657/broadcast_tx_commit?tx=0x68656c6c6f</code><br>响应结果类似于下图，其中check_tx和deliver_tx来自于abci应用，而交易哈希 和区块高度则由tendermint节点内部处理得出：</p>
<p><img src="https://lh3.googleusercontent.com/-hUNne3_TT-s/XAiI0XLRMsI/AAAAAAAAEFs/RTT_P7hvznoEfKZeKFmzWe2CCnbdOhV0wCHMYCw/I/rpc-ret.png" alt="rpc-ret"></p>
<p>事实上，由于BaseApplication对于交易数据没有任何的限制，因此我们可以提交 任意有效的16进制表示，而这些交易都将成功地打包到区块里。</p>
<p>让我们看一下这个区块的内容，在3#终端输入如下命令：</p>
<p><code>~$ curl http://localhost:26657/block?height=2</code><br>注意结果中的Txs字段，它包含了该区块中所有交易的base64编码：</p>
<p><img src="https://lh3.googleusercontent.com/-nIJ0D0tG1mQ/XAiI0pPnFbI/AAAAAAAAEFo/W0JagkLkNdwziOQYThLJ8lQAGsZBplgKQCHMYCw/I/rpc-block.png" alt="rpc-block"></p>
<p>我们可以使用命令行工具base64简单地进行验证：</p>
<p><code>~$ echo aGVsbG8= | based64 -d</code><br>可以访问这里 查看tendermint区块结构的详细说明。</p>
<p>也可以通过哈希查看交易内容，在3#终端输入如下命令（注意，你的哈希可能与此不同）：</p>
<p><code>~$ curl http://localhost:26657/tx?hash=0x2CF24DBA5FB0A30E26E83B2AC5B9E29E1B161E5C</code><br>得到如下的结果：</p>
<p><img src="https://lh3.googleusercontent.com/-itMMg2kAhY0/XAiI0Qhia-I/AAAAAAAAEFk/Qp5Xk5adNDYPCgFL9_zjmzrtgWF4jFY4wCHMYCw/I/rpc-tx.png" alt="rpc-tx"></p>
<h2 id="获得配套代码资料"><a href="#获得配套代码资料" class="headerlink" title="获得配套代码资料"></a>获得配套代码资料</h2><p>关注微信公众号<code>区块链001</code>, 回复<code>tendermint</code>获得</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-概述&quot;&gt;&lt;a href=&quot;#2-1-概述&quot; class=&quot;headerlink&quot; title=&quot;2.1 概述&quot;&gt;&lt;/a&gt;2.1 概述&lt;/h2&gt;&lt;p&gt;tendermint虽然定位于引擎，但它其实是一个完整的区块链实现。在这一部分 的课程中，我们将使用一个最小化的ABCI应用，来熟悉tendermint的主要组成 部分，以及使用tendermint进行去中心化应用开发的主要流程和工具。&lt;/p&gt;
&lt;p&gt;下图列出了tendermint应用的主要构成部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-9h1wL3AOaT0/XAiI0CiYoSI/AAAAAAAAEFY/GhAg0H7tV28RgTVW-kATnVCc3CJ0zFiWwCHMYCw/I/td-arch.png&quot; alt=&quot;td-arch&quot;&gt;&lt;/p&gt;
&lt;p&gt;tendermint提供了一个预构建的同名可执行程序，我们将学习如何使用这个程序 来初始化节点配置文件并启动节点。这个程序是完整的节点实现，除了通过P2P协议 与其他节点交换共识，同时还提供了RPC接口供客户端提交交易或者查询应用状态。&lt;/p&gt;
&lt;p&gt;我们将创建一个最小化的ABCI应用，tendermint可执行程序通过ABCI接口与 应用程序交互，例如要求应用执行交易、或者转发来自RPC接口的状态查询请求。&lt;br&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>tendermint简介</title>
    <link href="http://gcblog/github.io/2018/12/10/tendermint%E7%AE%80%E4%BB%8B/"/>
    <id>http://gcblog/github.io/2018/12/10/tendermint简介/</id>
    <published>2018-12-10T06:28:21.000Z</published>
    <updated>2018-12-16T14:31:22.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-tendermint简介"><a href="#1-1-tendermint简介" class="headerlink" title="1.1 tendermint简介"></a>1.1 tendermint简介</h2><p>tendermint是一个开源的完整的区块链实现，可以用于公链或联盟链，其官方定位 是面向开发者的区块链共识引擎：</p>
<p>与其他区块链平台例如以太坊或者EOS相比，tendermint最大的特点是其差异化的定位： 尽管包含了区块链的完整实现，但它却是以SDK的形式将这些核心功能提供出来，供开发者 方便地定制自己的专有区块链：</p>
<p><img src="https://lh3.googleusercontent.com/-7tK7wrbhhT8/XAiIonVqubI/AAAAAAAAEFI/S_7isBa52LAk1s-_J-QCvvev28w581AdwCHMYCw/I/tendermint.png" alt="tendermint"></p>
<p>tendermint的SDK中包含了构造一个区块链节点旳绝大部分组件，例如加密算法、共识算法、 区块链存储、RPC接口、P2P通信等等，开发人员只需要根据其应用开发接口 （Application Blockchain Communication Interface）的要求实现自己 的应用即可。</p>
<p>ABCI是开发语言无关的，开发人员可以使用自己喜欢的任何语言来开发基于tendermint的 专用区块链。不过由于tendermint本身是采用go语言开发的，因此用go开发ABCI应用的一个额外好处 就是，你可以把tendermint完整的嵌入自己的应用，干净利落地交付一个单一的可执行文件。<br><a id="more"></a></p>
<h2 id="1-2-tendermint的共识算法"><a href="#1-2-tendermint的共识算法" class="headerlink" title="1.2 tendermint的共识算法"></a>1.2 tendermint的共识算法</h2><p>在技术方面，tendermint引以为傲的是其共识算法 —— 世界上第一个可以应用于公链的拜占庭 容错算法。tendermint曾于2016年国际区块链周获得最具创新奖，并在Hyperledger的雨燕（Burrow） 等诸多产品中被采纳为共识引擎。你可以点击 <a href="https://forum.cosmos.network/t/list-of-projects-in-cosmos-tendermint-ecosystem/243" target="_blank" rel="noopener">这里</a> 查看其应用案例。</p>
<p>tendermint采用的共识机制属于一种权益证明（ Proof Of Stake）算法，一组验证人 （Validator）代替了矿工（Miner）的角色，依据抵押的权益比例轮流出块：</p>
<p><img src="https://lh3.googleusercontent.com/-IXSEtA-dXcY/XAiIohkad-I/AAAAAAAAEFQ/7pD-ir6VXEIThFTDRL0SHkwwD6_jriy9ACHMYCw/I/consensus-pos.png" alt="consensus-pos"></p>
<p>由于避免了POW机制，tendermint可以实现很高的交易吞吐量。根据官方的说法，在 合理（理想）的应用数据结构支持下，可以达到42000交易/秒，引文参考 <a href="https://github.com/tendermint/tendermint/wiki/Benchmarks" target="_blank" rel="noopener">这里</a>。 不过在现实环境中，部署在全球的100个节点进行共识沟通，实际可以达到1000交易/秒。</p>
<p>tendermint同时是拜占庭容错的（Byzantine Fault Tolerance），因此对于3f+1个 验证节点组成的区块链，即使有f个节点出现拜占庭错误，也可以保证全局正确共识的达成。同时 在极端环境下，tendermint在交易安全与停机风险之间选择了安全，因此当超过f个验证节点发生 故障时，系统将停止工作。</p>
<p>什么是拜占庭错误？简单的说就是任何错误：既包括节点宕机、也包括恶意节点的欺骗和攻击。</p>
<p>tendermint共识机制的另一个特点就是其共识的最终确定性：一旦共识达成就是真的达成， 而不是像比特币或以太坊的共识是一种概率性质的确定性，还有可能在将来某个时刻失效。 因此在tendermint中不会出现区块链分叉的情况。</p>
<h2 id="1-3-tendermint-vs-以太坊"><a href="#1-3-tendermint-vs-以太坊" class="headerlink" title="1.3 tendermint vs. 以太坊"></a>1.3 tendermint vs. 以太坊</h2><p>tendermint的定位决定了在最终交付的节点软件分层中，应用程序占有相当部分的分量。 让我们通过与以太坊的对比来更好地理解这一点：</p>
<p><img src="https://lh3.googleusercontent.com/-oPtxJ3NzSfo/XAiIokGDwnI/AAAAAAAAEFM/YMXMTtwH6qA3UoKGgVgBUVFfWJ0ApVmowCHMYCw/I/td-vs-ether.png" alt="td-vs-ethe"></p>
<p>在上图中，tendermint结构中的abci应用和以太坊结构中的智能合约，都是由用户代码实现的。 显然，ABCI应用大致与EVM+合约的组合相匹配。</p>
<p>在以太坊中，节点是一个整体，开发者提供的智能合约则运行在受限的虚拟机环境中；而在 tendermint中，并不存在虚拟机这一层，应用程序是一个标准的操作系统进程，不受任何 的限制与约束 —— 听起来这很危险，但当你考虑下使用tendermint的目的是构建专有的区块链 时，这种灵活性反而更有优势了。</p>
<p>事实上，tendermint留下的应用层空间如此之大，以至于你完全可以在ABCI应用中实现一个 EVM，然后提供solidity合约开发能力，这就是超级账本的 <a href="https://cn.hyperledger.org/projects/hyperledger-burrow" target="_blank" rel="noopener">Burrow</a> 做的事情。</p>
<h2 id="获得配套代码资料"><a href="#获得配套代码资料" class="headerlink" title="获得配套代码资料"></a>获得配套代码资料</h2><p>关注微信公众号<code>区块链001</code>, 回复<code>tendermint</code>获得</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-tendermint简介&quot;&gt;&lt;a href=&quot;#1-1-tendermint简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 tendermint简介&quot;&gt;&lt;/a&gt;1.1 tendermint简介&lt;/h2&gt;&lt;p&gt;tendermint是一个开源的完整的区块链实现，可以用于公链或联盟链，其官方定位 是面向开发者的区块链共识引擎：&lt;/p&gt;
&lt;p&gt;与其他区块链平台例如以太坊或者EOS相比，tendermint最大的特点是其差异化的定位： 尽管包含了区块链的完整实现，但它却是以SDK的形式将这些核心功能提供出来，供开发者 方便地定制自己的专有区块链：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-7tK7wrbhhT8/XAiIonVqubI/AAAAAAAAEFI/S_7isBa52LAk1s-_J-QCvvev28w581AdwCHMYCw/I/tendermint.png&quot; alt=&quot;tendermint&quot;&gt;&lt;/p&gt;
&lt;p&gt;tendermint的SDK中包含了构造一个区块链节点旳绝大部分组件，例如加密算法、共识算法、 区块链存储、RPC接口、P2P通信等等，开发人员只需要根据其应用开发接口 （Application Blockchain Communication Interface）的要求实现自己 的应用即可。&lt;/p&gt;
&lt;p&gt;ABCI是开发语言无关的，开发人员可以使用自己喜欢的任何语言来开发基于tendermint的 专用区块链。不过由于tendermint本身是采用go语言开发的，因此用go开发ABCI应用的一个额外好处 就是，你可以把tendermint完整的嵌入自己的应用，干净利落地交付一个单一的可执行文件。&lt;br&gt;
    
    </summary>
    
      <category term="tendermint" scheme="http://gcblog/github.io/categories/tendermint/"/>
    
    
      <category term="tendermint" scheme="http://gcblog/github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>mongodb+golang+mac</title>
    <link href="http://gcblog/github.io/2018/07/09/mac%E4%B8%8B%E4%BD%BF%E7%94%A8golang%E6%93%8D%E4%BD%9Cmongodb/"/>
    <id>http://gcblog/github.io/2018/07/09/mac下使用golang操作mongodb/</id>
    <published>2018-07-09T12:01:50.000Z</published>
    <updated>2018-07-09T13:02:50.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h3><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p>
<h3 id="NoSql数据库的CAP理论"><a href="#NoSql数据库的CAP理论" class="headerlink" title="NoSql数据库的CAP理论"></a>NoSql数据库的CAP理论</h3><p>CAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/cap.png" alt=""></p>
<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<h3 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h3><p>用OSX 的 brew 来安装 mongodb<br><code>brew install mongodb</code> 或者 <code>sudo brew install mongodb</code></p>
<p>如果要安装支持 TLS/SSL 命令如下：<br><code>brew install mongodb --with-openssl</code></p>
<p>查看是否安装成功<br><code>mongod -version</code><br>如果显示版本信息，说明已经安装成功</p>
<h3 id="启动mongo"><a href="#启动mongo" class="headerlink" title="启动mongo"></a>启动mongo</h3><p>mongo默认会在根目录 /data/db 下启动服务，所以需要先创建此路径。<br><code>sudo mkdir -p /data/db</code></p>
<p>然后开启服务<br><code>mongod</code></p>
<p>或者开启指定路径的服务<br><code>mongod --dbpath=xxx</code></p>
<p>新开一个终端，输入命令<br><code>mongo</code><br>进入mongo系统</p>
<p>再次输入命令测试<br><code>show dbs</code><br>显示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br></pre></td></tr></table></figure>
<p>即已成功运行</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>显示数据库<br><code>show dbs</code><br>显示数据表<br><code>show collections</code><br>选择或者创建 mydb数据表<br><code>use mydb</code></p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>如果没有 user表 会自动创建<br><code>db.user.save({&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:2})</code></p>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>删除数据表<br><code>db.user.drop()</code></p>
<p>删除数据库<br><code>use mydb</code><br><code>db.dropDatasase()</code></p>
<p>删除记录<br><code>db.user.remove({&quot;name&quot;:&quot;zhangsan&quot;})</code></p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>查所有<br><code>db.user.find()</code><br>查 age=2<br><code>db.user.find({&quot;age&quot;:2})</code></p>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>只改动某一项值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.update(&#123;&quot;_id&quot; : ObjectId(&quot;5b41c89323c223baaa7d4ef1&quot;)&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>如果没有set，相当于覆盖这条记录</p>
<h3 id="golang中使用mongo"><a href="#golang中使用mongo" class="headerlink" title="golang中使用mongo"></a>golang中使用mongo</h3><p><img src="https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/mongo.png" alt=""></p>
<h3 id="golang-demo"><a href="#golang-demo" class="headerlink" title="golang demo"></a>golang demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;gopkg.in/mgo.v2&quot;</span><br><span class="line">	&quot;gopkg.in/mgo.v2/bson&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">	ID    bson.ObjectId `_id`</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const  (</span><br><span class="line">	dbUrl = &quot;127.0.0.1:27017&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line"></span><br><span class="line">	session,err := mgo.Dial(dbUrl)</span><br><span class="line"></span><br><span class="line">	if err != err &#123;</span><br><span class="line">		println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer session.Close()</span><br><span class="line">	session.SetMode(mgo.Monotonic, true) //设置一致性模式</span><br><span class="line"></span><br><span class="line">	//选择数据库</span><br><span class="line">	db := session.DB(&quot;mydb&quot;)</span><br><span class="line"></span><br><span class="line">	//选择数据表</span><br><span class="line">	collection := db.C(&quot;user&quot;)</span><br><span class="line"></span><br><span class="line">	//增  单条插入</span><br><span class="line">	p1 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125;</span><br><span class="line">	p2 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125;</span><br><span class="line"></span><br><span class="line">	err = collection.Insert(&amp;p1, &amp;p2)</span><br><span class="line"></span><br><span class="line">	//批量插入</span><br><span class="line">	var arr []interface&#123;&#125;</span><br><span class="line">	arr = append(arr, p1)</span><br><span class="line">	arr = append(arr, p2)</span><br><span class="line">	err = collection.Insert(arr...)</span><br><span class="line">	if err != err &#123;</span><br><span class="line">		println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//查第一条</span><br><span class="line">	result := Person&#123;&#125;</span><br><span class="line">	collection.Find(bson.M&#123;&quot;age&quot;:12&#125;).One(&amp;result)</span><br><span class="line">	fmt.Println(&quot;restlt&quot;,result)</span><br><span class="line"></span><br><span class="line">	//查多条</span><br><span class="line">	results := []Person&#123;&#125;</span><br><span class="line">	collection.Find(bson.M&#123;&quot;age&quot;:12&#125;).All(&amp;results)</span><br><span class="line">	fmt.Println(&quot;results&quot;,results, len(results))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//查表中数据总数</span><br><span class="line">	count, _:= collection.Find(nil).Count()</span><br><span class="line">	fmt.Println(count)</span><br><span class="line"></span><br><span class="line">	//查所有</span><br><span class="line">	arr2 := make([]Person, 0)</span><br><span class="line">	iterNew := collection.Find(nil).Iter()</span><br><span class="line">	err = iterNew.All(&amp;arr2)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;arr2&quot;,arr2)</span><br><span class="line"></span><br><span class="line">	//改(不加set就是覆盖)</span><br><span class="line">	collection.Update(bson.M&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:22&#125;&#125;)</span><br><span class="line">	collection.Update(bson.M&#123;&quot;age&quot;:22&#125;,bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:23&#125;&#125;)</span><br><span class="line">	collection.Update(bson.M&#123;&quot;name&quot;:&quot;lisi&quot;&#125;, bson.M&#123;&quot;name&quot;:&quot;lisi2&quot;,&quot;age&quot;:22&#125;)</span><br><span class="line"></span><br><span class="line">	//批量更新</span><br><span class="line">	collection.UpdateAll(bson.M&#123;&quot;age&quot;:22&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:44&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//删</span><br><span class="line"></span><br><span class="line">	//删除符合条件的第一条</span><br><span class="line">	//collection.Remove(bson.M&#123;&quot;name&quot;: &quot;lisi2&quot;&#125;)</span><br><span class="line"></span><br><span class="line">	//删除所有</span><br><span class="line">	_, err = collection.RemoveAll(bson.M&#123;&quot;name&quot;: &quot;lisi&quot;&#125;)</span><br><span class="line">	if err != err &#123;</span><br><span class="line">		println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//根据ID删除</span><br><span class="line">	var wangwu = Person&#123;&#125;</span><br><span class="line">	collection.Find(bson.M&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;).One(&amp;wangwu)</span><br><span class="line">	fmt.Println(wangwu, wangwu.ID.Hex(), wangwu.ID.String())</span><br><span class="line">	err =collection.RemoveId(wangwu.ID)</span><br><span class="line">	fmt.Println(&quot;delete&quot;,err)</span><br><span class="line">	</span><br><span class="line">	//删除集合</span><br><span class="line">  //collection.DropCollection()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MongoDB简介&quot;&gt;&lt;a href=&quot;#MongoDB简介&quot; class=&quot;headerlink&quot; title=&quot;MongoDB简介&quot;&gt;&lt;/a&gt;MongoDB简介&lt;/h3&gt;&lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。&lt;/p&gt;
&lt;h3 id=&quot;NoSql数据库的CAP理论&quot;&gt;&lt;a href=&quot;#NoSql数据库的CAP理论&quot; class=&quot;headerlink&quot; title=&quot;NoSql数据库的CAP理论&quot;&gt;&lt;/a&gt;NoSql数据库的CAP理论&lt;/h3&gt;&lt;p&gt;CAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://gcblog/github.io/categories/go/"/>
    
    
      <category term="分布式" scheme="http://gcblog/github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="mongodb" scheme="http://gcblog/github.io/tags/mongodb/"/>
    
      <category term="数据库" scheme="http://gcblog/github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>etcd多台服务器集群环境搭建使用</title>
    <link href="http://gcblog/github.io/2018/07/05/etcd%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8/"/>
    <id>http://gcblog/github.io/2018/07/05/etcd多台服务器集群环境搭建使用/</id>
    <published>2018-07-05T11:41:22.000Z</published>
    <updated>2018-07-05T11:42:35.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装-etcd"><a href="#下载安装-etcd" class="headerlink" title="下载安装 etcd"></a>下载安装 etcd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p $GOPATH/src/github.com/coreos</span><br><span class="line">$ git clone https://github.com/coreos/etcd.git</span><br><span class="line">$ cd etcd</span><br><span class="line">$ ./build</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP</p>
<p>进入到bin目录下<br><code>$ cd $GOPATH/src/github.com/coreos/etcd/bin</code></p>
<p>3个ip分别换成3太服务器真实的ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TOKEN=token-03</span><br><span class="line">CLUSTER_STATE=new</span><br><span class="line">NAME_1=machine-1</span><br><span class="line">NAME_2=machine-2</span><br><span class="line">NAME_3=machine-3</span><br><span class="line">HOST_1=192.168.1.105</span><br><span class="line">HOST_2=192.168.1.143</span><br><span class="line">HOST_3=192.168.1.103</span><br><span class="line">CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380</span><br></pre></td></tr></table></figure>
<p><strong>machine 1</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line"># For machine 1</span><br><span class="line">THIS_NAME=$&#123;NAME_1&#125;</span><br><span class="line">THIS_IP=$&#123;HOST_1&#125;</span><br><span class="line">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure>
<p><strong>machine 2</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line"># For machine 2</span><br><span class="line">THIS_NAME=$&#123;NAME_2&#125;</span><br><span class="line">THIS_IP=$&#123;HOST_2&#125;</span><br><span class="line">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure>
<p><strong>machine 3</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line"># For machine 3</span><br><span class="line">THIS_NAME=$&#123;NAME_3&#125;</span><br><span class="line">THIS_IP=$&#123;HOST_3&#125;</span><br><span class="line">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</span><br></pre></td></tr></table></figure>
<p>检测服务器运行是否正常</p>
<p>3个ip分别换成3太服务器真实的ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line">export ETCDCTL_API=3</span><br><span class="line">HOST_1=192.168.1.105</span><br><span class="line">HOST_2=192.168.1.143</span><br><span class="line">HOST_3=192.168.1.103</span><br><span class="line">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</span><br></pre></td></tr></table></figure>
<p>查看进入集群的服务器列表<br><code>./etcdctl --endpoints=$ENDPOINTS member list</code></p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS get foo</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo</span><br></pre></td></tr></table></figure>
<h2 id="根据前缀查询"><a href="#根据前缀查询" class="headerlink" title="根据前缀查询"></a>根据前缀查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS put web1 value1</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put web2 value2</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put web3 value3</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS get web --prefix</span><br><span class="line"></span><br><span class="line">web1</span><br><span class="line">value1</span><br><span class="line">web2</span><br><span class="line">value2</span><br><span class="line">web3</span><br><span class="line">value3</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=$ENDPOINTS put key myvalue</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS del key</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put k1 value1</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put k2 value2</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS del k --prefix</span><br></pre></td></tr></table></figure>
<h2 id="事务写入"><a href="#事务写入" class="headerlink" title="事务写入"></a>事务写入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</span><br><span class="line"></span><br><span class="line">compares:</span><br><span class="line">// 输入以下内容，输入结束按 两次回车</span><br><span class="line">value(&quot;user1&quot;) = &quot;bad&quot;      </span><br><span class="line"></span><br><span class="line">//如果 user1 = bad，则执行 get user1 </span><br><span class="line">success requests (get, put, del):</span><br><span class="line">get user1</span><br><span class="line"></span><br><span class="line">//如果 user1 != bad，则执行 put user1 good</span><br><span class="line">failure requests (get, put, del):</span><br><span class="line">put user1 good</span><br><span class="line"></span><br><span class="line">// 运行结果，执行 success</span><br><span class="line">SUCCESS</span><br><span class="line"></span><br><span class="line">user1</span><br><span class="line">bad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</span><br><span class="line">compares:</span><br><span class="line">value(&quot;user1&quot;) = &quot;111&quot;  </span><br><span class="line"></span><br><span class="line">// 如果 user1 = 111，则执行 get user1 </span><br><span class="line">success requests (get, put, del):</span><br><span class="line">get user1</span><br><span class="line"></span><br><span class="line">//如果 user1 != 111，则执行 put user1 2222</span><br><span class="line">failure requests (get, put, del):</span><br><span class="line">put user1 2222</span><br><span class="line"></span><br><span class="line">// 运行结果，执行 failure</span><br><span class="line">FAILURE</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">$ ./etcdctl --endpoints=$ENDPOINTS get user1</span><br><span class="line">user1</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS watch stock1</span><br><span class="line"></span><br><span class="line">// 新打开终端</span><br><span class="line">$ cd $GOPATH/src/github.com/coreos/etcd/bin</span><br><span class="line"></span><br><span class="line">export ETCDCTL_API=3</span><br><span class="line">HOST_1=192.168.1.126</span><br><span class="line">HOST_2=192.168.1.119</span><br><span class="line">HOST_3=192.168.1.103</span><br><span class="line">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put stock1 1000</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS watch stock --prefix</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put stock1 10</span><br><span class="line">./etcdctl --endpoints=$ENDPOINTS put stock2 20</span><br></pre></td></tr></table></figure>
<h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p><a href="https://coreos.com/etcd/docs/latest/demo.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/demo.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载安装-etcd&quot;&gt;&lt;a href=&quot;#下载安装-etcd&quot; class=&quot;headerlink&quot; title=&quot;下载安装 etcd&quot;&gt;&lt;/a&gt;下载安装 etcd&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir -p $GOPATH/src/github.com/coreos&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone https://github.com/coreos/etcd.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd etcd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ./build&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://gcblog/github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="etcd" scheme="http://gcblog/github.io/tags/etcd/"/>
    
      <category term="分布式" scheme="http://gcblog/github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="服务器集群" scheme="http://gcblog/github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>etcd在golang中的使用</title>
    <link href="http://gcblog/github.io/2018/07/05/etcd%E5%9C%A8golang%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://gcblog/github.io/2018/07/05/etcd在golang中的使用/</id>
    <published>2018-07-05T11:35:05.000Z</published>
    <updated>2018-07-05T11:36:17.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是etcd"><a href="#什么是etcd" class="headerlink" title="什么是etcd"></a>什么是etcd</h2><p>ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统<br>etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p>
<pre><code>1.    简单：基于HTTP+JSON的API让你用curl就可以轻松使用。
2.    安全：可选SSL客户认证机制。
3.    快速：每个实例每秒支持一千次写操作。
4.    可信：使用Raft算法充分实现了分布式。
</code></pre><p>!&lt;–more–&gt;</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在如下路径创建文件夹<br><code>$ mkdir -p $GOPATH/src/github.com/coreos</code></p>
<p>下载etcd包<br><code>$ git clone https://github.com/coreos/etcd.git</code></p>
<p>下载完后，然后依次执行下面命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd etcd</span><br><span class="line">$ ./build</span><br><span class="line">$ ./bin/etcd</span><br></pre></td></tr></table></figure></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;github.com/coreos/etcd/clientv3&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;github.com/coreos/etcd/mvcc/mvccpb&quot;</span><br><span class="line">	&quot;ketang/netWork/0604_Socket/Tool&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	dialTimeout = 5 * time.Second</span><br><span class="line">	requestTimeout = 2 * time.Second</span><br><span class="line">	endPoints = []string&#123;&quot;127.0.0.1:2379&quot;&#125; //etcd 默认接受数据的端口2379</span><br><span class="line">)</span><br><span class="line">//添加 删除 查找 前缀 延时</span><br><span class="line"></span><br><span class="line">var etcd *clientv3.Client</span><br><span class="line">func main()  &#123;</span><br><span class="line">	fmt.Println(Tool.GetLocalIp())</span><br><span class="line">	var err error</span><br><span class="line">	etcd, err =clientv3.New(clientv3.Config&#123;</span><br><span class="line">		Endpoints:endPoints,</span><br><span class="line">		DialTimeout:dialTimeout,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//添加</span><br><span class="line">	err = putValue(&quot;a&quot;, &quot;abc&quot;)</span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	//查找</span><br><span class="line">	result := getValue(&quot;a&quot;)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line"></span><br><span class="line">	//删除</span><br><span class="line">	cnt := delValue(&quot;a&quot;)</span><br><span class="line">	fmt.Println(&quot;delete:&quot;, cnt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	err = putValue(&quot;b1&quot;, &quot;abc1&quot;)</span><br><span class="line">	err = putValue(&quot;b2&quot;, &quot;abc2&quot;)</span><br><span class="line">	err = putValue(&quot;b3&quot;, &quot;abc3&quot;)</span><br><span class="line"></span><br><span class="line">	//按前缀查找</span><br><span class="line">	result = getValueWIthPrefix(&quot;b&quot;)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	for _,item := range result &#123;</span><br><span class="line">		fmt.Println(string(item.Key),string(item.Value))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//按前缀删除</span><br><span class="line">	cnt2 := delValueWithPrefix(&quot;b&quot;)</span><br><span class="line">	fmt.Println(&quot;批量删除：&quot;, cnt2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//事务处理</span><br><span class="line">	putValue(&quot;user1&quot;, &quot;zhangsan&quot;)</span><br><span class="line">	_,err = etcd.Txn(context.TODO()).</span><br><span class="line">		If(clientv3.Compare(clientv3.Value(&quot;user1&quot;),&quot;=&quot;, &quot;zhangsan&quot;)).</span><br><span class="line">		Then(clientv3.OpPut(&quot;user1&quot;, &quot;zhangsan&quot;)).</span><br><span class="line">		Else(clientv3.OpPut(&quot;user1&quot;, &quot;lisi&quot;)).Commit()</span><br><span class="line"></span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	result = getValue(&quot;user1&quot;)</span><br><span class="line">	fmt.Println(&quot;user1:&quot;, string(result[0].Value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//lease 设置有效时间</span><br><span class="line">	resp, err:= etcd.Grant(context.TODO(), 1)</span><br><span class="line">	_,err = etcd.Put(context.TODO(), &quot;username&quot;,&quot;wangwu&quot;,clientv3.WithLease(resp.ID))</span><br><span class="line"></span><br><span class="line">	time.Sleep(3 * time.Second)</span><br><span class="line"></span><br><span class="line">	v := getValue(&quot;username&quot;)</span><br><span class="line">	fmt.Println(&quot;lease:&quot;,v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//watch监听的使用</span><br><span class="line">	putValue(&quot;w&quot;, &quot;hello&quot;)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		rch := etcd.Watch(context.Background(),&quot;w&quot;)</span><br><span class="line">		for wresp := range  rch &#123;</span><br><span class="line">			for _,ev := range wresp.Events &#123;</span><br><span class="line">				fmt.Printf(&quot;watch&gt;&gt;w  %s %q %q\n&quot;, ev.Type,ev.Kv, ev.Kv)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	putValue(&quot;w&quot;, &quot;hello world!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//监听某个key在一定范围内 value的变化</span><br><span class="line">	//putValue(&quot;fo0&quot;, &quot;a&quot;)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		//监听范围 [fo0-fo3)</span><br><span class="line">		rch := etcd.Watch(context.Background(), &quot;fo0&quot;, clientv3.WithRange(&quot;fo3&quot;))</span><br><span class="line"></span><br><span class="line">		for wresp := range  rch &#123;</span><br><span class="line">			for _,ev := range wresp.Events &#123;</span><br><span class="line">				fmt.Printf(&quot;watch range  --   %s %q %q\n&quot;, ev.Type,ev.Kv, ev.Kv)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	putValue(&quot;fo0&quot;, &quot;b&quot;)</span><br><span class="line">	putValue(&quot;fo1&quot;, &quot;b&quot;)</span><br><span class="line">	putValue(&quot;fo2&quot;, &quot;c&quot;)</span><br><span class="line">	putValue(&quot;fo2.5&quot;, &quot;c&quot;)</span><br><span class="line">	putValue(&quot;fo3&quot;, &quot;c&quot;)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	time.Sleep(10 * time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加键值对</span><br><span class="line">func putValue(key, value string)  error  &#123;</span><br><span class="line">	_, err := etcd.Put(context.TODO(),key, value)</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">func getValue(key string) []*mvccpb.KeyValue  &#123;</span><br><span class="line">	resp, err := etcd.Get(context.TODO(), key)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return  nil</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return resp.Kvs</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回删除了几条数据</span><br><span class="line">func delValue(key string) int64  &#123;</span><br><span class="line">	res,err := etcd.Delete(context.TODO(),key)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return 0</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return res.Deleted</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//按照前缀删除</span><br><span class="line">func delValueWithPrefix(prefix string) int64  &#123;</span><br><span class="line">	res,err := etcd.Delete(context.TODO(),prefix,clientv3.WithPrefix())</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		return 0</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return res.Deleted</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getValueWIthPrefix(prefix string) []*mvccpb.KeyValue &#123;</span><br><span class="line">	resp, err := etcd.Get(context.TODO(), prefix, clientv3.WithPrefix())</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return  nil</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return resp.Kvs</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是etcd&quot;&gt;&lt;a href=&quot;#什么是etcd&quot; class=&quot;headerlink&quot; title=&quot;什么是etcd&quot;&gt;&lt;/a&gt;什么是etcd&lt;/h2&gt;&lt;p&gt;ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统&lt;br&gt;etcd作为一个受到ZooKe
    
    </summary>
    
      <category term="区块链" scheme="http://gcblog/github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="etcd" scheme="http://gcblog/github.io/tags/etcd/"/>
    
      <category term="分布式" scheme="http://gcblog/github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式Raft算法原理及实现</title>
    <link href="http://gcblog/github.io/2018/07/04/%E5%88%86%E5%B8%83%E5%BC%8FRaft%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/07/04/分布式Raft算法原理及实现/</id>
    <published>2018-07-04T11:37:18.000Z</published>
    <updated>2018-07-04T11:38:04.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Raft-状态"><a href="#Raft-状态" class="headerlink" title="Raft 状态"></a>Raft 状态</h2><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：</p>
<ul>
<li><code>follower（跟随者）</code> ：所有结点都以 <code>follower</code> 的状态开始。如果没收到 <code>leader</code>消息则会变成 <code>candidate</code>状态。</li>
<li><code>candidate（候选人）</code>：会向其他结点“拉选票”，如果得到大部分的票则成为<code>leader</code>。这个过程就叫做Leader选举(Leader Election)。</li>
<li><code>leader（领导者）</code>：所有对系统的修改都会先经过<code>leader</code>。</li>
</ul>
<a id="more"></a>
<h2 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h2><p>Raft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。</p>
<p>基于leader的方法，Raft算法可以分解成三个子问题：</p>
<p><code>Leader election</code> (领导选举)：原来的leader挂掉后，必须选出一个新的leader</p>
<p><code>Log replication</code> (日志复制)：leader从客户端接收日志，并复制到整个集群中</p>
<p><code>Safety</code> (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项</p>
<h2 id="Leader-election-领导选举"><a href="#Leader-election-领导选举" class="headerlink" title="Leader election (领导选举)"></a>Leader election (领导选举)</h2><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 <code>follower</code>(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，<code>follower</code> 会给当前term加1并且转换成<code>candidate</code>状态。</p>
<p>然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，</p>
<ul>
<li><p>他自己赢得了这次的选举</p>
<ul>
<li>如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。</li>
<li>当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。</li>
</ul>
</li>
<li><p>其他的服务器成为领导者</p>
<p>  如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理：</p>
<ul>
<li>如果leader的term大于或等于自身的term，那么改<code>candidate</code> 会转成<code>follower</code> 状态</li>
<li>如果leader的term小于自身的term，那么会拒绝该 <code>leader</code>，并继续保持<code>candidate</code> 状态</li>
</ul>
</li>
<li><p>一段时间之后没有任何一个获胜的人</p>
<ul>
<li><p>有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。</p>
</li>
<li><p>Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Log-replication-日志复制"><a href="#Log-replication-日志复制" class="headerlink" title="Log replication (日志复制)"></a>Log replication (日志复制)</h2><p>当选出 <code>leader</code> 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。<code>leader</code> 把指令追加成一个<code>log entry</code>，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，<code>leader</code> 会把该entry回放到状态机中，然后把结果返回给客户端。</p>
<p>当 <code>follower</code> 宕机或者运行较慢时，<code>leader</code> 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。</p>
<p>raft的log replication保证以下性质(Log Matching Property)：</p>
<ul>
<li><p>如果两个log entry有相同的index和term，那么它们存储相同的指令</p>
</li>
<li><p>如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的</p>
</li>
</ul>
<p>其中特性一通过以下保证：</p>
<ul>
<li>leader在一个特定的term和index下，只会创建一个log entry</li>
<li>log entry不会改变它们在日志中的位置</li>
</ul>
<p>特性二通过以下保证：</p>
<ul>
<li>AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm)</li>
</ul>
<p>如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。</p>
<p>为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。</p>
<h3 id="提交之前任期内的日志条目"><a href="#提交之前任期内的日志条目" class="headerlink" title="提交之前任期内的日志条目"></a>提交之前任期内的日志条目</h3><p>领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180123-10289.png" alt=""></p>
<p>如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下：</p>
<ul>
<li><p>图a中，S1被选为主，然后复制到log index为2的log entry到S2上</p>
</li>
<li><p>图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3)</p>
</li>
<li><p>图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉</p>
</li>
<li><p>图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry</p>
</li>
</ul>
<p>为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。</p>
<h3 id="安全性论证"><a href="#安全性论证" class="headerlink" title="安全性论证"></a>安全性论证</h3><p>以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180123-23202.png" alt=""></p>
<blockquote>
<p>如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p>
</blockquote>
<ol>
<li><p>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</p>
</li>
<li><p>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。</p>
</li>
<li><p>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</p>
</li>
<li><p>投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。</p>
</li>
<li><p>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</p>
<ul>
<li><p>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</p>
</li>
<li><p>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。</p>
</li>
</ul>
</li>
<li><p>因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目</p>
</li>
</ol>
<h3 id="跟随者和候选人崩溃"><a href="#跟随者和候选人崩溃" class="headerlink" title="跟随者和候选人崩溃"></a>跟随者和候选人崩溃</h3><p>跟随者或者候选人崩溃，会按如下处理：</p>
<ul>
<li>领导者会不断给它发送选举和追加日志的RPC，直到成功</li>
<li>跟随者会忽略它已经处理过的追加日志的RPC</li>
</ul>
<h3 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h3><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>广播时间</strong>指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；</p>
</li>
<li><p><strong>选举超时时间</strong>就是选举的超时时间限制</p>
</li>
<li><p><strong>平均故障间隔时间</strong>就是对于一台服务器而言，两次故障之间的平均时间。</p>
</li>
</ul>
<p>选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。</p>
<p>选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。</p>
<p>对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。</p>
<h2 id="动画演示-Raft"><a href="#动画演示-Raft" class="headerlink" title="动画演示 Raft"></a>动画演示 Raft</h2><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现效果：<br>4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;flag&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	LEADER = iota</span><br><span class="line">	CANDIDATE</span><br><span class="line">	FOLLOWER</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明地址信息</span><br><span class="line">type Addr struct &#123;</span><br><span class="line">	Host string  //ip</span><br><span class="line">	Port int</span><br><span class="line">	Addr string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RaftServer struct &#123;</span><br><span class="line"></span><br><span class="line">	Votes int //选票</span><br><span class="line">	Role int // 角色 follower candidate leader</span><br><span class="line">	Nodes []Addr</span><br><span class="line">	isElecting bool //判断当前节点是否处于选举中</span><br><span class="line">	Timeout int //选举间隔时间（也叫超时时间）</span><br><span class="line">	ElecChan chan bool //通道信号</span><br><span class="line">	HeartBeatChan chan bool  //leader 的心跳信号</span><br><span class="line">	Port int //端口号</span><br><span class="line"></span><br><span class="line">	//网页接收到的参数 由主节点向子节点传参</span><br><span class="line">	CusMsg chan string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rs *RaftServer)changeRole(role int)  &#123;</span><br><span class="line">	switch role &#123;</span><br><span class="line">	case LEADER:</span><br><span class="line">		fmt.Println(&quot;leader&quot;)</span><br><span class="line">	case CANDIDATE:</span><br><span class="line">		fmt.Println(&quot;candidate&quot;)</span><br><span class="line">	case FOLLOWER:</span><br><span class="line">		fmt.Println(&quot;follower&quot;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	rs.Role = role</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rs *RaftServer)resetTimeout()  &#123;</span><br><span class="line">	//Raft系统一般为1500-3000毫秒选一次</span><br><span class="line">	rs.Timeout =  2000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行服务器</span><br><span class="line">func (rs *RaftServer)Run()  &#123;</span><br><span class="line">	//rs监听 是否有人 给我投票</span><br><span class="line">	listen , _ := net.Listen(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(rs.Port))</span><br><span class="line"></span><br><span class="line">	defer listen.Close()</span><br><span class="line"></span><br><span class="line">	go rs.elect()</span><br><span class="line"></span><br><span class="line">	//控制投票时间</span><br><span class="line">	go rs.electTimeDuration()</span><br><span class="line"></span><br><span class="line">	//go rs.printRole()</span><br><span class="line"></span><br><span class="line">	// 主节点发送心跳</span><br><span class="line">	go rs.sendHeartBeat()</span><br><span class="line">	//</span><br><span class="line">	go rs.sendDataToOtherNodes()</span><br><span class="line"></span><br><span class="line">	//监听http协议</span><br><span class="line">	go rs.setHttpServer()</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		conn,_ := listen.Accept()</span><br><span class="line">		go func()&#123;</span><br><span class="line"></span><br><span class="line">			for &#123;</span><br><span class="line">				by := make([]byte, 1024)</span><br><span class="line">				n,_:= conn.Read(by)</span><br><span class="line">				fmt.Println(&quot;收到消息&quot;, string(by[:n]))</span><br><span class="line"></span><br><span class="line">				value := string(by[:n])</span><br><span class="line">				v,_ := strconv.Atoi(value)</span><br><span class="line">				if v == rs.Port &#123;</span><br><span class="line">					rs.Votes++</span><br><span class="line">					fmt.Println(&quot;当前票数：&quot;, rs.Votes)</span><br><span class="line">					// leader 选举成功</span><br><span class="line">					if VoteSuccess(rs.Votes, 5) == true &#123;</span><br><span class="line">						fmt.Printf(&quot;我是 %v, 我被选举成leader&quot;, rs.Port)</span><br><span class="line"></span><br><span class="line">						//通知其他节点。停止选举</span><br><span class="line">						//重置其他节点状态和票数</span><br><span class="line">						rs.VoteToOther(&quot;stopVote&quot;)</span><br><span class="line">						rs.isElecting = false</span><br><span class="line">						//改变当前节点状态</span><br><span class="line"></span><br><span class="line">						rs.changeRole(LEADER)</span><br><span class="line">						break</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				//收到leader发来的消息</span><br><span class="line">				if strings.HasPrefix(string(by[:n]), &quot;stopVote&quot;) &#123;</span><br><span class="line">					//停止给别人投票</span><br><span class="line">					rs.isElecting = false</span><br><span class="line">					//回退自己的状态</span><br><span class="line">					rs.changeRole(FOLLOWER)</span><br><span class="line">					break</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func VoteSuccess(vote int, target int) bool  &#123;</span><br><span class="line">	if vote &gt;= target &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//发送数据)</span><br><span class="line">func (rs *RaftServer)VoteToOther(data string)  &#123;</span><br><span class="line">	for _,k := range rs.Nodes &#123;</span><br><span class="line">		if k.Port != rs.Port &#123;</span><br><span class="line">			if data == &quot;1234&quot; &#123;</span><br><span class="line">				fmt.Println(&quot;-------------&quot;, k.Port)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			label :conn,err := net.Dial(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(k.Port))</span><br><span class="line">			for  &#123;</span><br><span class="line">				if err != nil &#123;</span><br><span class="line">					time.Sleep(1*time.Second)</span><br><span class="line">					goto  label</span><br><span class="line">				&#125;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			conn.Write([]byte(data))</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给别人投票</span><br><span class="line">func (rs *RaftServer)elect()  &#123;</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		//通过通道确定现在可以给别人投票</span><br><span class="line"></span><br><span class="line">		&lt;- rs.ElecChan</span><br><span class="line"></span><br><span class="line">		//给其他节点投票，不能投给自己</span><br><span class="line">		vote := getVoteNum()</span><br><span class="line"></span><br><span class="line">		rs.VoteToOther(strconv.Itoa(vote))</span><br><span class="line">		// 设置选举状态</span><br><span class="line">		if rs.Role != LEADER &#123;</span><br><span class="line">			rs.changeRole(CANDIDATE)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			//是leader的情况</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getVoteNum() int  &#123;</span><br><span class="line"></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	return rand.Intn(4) + 5000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (rs *RaftServer)electTimeDuration()  &#123;</span><br><span class="line">	//</span><br><span class="line">	fmt.Println(&quot;+++&quot;, rs.isElecting)</span><br><span class="line">	for &#123;</span><br><span class="line">		if rs.isElecting &#123;</span><br><span class="line"></span><br><span class="line">			rs.ElecChan &lt;- true</span><br><span class="line">			time.Sleep(time.Duration(rs.Timeout) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印当前对象的角色</span><br><span class="line">func (rs *RaftServer)printRole()  &#123;</span><br><span class="line">	for  &#123;</span><br><span class="line">		time.Sleep(1 * time.Second)</span><br><span class="line">		fmt.Println(rs.Port, &quot;状态为&quot;, rs.Role, rs.isElecting)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	//获取参数</span><br><span class="line">	//运行  go run main.go -p 5000  (p 后面就是要启动的端口)</span><br><span class="line">	port := flag.Int(&quot;p&quot;,1234,&quot;port&quot;)</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(*port)</span><br><span class="line"></span><br><span class="line">	rs := RaftServer&#123;&#125;</span><br><span class="line">	rs.isElecting = true</span><br><span class="line">	rs.Votes = 0</span><br><span class="line">	rs.Role = FOLLOWER</span><br><span class="line">	//控制是否开始投票</span><br><span class="line">	rs.ElecChan = make(chan bool)</span><br><span class="line">	rs.HeartBeatChan = make(chan bool)</span><br><span class="line">	rs.CusMsg = make(chan string)</span><br><span class="line">	rs.resetTimeout()</span><br><span class="line">	rs.Nodes = []Addr&#123;</span><br><span class="line">		&#123;&quot;127.0.0.1&quot;,5000,&quot;5000&quot;&#125;,</span><br><span class="line">		&#123;&quot;127.0.0.1&quot;,5001,&quot;5001&quot;&#125;,</span><br><span class="line">		&#123;&quot;127.0.0.1&quot;,5002,&quot;5002&quot;&#125;,</span><br><span class="line">		&#123;&quot;127.0.0.1&quot;,5003,&quot;5003&quot;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	rs.Port = *port</span><br><span class="line"></span><br><span class="line">	rs.Run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//主节点发送心跳信号给其他节点</span><br><span class="line">func (rs *RaftServer)sendHeartBeat()  &#123;</span><br><span class="line">	// 每隔1s 发送一次心跳</span><br><span class="line">	for &#123;</span><br><span class="line">		time.Sleep(1 * time.Second)</span><br><span class="line">		if rs.Role == LEADER &#123;</span><br><span class="line">			//发送消息</span><br><span class="line">			rs.VoteToOther(&quot;heat beating&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过leader 给其他所有子节点发送数据</span><br><span class="line">func (rs *RaftServer)sendDataToOtherNodes()  &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		msg :=&lt;-rs.CusMsg</span><br><span class="line">		if rs.Role == LEADER &#123;</span><br><span class="line">			//发送消息</span><br><span class="line">			rs.VoteToOther(msg)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开启http服务器</span><br><span class="line">func (rs *RaftServer)setHttpServer()  &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(&quot;/req&quot;, rs.request)</span><br><span class="line">	httpPort := rs.Port + 10</span><br><span class="line">	if err:=http.ListenAndServe(&quot;:&quot;+strconv.Itoa(httpPort), nil); err == nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//leader向其他子节点发送数据</span><br><span class="line">func (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">	request.ParseForm()</span><br><span class="line">	if len(request.Form[&quot;data&quot;][0]) &gt; 0 &#123;</span><br><span class="line">		writer.Write([]byte(&quot;ok&quot;))</span><br><span class="line">		fmt.Println(request.Form[&quot;data&quot;][0])</span><br><span class="line">		rs.CusMsg &lt;- request.Form[&quot;data&quot;][0]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：<br>开启4个终端 分别执行 </p>
<ul>
<li>go run main.go -p 5000</li>
<li>go run main.go -p 5001</li>
<li>go run main.go -p 5002</li>
<li>go run main.go -p 5003</li>
</ul>
<p>如果5001成为了leader，在浏览器输入<code>http://127.0.0.1:5011/req?data=XXX</code><br>xxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Raft-状态&quot;&gt;&lt;a href=&quot;#Raft-状态&quot; class=&quot;headerlink&quot; title=&quot;Raft 状态&quot;&gt;&lt;/a&gt;Raft 状态&lt;/h2&gt;&lt;p&gt;一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;follower（跟随者）&lt;/code&gt; ：所有结点都以 &lt;code&gt;follower&lt;/code&gt; 的状态开始。如果没收到 &lt;code&gt;leader&lt;/code&gt;消息则会变成 &lt;code&gt;candidate&lt;/code&gt;状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;candidate（候选人）&lt;/code&gt;：会向其他结点“拉选票”，如果得到大部分的票则成为&lt;code&gt;leader&lt;/code&gt;。这个过程就叫做Leader选举(Leader Election)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leader（领导者）&lt;/code&gt;：所有对系统的修改都会先经过&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://gcblog/github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://gcblog/github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Raft" scheme="http://gcblog/github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>拜占庭PBFT简单实现</title>
    <link href="http://gcblog/github.io/2018/07/03/%E6%8B%9C%E5%8D%A0%E5%BA%ADPBFT%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/07/03/拜占庭PBFT简单实现/</id>
    <published>2018-07-03T10:57:53.000Z</published>
    <updated>2018-07-03T11:00:39.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PBFT（拜占庭容错）"><a href="#PBFT（拜占庭容错）" class="headerlink" title="PBFT（拜占庭容错）"></a>PBFT（拜占庭容错）</h2><p>基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p>
<p>其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：</p>
<ol>
<li>Request：请求端C发送请求到任意一节点，这里是0</li>
<li>Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123</li>
<li>Prepare：123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播</li>
<li>Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求<br>5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈</li>
</ol>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明节点信息,代表各个小国家</span><br><span class="line">type nodeInfo struct &#123;</span><br><span class="line">	//标示</span><br><span class="line">	id string</span><br><span class="line">	//准备访问的方法</span><br><span class="line">	path string</span><br><span class="line">	//服务器做出的相应</span><br><span class="line">	writer http.ResponseWriter</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//存放四个国家的地址</span><br><span class="line">var nodeTable = make(map[string]string)</span><br><span class="line"></span><br><span class="line">//拜占庭在Fabric中的使用</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	//获取执行的参数</span><br><span class="line">	userId :=os.Args[1]//获取执行的第一个参数</span><br><span class="line">	fmt.Println(userId)</span><br><span class="line"></span><br><span class="line">	//./main Apple</span><br><span class="line"></span><br><span class="line">	//创建四个国家的地址</span><br><span class="line">	nodeTable = map[string]string &#123;</span><br><span class="line">		&quot;Apple&quot;:&quot;localhost:1111&quot;,</span><br><span class="line">		&quot;MS&quot;:&quot;localhost:1112&quot;,</span><br><span class="line">		&quot;Google&quot;:&quot;localhost:1113&quot;,</span><br><span class="line">		&quot;IBM&quot;:&quot;localhost:1114&quot;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node:=nodeInfo&#123;userId,nodeTable[userId],nil&#125;</span><br><span class="line">	fmt.Println(node)</span><br><span class="line"></span><br><span class="line">	//http协议的回调函数</span><br><span class="line">	//http://localhost:1111/req?warTime=8888</span><br><span class="line">	http.HandleFunc(&quot;/req&quot;,node.request)</span><br><span class="line">	http.HandleFunc(&quot;/prePrepare&quot;,node.prePrepare)</span><br><span class="line">	http.HandleFunc(&quot;/prepare&quot;,node.prepare)</span><br><span class="line">	http.HandleFunc(&quot;/commit&quot;,node.commit)</span><br><span class="line"></span><br><span class="line">	//启动服务器</span><br><span class="line">	if err:=http.ListenAndServe(node.path,nil);err!=nil &#123;</span><br><span class="line">		fmt.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此函数是http访问时候req命令的请求回调函数</span><br><span class="line">func (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line">	//设置允许解析参数</span><br><span class="line">	request.ParseForm()</span><br><span class="line">	//如果有参数值，则继续处理</span><br><span class="line">	if (len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</span><br><span class="line">		node.writer = writer</span><br><span class="line">		//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播</span><br><span class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prePrepare&quot;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//由主节点向其他节点做广播</span><br><span class="line">func (node *nodeInfo)broadcast(msg string ,path string )&#123;</span><br><span class="line">	//遍历所有的国家</span><br><span class="line">	for nodeId,url:=range nodeTable &#123;</span><br><span class="line"></span><br><span class="line">		if nodeId == node.id &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		//调用Get请求</span><br><span class="line">		//http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;)</span><br><span class="line">		http.Get(&quot;http://&quot;+url+path+&quot;?warTime=&quot;+msg+&quot;&amp;nodeId=&quot;+node.id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) &#123;</span><br><span class="line">	request.ParseForm()</span><br><span class="line">	//fmt.Println(&quot;hello world&quot;)</span><br><span class="line">	//在做分发</span><br><span class="line">	if(len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</span><br><span class="line">		//分发给其他三个人</span><br><span class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">	request.ParseForm()</span><br><span class="line">	//调用验证</span><br><span class="line">	if len(request.Form[&quot;warTime&quot;])&gt;0&#123;</span><br><span class="line">		fmt.Println(request.Form[&quot;warTime&quot;][0])</span><br><span class="line">	&#125;</span><br><span class="line">	if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</span><br><span class="line">		fmt.Println(request.Form[&quot;nodeId&quot;][0])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node.authentication(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var authenticationsuccess = true</span><br><span class="line">var authenticationMap = make(map[string]string)</span><br><span class="line">//获得除了本节点外的其他节点数据</span><br><span class="line">func (node *nodeInfo)authentication(request *http.Request) &#123;</span><br><span class="line"></span><br><span class="line">	//接收参数</span><br><span class="line">	request.ParseForm()</span><br><span class="line"></span><br><span class="line">	if authenticationsuccess!=false  &#123;</span><br><span class="line">		if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</span><br><span class="line">			authenticationMap[request.Form[&quot;nodeId&quot;][0]]=&quot;ok&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if len(authenticationMap)&gt;len(nodeTable)/3 &#123;</span><br><span class="line">		//则拜占庭原理实现,通过commit反馈给浏览器</span><br><span class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">	//给浏览器反馈相应</span><br><span class="line">	io.WriteString(node.writer,&quot;ok&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何运行：开启4个终端，eg：go run main.go Apple  …<br>然后在浏览器输入：<code>http://localhost:1112/req?warTime=1234</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PBFT（拜占庭容错）&quot;&gt;&lt;a href=&quot;#PBFT（拜占庭容错）&quot; class=&quot;headerlink&quot; title=&quot;PBFT（拜占庭容错）&quot;&gt;&lt;/a&gt;PBFT（拜占庭容错）&lt;/h2&gt;&lt;p&gt;基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Request：请求端C发送请求到任意一节点，这里是0&lt;/li&gt;
&lt;li&gt;Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123&lt;/li&gt;
&lt;li&gt;Prepare：123,收到后记录并再次广播，1-&amp;gt;023，2-&amp;gt;013，3因为宕机无法广播&lt;/li&gt;
&lt;li&gt;Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求&lt;br&gt;5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="拜占庭" scheme="http://gcblog/github.io/tags/%E6%8B%9C%E5%8D%A0%E5%BA%AD/"/>
    
      <category term="PBFT" scheme="http://gcblog/github.io/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>共识算法DPOS原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/29/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95DPOS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/29/共识算法DPOS原理及实现/</id>
    <published>2018-06-29T11:31:58.000Z</published>
    <updated>2018-06-29T11:34:46.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>DPOS：Delegated Proof of Stake，委任权益证明<br>它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。</p>
<h2 id="算法具体实现原理"><a href="#算法具体实现原理" class="headerlink" title="算法具体实现原理"></a>算法具体实现原理</h2><p>假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。</p>
<a id="more"></a>
<h2 id="代码简单实现其原理"><a href="#代码简单实现其原理" class="headerlink" title="代码简单实现其原理"></a>代码简单实现其原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;crypto/sha256&quot;</span><br><span class="line">	&quot;encoding/hex&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Block struct &#123;</span><br><span class="line">	Index int</span><br><span class="line">	Timestamp string</span><br><span class="line">	Prehash string</span><br><span class="line">	Hash string</span><br><span class="line">	Data []byte</span><br><span class="line"></span><br><span class="line">	delegate *Node// 代理 区块由哪个节点挖出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func GenesisBlock()  Block &#123;</span><br><span class="line">	gene := Block&#123;0, time.Now().String(),&quot;&quot;, &quot;&quot;, []byte(&quot;genesis block&quot;), nil&#125;</span><br><span class="line"></span><br><span class="line">	gene.Hash = string(blockHash(gene))</span><br><span class="line"></span><br><span class="line">	return Block&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func blockHash(block Block) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	record := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)</span><br><span class="line"></span><br><span class="line">	h := sha256.New()</span><br><span class="line">	h.Write([]byte(record))</span><br><span class="line">	hashed := h.Sum(nil)</span><br><span class="line">	return hashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节点类型</span><br><span class="line">type Node struct &#123;</span><br><span class="line">	Name  string //节点名称</span><br><span class="line">	Votes int    // 被选举的票数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block  &#123;</span><br><span class="line"></span><br><span class="line">	var newBlock = Block&#123;lastBlock.Index+1, time.Now().String(), lastBlock.Hash, &quot;&quot;, data, nil&#125;</span><br><span class="line"></span><br><span class="line">	newBlock.Hash = hex.EncodeToString(blockHash(newBlock))</span><br><span class="line">	newBlock.delegate = node</span><br><span class="line">	return newBlock</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建节点</span><br><span class="line">var NodeArr = make([]Node,10)</span><br><span class="line">func CreateNode() &#123;</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		name := fmt.Sprintf(&quot;NODE %d num&quot;, i+1)</span><br><span class="line">		NodeArr[i] = Node&#123;name, 0&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简单模拟投票</span><br><span class="line">func Vote()  &#123;</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		rand.Seed(time.Now().UnixNano())</span><br><span class="line">		vote := rand.Intn(10) + 1</span><br><span class="line">		NodeArr[i].Votes = vote</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//选出票数最多的前3位</span><br><span class="line">func SortNodes() []Node  &#123;</span><br><span class="line">	n:= NodeArr</span><br><span class="line">	for i := 0; i&lt;len(n) ;i++  &#123;</span><br><span class="line">		for j := 0; j &lt; len(n)-1 ;j++  &#123;</span><br><span class="line">			if n[j].Votes &lt; n[j+1].Votes &#123;</span><br><span class="line">				n[j],n[j+1] = n[j+1],n[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return n[:3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	CreateNode()</span><br><span class="line">	fmt.Println(NodeArr)</span><br><span class="line">	Vote()</span><br><span class="line">	nodes := SortNodes()</span><br><span class="line"></span><br><span class="line">	fmt.Println(nodes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//创建创世区块</span><br><span class="line">	gene := GenesisBlock()</span><br><span class="line"></span><br><span class="line">	lastBlock := gene</span><br><span class="line">	for i:= 0; i&lt; len(nodes) ;i++  &#123;</span><br><span class="line">		lastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(&quot;new block %d&quot;,i)))</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">竞选的节点 [&#123;第 1 个节点 0&#125; &#123;第 2 个节点 0&#125; &#123;第 3 个节点 0&#125; &#123;第 4 个节点 0&#125; &#123;第 5 个节点 0&#125; &#123;第 6 个节点 0&#125; &#123;第 7 个节点 0&#125; &#123;第 8 个节点 0&#125; &#123;第 9 个节点 0&#125; &#123;第 10 个节点 0&#125;]</span><br><span class="line">选出的节点 [&#123;第 10 个节点 8&#125; &#123;第 4 个节点 7&#125; &#123;第 3 个节点 6&#125;]</span><br><span class="line">第 10 个节点 出块 &#123;1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357  0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000&#125;</span><br><span class="line">第 4 个节点 出块 &#123;2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018&#125;</span><br><span class="line">第 3 个节点 出块 &#123;3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理简介&quot;&gt;&lt;a href=&quot;#原理简介&quot; class=&quot;headerlink&quot; title=&quot;原理简介&quot;&gt;&lt;/a&gt;原理简介&lt;/h2&gt;&lt;p&gt;DPOS：Delegated Proof of Stake，委任权益证明&lt;br&gt;它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。&lt;/p&gt;
&lt;h2 id=&quot;算法具体实现原理&quot;&gt;&lt;a href=&quot;#算法具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;算法具体实现原理&quot;&gt;&lt;/a&gt;算法具体实现原理&lt;/h2&gt;&lt;p&gt;假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DPOS" scheme="http://gcblog/github.io/tags/DPOS/"/>
    
      <category term="共识算法" scheme="http://gcblog/github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>共识算法POS原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/29/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95POS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/29/共识算法POS原理及实现/</id>
    <published>2018-06-29T11:31:41.000Z</published>
    <updated>2018-06-29T11:33:55.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POS简介"><a href="#POS简介" class="headerlink" title="POS简介"></a>POS简介</h2><p>POS：Proof of Stake，股权证明<br>类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。<br>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。</p>
<h2 id="算法具体实现原理"><a href="#算法具体实现原理" class="headerlink" title="算法具体实现原理"></a>算法具体实现原理</h2><p>每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。</p>
<a id="more"></a>
<h2 id="代码简单实现其原理"><a href="#代码简单实现其原理" class="headerlink" title="代码简单实现其原理"></a>代码简单实现其原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;crypto/sha256&quot;</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;encoding/hex&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//实现pos挖矿的原理</span><br><span class="line"></span><br><span class="line">type Block struct &#123;</span><br><span class="line">	Index int</span><br><span class="line">	Data string //</span><br><span class="line">	PreHash string</span><br><span class="line">	Hash string</span><br><span class="line">	Timestamp string</span><br><span class="line">	//记录挖矿节点</span><br><span class="line">	Validator *Node</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func genesisBlock() Block  &#123;</span><br><span class="line"></span><br><span class="line">	var genesBlock  = Block&#123;0, &quot;Genesis block&quot;,&quot;&quot;,&quot;&quot;,time.Now().String(),&amp;Node&#123;0, 0, &quot;dd&quot;&#125;&#125;</span><br><span class="line">	genesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock))</span><br><span class="line">	return genesBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BlockHash(block *Block) []byte  &#123;</span><br><span class="line">	record := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address</span><br><span class="line">	h := sha256.New()</span><br><span class="line">	h.Write([]byte(record))</span><br><span class="line">	hashed := h.Sum(nil)</span><br><span class="line"></span><br><span class="line">	return hashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建全节点类型</span><br><span class="line">type Node struct &#123;</span><br><span class="line">	Tokens int //持币数量</span><br><span class="line">	Days int //持币时间</span><br><span class="line">	Address string //地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建5个节点</span><br><span class="line">//算法的实现要满足 持币越多的节点越容易出块</span><br><span class="line">var nodes = make([]Node, 5)</span><br><span class="line">//存放节点的地址</span><br><span class="line">var addr = make([]*Node, 15)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func InitNodes()  &#123;</span><br><span class="line"></span><br><span class="line">	nodes[0] = Node&#123;1, 1, &quot;0x12341&quot;&#125;</span><br><span class="line">	nodes[1] = Node&#123;2, 1, &quot;0x12342&quot;&#125;</span><br><span class="line">	nodes[2] = Node&#123;3, 1, &quot;0x12343&quot;&#125;</span><br><span class="line">	nodes[3] = Node&#123;4, 1, &quot;0x12344&quot;&#125;</span><br><span class="line">	nodes[4] = Node&#123;5, 1, &quot;0x12345&quot;&#125;</span><br><span class="line"></span><br><span class="line">	cnt :=0</span><br><span class="line">	for i:=0;i&lt;5;i++ &#123;</span><br><span class="line">		for j:=0;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123;</span><br><span class="line">			addr[cnt] = &amp;nodes[i]</span><br><span class="line">			cnt++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//采用Pos共识算法进行挖矿</span><br><span class="line">func CreateNewBlock(lastBlock *Block, data string) Block&#123;</span><br><span class="line"></span><br><span class="line">	var newBlock Block</span><br><span class="line">	newBlock.Index = lastBlock.Index + 1</span><br><span class="line">	newBlock.Timestamp = time.Now().String()</span><br><span class="line">	newBlock.PreHash = lastBlock.Hash</span><br><span class="line">	newBlock.Data = data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//通过pos计算由那个村民挖矿</span><br><span class="line">	//设置随机种子</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	//[0,15)产生0-15的随机值</span><br><span class="line">	var rd =rand.Intn(15)</span><br><span class="line"></span><br><span class="line">	//选出挖矿的旷工</span><br><span class="line">	node := addr[rd]</span><br><span class="line">	//设置当前区块挖矿地址为旷工</span><br><span class="line">	newBlock.Validator = node</span><br><span class="line">	//简单模拟 挖矿所得奖励</span><br><span class="line">	node.Tokens += 1</span><br><span class="line">	newBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock))</span><br><span class="line">	return newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	InitNodes()</span><br><span class="line"></span><br><span class="line">	//创建创世区块</span><br><span class="line">	var genesisBlock = genesisBlock()</span><br><span class="line"></span><br><span class="line">	//创建新区快</span><br><span class="line">	var newBlock = CreateNewBlock(&amp;genesisBlock, &quot;new block&quot;)</span><br><span class="line"></span><br><span class="line">	//打印新区快信息</span><br><span class="line">	fmt.Println(newBlock)</span><br><span class="line">	fmt.Println(newBlock.Validator.Address)</span><br><span class="line">	fmt.Println(newBlock.Validator.Tokens)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0&#125;</span><br><span class="line">0x12341</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POS简介&quot;&gt;&lt;a href=&quot;#POS简介&quot; class=&quot;headerlink&quot; title=&quot;POS简介&quot;&gt;&lt;/a&gt;POS简介&lt;/h2&gt;&lt;p&gt;POS：Proof of Stake，股权证明&lt;br&gt;类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。&lt;br&gt;简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。&lt;/p&gt;
&lt;h2 id=&quot;算法具体实现原理&quot;&gt;&lt;a href=&quot;#算法具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;算法具体实现原理&quot;&gt;&lt;/a&gt;算法具体实现原理&lt;/h2&gt;&lt;p&gt;每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="共识算法" scheme="http://gcblog/github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="POS" scheme="http://gcblog/github.io/tags/POS/"/>
    
  </entry>
  
  <entry>
    <title>共识算法POW原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/29/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95POW%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/29/共识算法POW原理及实现/</id>
    <published>2018-06-29T11:31:22.000Z</published>
    <updated>2018-06-29T11:33:06.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POW简介"><a href="#POW简介" class="headerlink" title="POW简介"></a>POW简介</h2><p>Proof of Work，工作证明。<br>POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法</p>
<h2 id="算法具体实现原理"><a href="#算法具体实现原理" class="headerlink" title="算法具体实现原理"></a>算法具体实现原理</h2><p>这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。<br>这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。</p>
<a id="more"></a>
<h2 id="代码简单实现其原理"><a href="#代码简单实现其原理" class="headerlink" title="代码简单实现其原理"></a>代码简单实现其原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;crypto/sha256&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">	&quot;encoding/hex&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//pow 挖矿算法</span><br><span class="line"></span><br><span class="line">//定义难度系数</span><br><span class="line">const difiiculty = 4</span><br><span class="line"></span><br><span class="line">type Block struct &#123;</span><br><span class="line">	Index      int // 区块高度</span><br><span class="line">	TimeStamp  int64</span><br><span class="line">	Data       string //交易记录</span><br><span class="line">	Hash       string</span><br><span class="line">	Prehash    string</span><br><span class="line">	Nonce      int</span><br><span class="line">	Difficulty int //难度系数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建区块链</span><br><span class="line">var BlockChain []Block</span><br><span class="line"></span><br><span class="line">//创世区块</span><br><span class="line">func GenesisBlock() *Block &#123;</span><br><span class="line"></span><br><span class="line">	var geneBlock = Block&#123;0, time.Now().Unix(), &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, difiiculty&#125;</span><br><span class="line">	geneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock))</span><br><span class="line"></span><br><span class="line">	return &amp;geneBlock</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func BlockHash(block Block) []byte &#123;</span><br><span class="line">	re := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash +</span><br><span class="line">		strconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty)</span><br><span class="line"></span><br><span class="line">	h := sha256.New()</span><br><span class="line">	h.Write([]byte(re))</span><br><span class="line">	hashed := h.Sum(nil)</span><br><span class="line"></span><br><span class="line">	return hashed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isBlockValid(block Block) bool  &#123;</span><br><span class="line">	prefix := strings.Repeat(&quot;0&quot;, block.Difficulty)</span><br><span class="line">	return strings.HasPrefix(block.Hash, prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建新区块 pow挖矿</span><br><span class="line">func CreateNewBlock(lastBlock *Block, data string) *Block &#123;</span><br><span class="line">	var newBlock Block</span><br><span class="line">	newBlock.Index = lastBlock.Index + 1</span><br><span class="line">	newBlock.TimeStamp = time.Now().Unix()</span><br><span class="line">	newBlock.Data = data</span><br><span class="line">	newBlock.Prehash = lastBlock.Hash</span><br><span class="line">	newBlock.Difficulty = difiiculty</span><br><span class="line">	newBlock.Nonce = 0</span><br><span class="line">	//开挖-当前区块的hash值的前面的0的个数与难度系数值相同</span><br><span class="line">	for &#123;</span><br><span class="line">		//计算hash</span><br><span class="line">		cuhash := hex.EncodeToString(BlockHash(newBlock))</span><br><span class="line">		fmt.Println(&quot;挖矿中&quot;,cuhash)</span><br><span class="line">		newBlock.Hash = cuhash</span><br><span class="line">		if isBlockValid(newBlock) &#123;</span><br><span class="line"></span><br><span class="line">			//校验区块</span><br><span class="line">			if VerflyBlock(newBlock, *lastBlock) &#123;</span><br><span class="line">				fmt.Println(&quot;挖矿成功&quot;)</span><br><span class="line">				return  &amp;newBlock</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		newBlock.Nonce ++</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//校验新的区块是否合法</span><br><span class="line">func VerflyBlock(newblock Block, lastBlock Block) bool  &#123;</span><br><span class="line">	if lastBlock.Index +1 !=newblock.Index &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	if newblock.Prehash !=lastBlock.Hash &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	var genBlock = GenesisBlock()</span><br><span class="line">	</span><br><span class="line">	newBlock := CreateNewBlock(genBlock,&quot;新区块&quot;)</span><br><span class="line">	fmt.Println(newBlock)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489</span><br><span class="line">挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae</span><br><span class="line">挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171</span><br><span class="line">挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811</span><br><span class="line">挖矿成功</span><br><span class="line">&amp;&#123;1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POW简介&quot;&gt;&lt;a href=&quot;#POW简介&quot; class=&quot;headerlink&quot; title=&quot;POW简介&quot;&gt;&lt;/a&gt;POW简介&lt;/h2&gt;&lt;p&gt;Proof of Work，工作证明。&lt;br&gt;POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法&lt;/p&gt;
&lt;h2 id=&quot;算法具体实现原理&quot;&gt;&lt;a href=&quot;#算法具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;算法具体实现原理&quot;&gt;&lt;/a&gt;算法具体实现原理&lt;/h2&gt;&lt;p&gt;这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。&lt;br&gt;这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。&lt;/p&gt;
    
    </summary>
    
      <category term="共识算法" scheme="http://gcblog/github.io/categories/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="共识算法" scheme="http://gcblog/github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="POW" scheme="http://gcblog/github.io/tags/POW/"/>
    
  </entry>
  
  <entry>
    <title>DSA和ECC签名验签</title>
    <link href="http://gcblog/github.io/2018/06/28/DSA%E5%92%8CECC%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE/"/>
    <id>http://gcblog/github.io/2018/06/28/DSA和ECC签名验签/</id>
    <published>2018-06-28T10:52:24.000Z</published>
    <updated>2018-08-16T01:07:26.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h2><p>DSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。<br>在安全性上，DSA和RSA差不多，但是速度比RSA快很多。</p>
<a id="more"></a>
<h3 id="DSA签名和验签"><a href="#DSA签名和验签" class="headerlink" title="DSA签名和验签"></a>DSA签名和验签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	//设置私钥使用的参数</span><br><span class="line">	var param dsa.Parameters</span><br><span class="line">	dsa.GenerateParameters(&amp;param, rand.Reader, dsa.L1024N160)</span><br><span class="line"></span><br><span class="line">	//创建私钥</span><br><span class="line">	var pri dsa.PrivateKey</span><br><span class="line">	pri.Parameters = param</span><br><span class="line">	dsa.GenerateKey(&amp;pri, rand.Reader)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//生成公钥</span><br><span class="line">	pub := pri.PublicKey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//签名</span><br><span class="line">	message := []byte(&quot;hello&quot;)</span><br><span class="line">	r,s,_ := dsa.Sign(rand.Reader, &amp;pri, message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//验证</span><br><span class="line">	if dsa.Verify(&amp;pub, message, r, s)&#123;</span><br><span class="line">		fmt.Println(&quot;验签成功&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h2><p>椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。</p>
<p>椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。<br>比特币就是用ECC来做签名和验签。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</li>
<li>计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多</li>
<li>存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多</li>
<li>带宽要求低使得ECC具有广泛得应用前景</li>
</ul>
<h3 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h3><p>一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。</p>
<blockquote>
<p>E:y<sup>2</sup>=ax<sup>3</sup>+ bx<sup>2</sup>+cx+d</p>
</blockquote>
<p>例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为:</p>
<blockquote>
<p>E:y<sup>2</sup>=x<sup>3</sup>-2x+4</p>
</blockquote>
<p>该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。　　</p>
<p><img src="http://olgjbx93m.bkt.clouddn.com/20180117-211235.png" alt=""></p>
<h3 id="ECC签名和验签"><a href="#ECC签名和验签" class="headerlink" title="ECC签名和验签"></a>ECC签名和验签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	message := []byte(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">	//设置生成的私钥为256位</span><br><span class="line">	privatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span><br><span class="line"></span><br><span class="line">	//创建公钥</span><br><span class="line">	publicKey := privatekey.PublicKey</span><br><span class="line"></span><br><span class="line">	//hash散列明文</span><br><span class="line">	digest := sha256.Sum256(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//用私钥签名</span><br><span class="line">	r,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:])</span><br><span class="line"></span><br><span class="line">	//设置私钥的参数类型</span><br><span class="line">	param := privatekey.Curve.Params()</span><br><span class="line"></span><br><span class="line">	//获取私钥的长度（字节）</span><br><span class="line">	curveOrderBytes:=param.P.BitLen()/8</span><br><span class="line"></span><br><span class="line">	//获得签名返回的字节</span><br><span class="line">	rByte,sByte := r.Bytes(), s.Bytes()</span><br><span class="line"></span><br><span class="line">	//创建数组合并字节</span><br><span class="line">	signature := make([]byte,curveOrderBytes*2)</span><br><span class="line">	copy(signature[:len(rByte)], rByte)</span><br><span class="line">	copy(signature[len(sByte):], sByte)</span><br><span class="line"></span><br><span class="line">	//现在signature中就存放了完整的签名的结果</span><br><span class="line"></span><br><span class="line">	//验签</span><br><span class="line">	digest = sha256.Sum256(message)</span><br><span class="line">	//获得公钥的字节长度</span><br><span class="line">	curveOrderBytes= publicKey.Curve.Params().P.BitLen()/8</span><br><span class="line"></span><br><span class="line">	//创建大整数类型保存rbyte,sbyte</span><br><span class="line">	r,s = new(big.Int),new(big.Int)</span><br><span class="line"></span><br><span class="line">	r.SetBytes(signature[:curveOrderBytes])</span><br><span class="line">	s.SetBytes(signature[curveOrderBytes:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//开始认证</span><br><span class="line">	e:=ecdsa.Verify(&amp;publicKey,digest[:],r,s)</span><br><span class="line">	if e== true &#123;</span><br><span class="line">		fmt.Println(&quot;验签成功&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DSA&quot;&gt;&lt;a href=&quot;#DSA&quot; class=&quot;headerlink&quot; title=&quot;DSA&quot;&gt;&lt;/a&gt;DSA&lt;/h2&gt;&lt;p&gt;DSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。&lt;br&gt;在安全性上，DSA和RSA差不多，但是速度比RSA快很多。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DSA" scheme="http://gcblog/github.io/tags/DSA/"/>
    
      <category term="ECC" scheme="http://gcblog/github.io/tags/ECC/"/>
    
      <category term="签名" scheme="http://gcblog/github.io/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="验签" scheme="http://gcblog/github.io/tags/%E9%AA%8C%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>RSA签名验签</title>
    <link href="http://gcblog/github.io/2018/06/28/RSA%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE/"/>
    <id>http://gcblog/github.io/2018/06/28/RSA签名验签/</id>
    <published>2018-06-28T10:51:55.000Z</published>
    <updated>2018-06-28T10:54:08.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是数字签名"><a href="#什么是数字签名" class="headerlink" title="什么是数字签名"></a>什么是数字签名</h2><p>数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p>
<h2 id="签名的生成和验证"><a href="#签名的生成和验证" class="headerlink" title="签名的生成和验证"></a>签名的生成和验证</h2><h3 id="生成消息签名的行为"><a href="#生成消息签名的行为" class="headerlink" title="生成消息签名的行为"></a>生成消息签名的行为</h3><p>生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。</p>
<a id="more"></a>
<h3 id="验证消息签名的行为"><a href="#验证消息签名的行为" class="headerlink" title="验证消息签名的行为"></a>验证消息签名的行为</h3><p>验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。</p>
<h2 id="公钥密码与数字签名"><a href="#公钥密码与数字签名" class="headerlink" title="公钥密码与数字签名"></a>公钥密码与数字签名</h2><p>在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。</p>
<h3 id="公钥密码机制"><a href="#公钥密码机制" class="headerlink" title="公钥密码机制"></a>公钥密码机制</h3><p>公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有<br>用与之对应的私钥才能正确解密。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 <strong>私钥加密</strong> 相当于 <strong>生成签名</strong>，而用 <strong>公钥解密</strong> 则相当于<strong>验证签名</strong>。</p>
<h2 id="数字签名算法"><a href="#数字签名算法" class="headerlink" title="数字签名算法"></a>数字签名算法</h2><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。</p>
<h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><p>DSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。</p>
<h3 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h3><p>ECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字<br>签名算法( NIST FIPS 186-3 )。</p>
<h2 id="RSA算法实现签名和验签"><a href="#RSA算法实现签名和验签" class="headerlink" title="RSA算法实现签名和验签"></a>RSA算法实现签名和验签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	//生成私钥</span><br><span class="line">	pri,_ := rsa.GenerateKey(rand.Reader, 1024)</span><br><span class="line"></span><br><span class="line">	//生成公钥</span><br><span class="line">	pub := &amp;pri.PublicKey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	plainTxt := []byte(&quot;hello world，你好&quot;)</span><br><span class="line"></span><br><span class="line">	//对原文进行hash散列</span><br><span class="line">	h := md5.New()</span><br><span class="line">	h.Write(plainTxt)</span><br><span class="line">	hashed := h.Sum(nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	opts := rsa.PSSOptions&#123;rsa.PSSSaltLengthAuto, crypto.MD5&#125;</span><br><span class="line"></span><br><span class="line">	//实现签名</span><br><span class="line"></span><br><span class="line">	sign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&amp;opts)</span><br><span class="line"></span><br><span class="line">	fmt.Println(hex.EncodeToString(sign))</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	//通过公钥实现验签</span><br><span class="line">	err:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &amp;opts)</span><br><span class="line"></span><br><span class="line">	//err 为空 及验签成功</span><br><span class="line">	fmt.Println(&quot;err:&quot;, err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是数字签名&quot;&gt;&lt;a href=&quot;#什么是数字签名&quot; class=&quot;headerlink&quot; title=&quot;什么是数字签名&quot;&gt;&lt;/a&gt;什么是数字签名&lt;/h2&gt;&lt;p&gt;数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。&lt;/p&gt;
&lt;h2 id=&quot;签名的生成和验证&quot;&gt;&lt;a href=&quot;#签名的生成和验证&quot; class=&quot;headerlink&quot; title=&quot;签名的生成和验证&quot;&gt;&lt;/a&gt;签名的生成和验证&lt;/h2&gt;&lt;h3 id=&quot;生成消息签名的行为&quot;&gt;&lt;a href=&quot;#生成消息签名的行为&quot; class=&quot;headerlink&quot; title=&quot;生成消息签名的行为&quot;&gt;&lt;/a&gt;生成消息签名的行为&lt;/h3&gt;&lt;p&gt;生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="签名" scheme="http://gcblog/github.io/tags/%E7%AD%BE%E5%90%8D/"/>
    
      <category term="验签" scheme="http://gcblog/github.io/tags/%E9%AA%8C%E7%AD%BE/"/>
    
      <category term="RSA" scheme="http://gcblog/github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密RSA原理简介及使用</title>
    <link href="http://gcblog/github.io/2018/06/27/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86RSA%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://gcblog/github.io/2018/06/27/非对称加密RSA原理简介及使用/</id>
    <published>2018-06-27T10:54:38.000Z</published>
    <updated>2018-06-28T10:36:59.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RSA"><a href="#什么是RSA" class="headerlink" title="什么是RSA"></a>什么是RSA</h2><p>RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。</p>
<p>RSA可以被用于公钥密码和数字签名。</p>
<h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><p>在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：</p>
<p><strong>密文=明文<sup>E</sup> mod N</strong> (RSA加密)</p>
<p>RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将<br>明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。</p>
<p>加密公式中出现的两个数<code>E</code>和 <code>N</code>，到底都是什么数呢? RSA的加密是求明文的<br><code>E</code>次方mod <code>N</code>，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，<code>E</code> 和 <code>N</code>是RSA加密的密钥，也就是说，<code>E</code> 和 <code>N</code>的组合就是公钥。</p>
<a id="more"></a>
<h2 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h2><p>RSA的解密和加密一样简单，可以用下面的公式来表达:</p>
<p><strong>明文=密文 <sup>D</sup> mod N</strong> ( RSA解密)</p>
<p>表示密文的数字的D次方求 mod N就可以得到明文。</p>
<p>这里所使用的数字N和加密时使用的数字N是相同的。数 <code>D</code> 和数 <code>N</code> 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。</p>
<p>在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>
<h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>在RSA中，加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>
<p>由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。</p>
<h2 id="生成私钥公钥步骤"><a href="#生成私钥公钥步骤" class="headerlink" title="生成私钥公钥步骤"></a>生成私钥公钥步骤</h2><p>用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥）</p>
<p>1.生成 RSA 私钥（传统格式的）</p>
<p><code>openssl genrsa -out rsa_private_key.pem 1024</code></p>
<p>2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车</p>
<p><code>openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM</code></p>
<p>3.生成 RSA 公钥</p>
<p><code>openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</code></p>
<p>此时在系统根目录已经生成了两个文件。可以直接使用<code>cat</code>命令查看文件中的内容</p>
<h2 id="代码实现加密以及解密过程"><a href="#代码实现加密以及解密过程" class="headerlink" title="代码实现加密以及解密过程"></a>代码实现加密以及解密过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNL</span><br><span class="line">d7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0</span><br><span class="line">TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB</span><br><span class="line">AoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPew</span><br><span class="line">MtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaem</span><br><span class="line">UOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1</span><br><span class="line">ybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNA</span><br><span class="line">Jh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhw</span><br><span class="line">nfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrr</span><br><span class="line">t4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9</span><br><span class="line">T+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi</span><br><span class="line">57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtF</span><br><span class="line">IXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi</span><br><span class="line">-----END RSA PRIVATE KEY-----`)</span><br><span class="line"></span><br><span class="line">var publicKey = []byte(`-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0</span><br><span class="line">nBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWO</span><br><span class="line">jmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxx</span><br><span class="line">LjPiWq1HQhmywNv3BQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----`)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	data := []byte(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line">	cry := RSAEncrypt(data)</span><br><span class="line"></span><br><span class="line">	fmt.Println(hex.EncodeToString(cry))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ori := RSADecrypt(cry)</span><br><span class="line">	fmt.Println(string(ori))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RSAEncrypt(plaintxt []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	//公钥加密</span><br><span class="line">	block, _:= pem.Decode(publicKey)</span><br><span class="line"></span><br><span class="line">	//解析公钥</span><br><span class="line">	pubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line"></span><br><span class="line">	//加载公钥</span><br><span class="line">	pub := pubInterface.(*rsa.PublicKey)</span><br><span class="line"></span><br><span class="line">	//加密明文</span><br><span class="line">	bits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt)</span><br><span class="line"></span><br><span class="line">	//bits为最终的密文</span><br><span class="line">	return bits</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RSADecrypt(cryptTxt []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	block,_:= pem.Decode(privateKey)</span><br><span class="line"></span><br><span class="line">	priv,_:= x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line"></span><br><span class="line">	bits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt)</span><br><span class="line"></span><br><span class="line">	return bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8a</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<h2 id="代码实现生成公钥私钥来加密和解密"><a href="#代码实现生成公钥私钥来加密和解密" class="headerlink" title="代码实现生成公钥私钥来加密和解密"></a>代码实现生成公钥私钥来加密和解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	prikey := CreatePrivateKey()</span><br><span class="line">	pubKey := CreatePublic(prikey)</span><br><span class="line">	</span><br><span class="line">	// 加密和解密</span><br><span class="line">	ori:=[]byte(&quot;hello world!!!&quot;)</span><br><span class="line">	//通过oaep函数实现公钥加密</span><br><span class="line">	//第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要</span><br><span class="line">	cipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &amp;pubKey, ori, nil)</span><br><span class="line"></span><br><span class="line">	fmt.Println(cipherTxt)</span><br><span class="line"></span><br><span class="line">	//解密</span><br><span class="line">	plainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil)</span><br><span class="line">	fmt.Println(string(plainTxt))</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建私钥</span><br><span class="line">func CreatePrivateKey() *rsa.PrivateKey  &#123;</span><br><span class="line"></span><br><span class="line">	// 长度为1024 位 的私钥</span><br><span class="line">	pri,_:= rsa.GenerateKey(rand.Reader, 1024)</span><br><span class="line">	return pri</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 生成公钥</span><br><span class="line">func CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey  &#123;</span><br><span class="line">	return prikey.PublicKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是RSA&quot;&gt;&lt;a href=&quot;#什么是RSA&quot; class=&quot;headerlink&quot; title=&quot;什么是RSA&quot;&gt;&lt;/a&gt;什么是RSA&lt;/h2&gt;&lt;p&gt;RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。&lt;/p&gt;
&lt;p&gt;RSA可以被用于公钥密码和数字签名。&lt;/p&gt;
&lt;h2 id=&quot;RSA加密&quot;&gt;&lt;a href=&quot;#RSA加密&quot; class=&quot;headerlink&quot; title=&quot;RSA加密&quot;&gt;&lt;/a&gt;RSA加密&lt;/h2&gt;&lt;p&gt;在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;密文=明文&lt;sup&gt;E&lt;/sup&gt; mod N&lt;/strong&gt; (RSA加密)&lt;/p&gt;
&lt;p&gt;RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将&lt;br&gt;明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。&lt;/p&gt;
&lt;p&gt;加密公式中出现的两个数&lt;code&gt;E&lt;/code&gt;和 &lt;code&gt;N&lt;/code&gt;，到底都是什么数呢? RSA的加密是求明文的&lt;br&gt;&lt;code&gt;E&lt;/code&gt;次方mod &lt;code&gt;N&lt;/code&gt;，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，&lt;code&gt;E&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt;是RSA加密的密钥，也就是说，&lt;code&gt;E&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt;的组合就是公钥。&lt;/p&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="RSA" scheme="http://gcblog/github.io/tags/RSA/"/>
    
      <category term="非对称加密" scheme="http://gcblog/github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>对称加密算法AES原理及实现</title>
    <link href="http://gcblog/github.io/2018/06/27/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95AES%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://gcblog/github.io/2018/06/27/对称加密算法AES原理及实现/</id>
    <published>2018-06-27T10:52:14.000Z</published>
    <updated>2018-06-27T10:53:55.826Z</updated>
    
    <content type="html"><![CDATA[<p>AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。<br>　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。<br>　　<br><a id="more"></a>
　　</p>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>AES中没有使用Feistel网络，其结构称为SPN结构。<br>　　<br>和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。<br>　　<br>AES总体结构示意图：<br>　　<br><img src="http://olgjbx93m.bkt.clouddn.com/201801010001.png" alt="结构示意图"></p>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>密码算法可以分为分组密码和流密码两种</p>
<ul>
<li><p><strong>分组密码（block cipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。</p>
<p>  例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。</p>
</li>
<li><p><strong>流密码（stream cipher）</strong>是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。</p>
</li>
</ul>
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。</p>
<ul>
<li>ECB模式：Electronic CodeBook mode（电子密码模式）</li>
<li>CBC模式：Cipher Block Chaining mode（密码分组链接模式）</li>
<li>CFB模式：Cipher FeedBack mode（密文反馈模式）</li>
<li>OFB模式：Output FeedBack mode（输出反馈模式）</li>
<li>CTR模式：CounTeR mode（计数器模式）</li>
</ul>
<p>ECB模式存在很高的风险，下面举例后面4中模式的使用.<br>加密的过程中使用了随机流，所以每次加密的密文都不一样</p>
<h3 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	key := &quot;1234567890asdfgh&quot;</span><br><span class="line">	data := &quot;hollo, world!&quot;</span><br><span class="line"></span><br><span class="line">	cry := AesCBCEncrypt([]byte(data), []byte(key))</span><br><span class="line">	fmt.Println(hex.EncodeToString(cry))</span><br><span class="line"></span><br><span class="line">	oriData := AESCBCDECriypt(cry, []byte(key))</span><br><span class="line">	fmt.Println(string(oriData))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// AES也是对称加密 AES 是 DES 的替代品</span><br><span class="line">// AES 密钥长度 只能是 16、24、32 字节</span><br><span class="line">//加密</span><br><span class="line">func AesCBCEncrypt(org []byte, key []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	//按照公钥长度 进行分组补码</span><br><span class="line">	org = PKCS7Padding(org, block.BlockSize())</span><br><span class="line"></span><br><span class="line">	//设置CBC的加密模式</span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key)</span><br><span class="line"></span><br><span class="line">	//加密处理</span><br><span class="line">	crypted := make([]byte, len(org))</span><br><span class="line">	blockMode.CryptBlocks(crypted, org)</span><br><span class="line"></span><br><span class="line">	return crypted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解密</span><br><span class="line">func AESCBCDECriypt(criptText []byte, key []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	//校验key的有效性</span><br><span class="line">	block,_:=aes.NewCipher(key)</span><br><span class="line">	//通过CBC模式解密</span><br><span class="line">	blockMode:=cipher.NewCBCDecrypter(block,key)</span><br><span class="line"></span><br><span class="line">	//实现解密</span><br><span class="line">	origData:=make([]byte,len(criptText))</span><br><span class="line">	blockMode.CryptBlocks(origData,criptText)</span><br><span class="line"></span><br><span class="line">	//去码</span><br><span class="line">	origData = PKCS7UnPadding(origData)</span><br><span class="line">	return origData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//PKCS5 分组长度只能为8</span><br><span class="line">//PKCs7 分组长度 1- 255</span><br><span class="line"></span><br><span class="line">func PKCS7Padding(org []byte, blockSize int) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	pad := blockSize-len(org)%blockSize</span><br><span class="line">	padArr := bytes.Repeat([]byte&#123;byte(pad)&#125;, pad)</span><br><span class="line">	return  append(org, padArr...)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PKCS7UnPadding(cryptText []byte) []byte  &#123;</span><br><span class="line">	</span><br><span class="line">	length := len(cryptText)</span><br><span class="line">	lastByte := cryptText[length - 1]</span><br><span class="line">	return cryptText[:length-int(lastByte)]</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffa22c136fd3e944255d43e255c98ecc</span><br><span class="line">hollo, world!</span><br></pre></td></tr></table></figure></p>
<h3 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	key := []byte(&quot;1234567890asdfgh&quot;)</span><br><span class="line">	data := []byte(&quot;abc hello world!&quot;)</span><br><span class="line">	cry := AESCFBEncrypt(data, key)</span><br><span class="line"></span><br><span class="line">	fmt.Println(hex.EncodeToString(cry))</span><br><span class="line">	//fmt.Println(base64.StdEncoding.EncodeToString(cry))</span><br><span class="line"></span><br><span class="line">	ori := AESCFBDecrypt(cry, key)</span><br><span class="line">	fmt.Println(string(ori))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CFB分组模式加密</span><br><span class="line">func AESCFBEncrypt(oriData []byte, key []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	//拆分iv和密文</span><br><span class="line">	cipherText := make([]byte, aes.BlockSize + len(oriData))</span><br><span class="line"></span><br><span class="line">	iv := cipherText[:aes.BlockSize]</span><br><span class="line"></span><br><span class="line">	//向iv切片数组初始化 reader（随机内存流）</span><br><span class="line">	io.ReadFull(rand.Reader, iv)</span><br><span class="line"></span><br><span class="line">	//设置加密模式CFB</span><br><span class="line">	stream := cipher.NewCFBEncrypter(block,iv)</span><br><span class="line"></span><br><span class="line">	//加密</span><br><span class="line">	stream.XORKeyStream(cipherText[aes.BlockSize:], oriData)</span><br><span class="line"></span><br><span class="line">	return  cipherText</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解密</span><br><span class="line">func AESCFBDecrypt(cryptText []byte, key []byte) []byte &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	//拆分iv 和密文</span><br><span class="line">	iv := cryptText[:aes.BlockSize]</span><br><span class="line">	cipherText := cryptText[aes.BlockSize:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//设置解密模式</span><br><span class="line">	stream := cipher.NewCFBDecrypter(block, iv)</span><br><span class="line"></span><br><span class="line">	var des = make([]byte, len(cipherText))</span><br><span class="line"></span><br><span class="line">	//解密</span><br><span class="line">	stream.XORKeyStream(des, cipherText)</span><br><span class="line"></span><br><span class="line">	return des</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">92e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513</span><br><span class="line">abc hello world!</span><br></pre></td></tr></table></figure></p>
<h3 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	key := []byte(&quot;1234567890asdfgh&quot;)</span><br><span class="line">	data := []byte(&quot;abcd hello world!&quot;)</span><br><span class="line">	cry := AESOFBEncrypt(data, key)</span><br><span class="line"></span><br><span class="line">	fmt.Println(hex.EncodeToString(cry))</span><br><span class="line"></span><br><span class="line">	ori := AESOFBDecrypt(cry, key)</span><br><span class="line">	fmt.Println(string(ori))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AES OFB分组加密模式  CTR也是一样</span><br><span class="line">func AESOFBEncrypt(plaintxt []byte, key []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	cipherText := make([]byte, aes.BlockSize + len(plaintxt))</span><br><span class="line"></span><br><span class="line">	iv := cipherText[:aes.BlockSize]</span><br><span class="line"></span><br><span class="line">	//向iv切片数组初始化 reader（随机内存流）</span><br><span class="line">	io.ReadFull(rand.Reader, iv)</span><br><span class="line"></span><br><span class="line">	//设置加密模式CFB</span><br><span class="line">	stream := cipher.NewOFB(block,iv)</span><br><span class="line"></span><br><span class="line">	//加密</span><br><span class="line">	stream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</span><br><span class="line"></span><br><span class="line">	return  cipherText</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//解密</span><br><span class="line">func AESOFBDecrypt(cryptText []byte, key []byte) []byte &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	//拆分iv 和 密文</span><br><span class="line">	iv := cryptText[:aes.BlockSize]</span><br><span class="line">	plaintxt := make([]byte, len(cryptText)-aes.BlockSize)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//设置解密模式</span><br><span class="line">	stream := cipher.NewOFB(block, iv)</span><br><span class="line"></span><br><span class="line">	//解密</span><br><span class="line">	stream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</span><br><span class="line"></span><br><span class="line">	return plaintxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4</span><br><span class="line">abcd hello world!</span><br></pre></td></tr></table></figure></p>
<h3 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	key := []byte(&quot;1234567890asdfgh&quot;)</span><br><span class="line">	data := []byte(&quot;abcd hello world!&quot;)</span><br><span class="line">	cry := AESCTREncrypt(data, key)</span><br><span class="line"></span><br><span class="line">	fmt.Println(hex.EncodeToString(cry))</span><br><span class="line"></span><br><span class="line">	ori := AESCTRDecrypt(cry, key)</span><br><span class="line">	fmt.Println(string(ori))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AES CTR分组加密模式</span><br><span class="line">func AESCTREncrypt(plaintxt []byte, key []byte) []byte  &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	cipherText := make([]byte, aes.BlockSize + len(plaintxt))</span><br><span class="line"></span><br><span class="line">	iv := cipherText[:aes.BlockSize]</span><br><span class="line"></span><br><span class="line">	//向iv切片数组初始化 reader（随机内存流）</span><br><span class="line">	io.ReadFull(rand.Reader, iv)</span><br><span class="line"></span><br><span class="line">	//设置加密模式CTR</span><br><span class="line">	stream := cipher.NewCTR(block,iv)</span><br><span class="line"></span><br><span class="line">	//加密</span><br><span class="line">	stream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</span><br><span class="line"></span><br><span class="line">	return  cipherText</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//解密</span><br><span class="line">func AESCTRDecrypt(cryptText []byte, key []byte) []byte &#123;</span><br><span class="line"></span><br><span class="line">	//校验密钥</span><br><span class="line">	block,_ := aes.NewCipher(key)</span><br><span class="line"></span><br><span class="line">	//拆分iv 和 密文</span><br><span class="line">	iv := cryptText[:aes.BlockSize]</span><br><span class="line">	plaintxt := make([]byte, len(cryptText)-aes.BlockSize)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//设置解密模式</span><br><span class="line">	stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">	//解密</span><br><span class="line">	stream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</span><br><span class="line"></span><br><span class="line">	return plaintxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534</span><br><span class="line">abcd hello world!</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。&lt;br&gt;　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。&lt;br&gt;　　&lt;br&gt;
    
    </summary>
    
      <category term="加密算法" scheme="http://gcblog/github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="AES" scheme="http://gcblog/github.io/tags/AES/"/>
    
      <category term="对称加密" scheme="http://gcblog/github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
