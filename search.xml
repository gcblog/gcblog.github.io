<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[temdermint初识]]></title>
      <url>%2F2018%2F12%2F16%2Ftemdermint%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[2.1 概述tendermint虽然定位于引擎，但它其实是一个完整的区块链实现。在这一部分 的课程中，我们将使用一个最小化的ABCI应用，来熟悉tendermint的主要组成 部分，以及使用tendermint进行去中心化应用开发的主要流程和工具。 下图列出了tendermint应用的主要构成部分： tendermint提供了一个预构建的同名可执行程序，我们将学习如何使用这个程序 来初始化节点配置文件并启动节点。这个程序是完整的节点实现，除了通过P2P协议 与其他节点交换共识，同时还提供了RPC接口供客户端提交交易或者查询应用状态。 我们将创建一个最小化的ABCI应用，tendermint可执行程序通过ABCI接口与 应用程序交互，例如要求应用执行交易、或者转发来自RPC接口的状态查询请求。 2.2 节点初始化tendermint节点程序的行为非常依赖于配置文件，使用其init子命令 可以获得一组默认的初始化文件。 例如，在1#终端输入如下命令创建初始化文件： ~$ tendermint initinit子命令将在~/.tendermint目录下创建两个子目录data和config，分别用于 保存区块链数据和配置文件。 在data目录下将包含如下的数据文件，均为leveldb格式： blockstore.db：区块链数据库evidence.db：节点行为数据state.db：区块链状态数据tx_index.db：交易索引数据，在config子目录下将包含如下的配置文件： config.toml：节点软件配置文件node_key.json：节点密钥文件，用于p2p通信加密priv_validator.json：验证节点密钥文件，用于共识签名genesis.json：创世文件节点配置文件config.toml用来设置节点软件的运行参数，例如RPC监听端口等。 我们修改consensus.create_empty_blocks为false，即不出无交易的空块： [consensus]create_empty_blocks = false重新初始化 在我们开发ABCI应用的过程中，往往需要对应用中的状态结构等信息进行调整，再次重新启动 后就可能导致原有的链数据和新的状态结构不兼容，因此需要时不时地重新初始化区块链数据。 当然你可以完全删除~/.tendermint目录，然后重新执行tendermint init命令。不过官方 的建议是使用unsafe_reset_all子命令来做这个事情，这个命令可以保留现有的配置而仅删除 数据文件。例如： ~$ tendermint unsafe_reset_all 2.3 节点启动与停止初始化之后，我们就可以启动节点了。在1#终端执行node子命令启动tendermint节点： ~$ tendermint node可以看到tendermint在反复尝试abci应用的默认监听地址tcp://127.0.0.1:26658： 显然，tendermint要求一个配套的abci应用才能正常工作，我们将在下一节解决这个 问题。 在目前这种状态下，如果需要退出tendermint的执行，可以切换到2#终端，使用pkill 命令终止其运行： ~$ pkill -9 tendermint 2.4 编写最小化应用tendermint开发包中已经包含了一个基本的ABCI应用实现类BaseApplication， 可以完成与tendermint节点旳基本交互： tendermint节点程序可以通过socket通信访问ABCI应用，因此我们使用abci/server 包的NewServer()函数创建一个SocketServer实例来启动这个应用。 例如，下面的代码在tendermint尝试连接的默认端口26658启动abci应用：1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;github.com/tendermint/tendermint/abci/types&quot; &quot;github.com/tendermint/tendermint/abci/server&quot;)func main()&#123; app := types.NewBaseApplication() svr,err := server.NewServer(&quot;:26658&quot;,&quot;socket&quot;,app) if err != nil &#123; panic(err) &#125; svr.Start() defer svr.Stop() fmt.Println(&quot;abci server started&quot;) select &#123;&#125;&#125; 将上述代码保存为~/repo/go/src/diy/c2/mini-app.go，然后在2#终端 进入c2目录并启动该应用：12~$ cd ~/repo/go/src/diy/c2~/repo/go/src/diy/c2$ go run mini-app.go 现在回到1#终端重新启动tendermint节点： ~$ tendermint node你可以看到这次tendermint节点启动成功了： 由于我们只有一个节点，因此tendermint会抱怨连接不到其他的节点，it‘s ok。 2.5 RPC开发接口在一个典型的（非理想化的）去中心化应用的开发中，除了需要开发链上应用 （例如ABCI应用或者以太坊中的智能合约），往往还需要开发传统的网页应用 /桌面应用/手机应用，以方便那些不可能自己部署节点旳用户： 和以太坊一样，tendermint的节点也提供了RPC接口供这些传统应用代码访问节点功能， 例如提交交易或者查询节点状态，其默认的RPC监听端口是26657。 首先确保1#终端和2#终端分别运行着tendermint和abci应用，然后我们切换到3# 终端，输入如下命令提交交易0x68656c6c6f —— 对应于字符串hello的16进制表示： ~$ curl http://localhost:26657/broadcast_tx_commit?tx=0x68656c6c6f响应结果类似于下图，其中check_tx和deliver_tx来自于abci应用，而交易哈希 和区块高度则由tendermint节点内部处理得出： 事实上，由于BaseApplication对于交易数据没有任何的限制，因此我们可以提交 任意有效的16进制表示，而这些交易都将成功地打包到区块里。 让我们看一下这个区块的内容，在3#终端输入如下命令： ~$ curl http://localhost:26657/block?height=2注意结果中的Txs字段，它包含了该区块中所有交易的base64编码： 我们可以使用命令行工具base64简单地进行验证： ~$ echo aGVsbG8= | based64 -d可以访问这里 查看tendermint区块结构的详细说明。 也可以通过哈希查看交易内容，在3#终端输入如下命令（注意，你的哈希可能与此不同）： ~$ curl http://localhost:26657/tx?hash=0x2CF24DBA5FB0A30E26E83B2AC5B9E29E1B161E5C得到如下的结果： 获得配套代码资料关注微信公众号区块链001, 回复tendermint获得]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tendermint简介]]></title>
      <url>%2F2018%2F12%2F10%2Ftendermint%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[1.1 tendermint简介tendermint是一个开源的完整的区块链实现，可以用于公链或联盟链，其官方定位 是面向开发者的区块链共识引擎： 与其他区块链平台例如以太坊或者EOS相比，tendermint最大的特点是其差异化的定位： 尽管包含了区块链的完整实现，但它却是以SDK的形式将这些核心功能提供出来，供开发者 方便地定制自己的专有区块链： tendermint的SDK中包含了构造一个区块链节点旳绝大部分组件，例如加密算法、共识算法、 区块链存储、RPC接口、P2P通信等等，开发人员只需要根据其应用开发接口 （Application Blockchain Communication Interface）的要求实现自己 的应用即可。 ABCI是开发语言无关的，开发人员可以使用自己喜欢的任何语言来开发基于tendermint的 专用区块链。不过由于tendermint本身是采用go语言开发的，因此用go开发ABCI应用的一个额外好处 就是，你可以把tendermint完整的嵌入自己的应用，干净利落地交付一个单一的可执行文件。 1.2 tendermint的共识算法在技术方面，tendermint引以为傲的是其共识算法 —— 世界上第一个可以应用于公链的拜占庭 容错算法。tendermint曾于2016年国际区块链周获得最具创新奖，并在Hyperledger的雨燕（Burrow） 等诸多产品中被采纳为共识引擎。你可以点击 这里 查看其应用案例。 tendermint采用的共识机制属于一种权益证明（ Proof Of Stake）算法，一组验证人 （Validator）代替了矿工（Miner）的角色，依据抵押的权益比例轮流出块： 由于避免了POW机制，tendermint可以实现很高的交易吞吐量。根据官方的说法，在 合理（理想）的应用数据结构支持下，可以达到42000交易/秒，引文参考 这里。 不过在现实环境中，部署在全球的100个节点进行共识沟通，实际可以达到1000交易/秒。 tendermint同时是拜占庭容错的（Byzantine Fault Tolerance），因此对于3f+1个 验证节点组成的区块链，即使有f个节点出现拜占庭错误，也可以保证全局正确共识的达成。同时 在极端环境下，tendermint在交易安全与停机风险之间选择了安全，因此当超过f个验证节点发生 故障时，系统将停止工作。 什么是拜占庭错误？简单的说就是任何错误：既包括节点宕机、也包括恶意节点的欺骗和攻击。 tendermint共识机制的另一个特点就是其共识的最终确定性：一旦共识达成就是真的达成， 而不是像比特币或以太坊的共识是一种概率性质的确定性，还有可能在将来某个时刻失效。 因此在tendermint中不会出现区块链分叉的情况。 1.3 tendermint vs. 以太坊tendermint的定位决定了在最终交付的节点软件分层中，应用程序占有相当部分的分量。 让我们通过与以太坊的对比来更好地理解这一点： 在上图中，tendermint结构中的abci应用和以太坊结构中的智能合约，都是由用户代码实现的。 显然，ABCI应用大致与EVM+合约的组合相匹配。 在以太坊中，节点是一个整体，开发者提供的智能合约则运行在受限的虚拟机环境中；而在 tendermint中，并不存在虚拟机这一层，应用程序是一个标准的操作系统进程，不受任何 的限制与约束 —— 听起来这很危险，但当你考虑下使用tendermint的目的是构建专有的区块链 时，这种灵活性反而更有优势了。 事实上，tendermint留下的应用层空间如此之大，以至于你完全可以在ABCI应用中实现一个 EVM，然后提供solidity合约开发能力，这就是超级账本的 Burrow 做的事情。 获得配套代码资料关注微信公众号区块链001, 回复tendermint获得]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb+golang+mac]]></title>
      <url>%2F2018%2F07%2F09%2Fmac%E4%B8%8B%E4%BD%BF%E7%94%A8golang%E6%93%8D%E4%BD%9Cmongodb%2F</url>
      <content type="text"><![CDATA[MongoDB简介MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。 NoSql数据库的CAP理论CAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 安装MongoDB用OSX 的 brew 来安装 mongodbbrew install mongodb 或者 sudo brew install mongodb 如果要安装支持 TLS/SSL 命令如下：brew install mongodb --with-openssl 查看是否安装成功mongod -version如果显示版本信息，说明已经安装成功 启动mongomongo默认会在根目录 /data/db 下启动服务，所以需要先创建此路径。sudo mkdir -p /data/db 然后开启服务mongod 或者开启指定路径的服务mongod --dbpath=xxx 新开一个终端，输入命令mongo进入mongo系统 再次输入命令测试show dbs显示如下 1234&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB 即已成功运行 基本命令显示数据库show dbs显示数据表show collections选择或者创建 mydb数据表use mydb 增如果没有 user表 会自动创建db.user.save({&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:2}) 删删除数据表db.user.drop() 删除数据库use mydbdb.dropDatasase() 删除记录db.user.remove({&quot;name&quot;:&quot;zhangsan&quot;}) 查查所有db.user.find()查 age=2db.user.find({&quot;age&quot;:2}) 改只改动某一项值 1db.user.update(&#123;&quot;_id&quot; : ObjectId(&quot;5b41c89323c223baaa7d4ef1&quot;)&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;&#125;) 如果没有set，相当于覆盖这条记录 golang中使用mongo golang demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package mainimport ( &quot;gopkg.in/mgo.v2&quot; &quot;gopkg.in/mgo.v2/bson&quot; &quot;fmt&quot;)type Person struct &#123; ID bson.ObjectId `_id` Name string Age int&#125;const ( dbUrl = &quot;127.0.0.1:27017&quot;)func main()&#123; session,err := mgo.Dial(dbUrl) if err != err &#123; println(err) &#125; defer session.Close() session.SetMode(mgo.Monotonic, true) //设置一致性模式 //选择数据库 db := session.DB(&quot;mydb&quot;) //选择数据表 collection := db.C(&quot;user&quot;) //增 单条插入 p1 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125; p2 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125; err = collection.Insert(&amp;p1, &amp;p2) //批量插入 var arr []interface&#123;&#125; arr = append(arr, p1) arr = append(arr, p2) err = collection.Insert(arr...) if err != err &#123; println(err) &#125; //查第一条 result := Person&#123;&#125; collection.Find(bson.M&#123;&quot;age&quot;:12&#125;).One(&amp;result) fmt.Println(&quot;restlt&quot;,result) //查多条 results := []Person&#123;&#125; collection.Find(bson.M&#123;&quot;age&quot;:12&#125;).All(&amp;results) fmt.Println(&quot;results&quot;,results, len(results)) //查表中数据总数 count, _:= collection.Find(nil).Count() fmt.Println(count) //查所有 arr2 := make([]Person, 0) iterNew := collection.Find(nil).Iter() err = iterNew.All(&amp;arr2) if err != nil &#123; panic(err) &#125; fmt.Println(&quot;arr2&quot;,arr2) //改(不加set就是覆盖) collection.Update(bson.M&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:22&#125;&#125;) collection.Update(bson.M&#123;&quot;age&quot;:22&#125;,bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:23&#125;&#125;) collection.Update(bson.M&#123;&quot;name&quot;:&quot;lisi&quot;&#125;, bson.M&#123;&quot;name&quot;:&quot;lisi2&quot;,&quot;age&quot;:22&#125;) //批量更新 collection.UpdateAll(bson.M&#123;&quot;age&quot;:22&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:44&#125;&#125;) //删 //删除符合条件的第一条 //collection.Remove(bson.M&#123;&quot;name&quot;: &quot;lisi2&quot;&#125;) //删除所有 _, err = collection.RemoveAll(bson.M&#123;&quot;name&quot;: &quot;lisi&quot;&#125;) if err != err &#123; println(err) &#125; //根据ID删除 var wangwu = Person&#123;&#125; collection.Find(bson.M&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;).One(&amp;wangwu) fmt.Println(wangwu, wangwu.ID.Hex(), wangwu.ID.String()) err =collection.RemoveId(wangwu.ID) fmt.Println(&quot;delete&quot;,err) //删除集合 //collection.DropCollection()&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[etcd多台服务器集群环境搭建使用]]></title>
      <url>%2F2018%2F07%2F05%2Fetcd%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[下载安装 etcd1234$ mkdir -p $GOPATH/src/github.com/coreos$ git clone https://github.com/coreos/etcd.git$ cd etcd$ ./build 启动服务每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP 进入到bin目录下$ cd $GOPATH/src/github.com/coreos/etcd/bin 3个ip分别换成3太服务器真实的ip 123456789TOKEN=token-03CLUSTER_STATE=newNAME_1=machine-1NAME_2=machine-2NAME_3=machine-3HOST_1=192.168.1.105HOST_2=192.168.1.143HOST_3=192.168.1.103CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380 machine 1 执行如下命令 123456$ cd $GOPATH/src/github.com/coreos/etcd/bin# For machine 1THIS_NAME=$&#123;NAME_1&#125;THIS_IP=$&#123;HOST_1&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine 2 执行如下命令 123456$ cd $GOPATH/src/github.com/coreos/etcd/bin# For machine 2THIS_NAME=$&#123;NAME_2&#125;THIS_IP=$&#123;HOST_2&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine 3 执行如下命令 123456$ cd $GOPATH/src/github.com/coreos/etcd/bin# For machine 3THIS_NAME=$&#123;NAME_3&#125;THIS_IP=$&#123;HOST_3&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; 检测服务器运行是否正常 3个ip分别换成3太服务器真实的ip 1234567$ cd $GOPATH/src/github.com/coreos/etcd/binexport ETCDCTL_API=3HOST_1=192.168.1.105HOST_2=192.168.1.143HOST_3=192.168.1.103ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379 查看进入集群的服务器列表./etcdctl --endpoints=$ENDPOINTS member list 存储数据1234./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World!&quot;./etcdctl --endpoints=$ENDPOINTS get foo./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo 根据前缀查询123456789101112./etcdctl --endpoints=$ENDPOINTS put web1 value1./etcdctl --endpoints=$ENDPOINTS put web2 value2./etcdctl --endpoints=$ENDPOINTS put web3 value3./etcdctl --endpoints=$ENDPOINTS get web --prefixweb1value1web2value2web3value3 删除123456./etcdctl --endpoints=$ENDPOINTS put key myvalue./etcdctl --endpoints=$ENDPOINTS del key./etcdctl --endpoints=$ENDPOINTS put k1 value1./etcdctl --endpoints=$ENDPOINTS put k2 value2./etcdctl --endpoints=$ENDPOINTS del k --prefix 事务写入1234567891011121314151617181920212223242526272829303132333435363738394041424344$ ./etcdctl --endpoints=$ENDPOINTS put user1 badOK$ ./etcdctl --endpoints=$ENDPOINTS txn --interactivecompares:// 输入以下内容，输入结束按 两次回车value(&quot;user1&quot;) = &quot;bad&quot; //如果 user1 = bad，则执行 get user1 success requests (get, put, del):get user1//如果 user1 != bad，则执行 put user1 goodfailure requests (get, put, del):put user1 good// 运行结果，执行 successSUCCESSuser1bad$ ./etcdctl --endpoints=$ENDPOINTS txn --interactivecompares:value(&quot;user1&quot;) = &quot;111&quot; // 如果 user1 = 111，则执行 get user1 success requests (get, put, del):get user1//如果 user1 != 111，则执行 put user1 2222failure requests (get, put, del):put user1 2222// 运行结果，执行 failureFAILUREOK$ ./etcdctl --endpoints=$ENDPOINTS get user1user12222 watch1234567891011121314151617// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知./etcdctl --endpoints=$ENDPOINTS watch stock1// 新打开终端$ cd $GOPATH/src/github.com/coreos/etcd/binexport ETCDCTL_API=3HOST_1=192.168.1.126HOST_2=192.168.1.119HOST_3=192.168.1.103ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379./etcdctl --endpoints=$ENDPOINTS put stock1 1000./etcdctl --endpoints=$ENDPOINTS watch stock --prefix./etcdctl --endpoints=$ENDPOINTS put stock1 10./etcdctl --endpoints=$ENDPOINTS put stock2 20 更多操作https://coreos.com/etcd/docs/latest/demo.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[etcd在golang中的使用]]></title>
      <url>%2F2018%2F07%2F05%2Fetcd%E5%9C%A8golang%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[什么是etcdETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。 1. 简单：基于HTTP+JSON的API让你用curl就可以轻松使用。 2. 安全：可选SSL客户认证机制。 3. 快速：每个实例每秒支持一千次写操作。 4. 可信：使用Raft算法充分实现了分布式。 !&lt;–more–&gt; 安装在如下路径创建文件夹$ mkdir -p $GOPATH/src/github.com/coreos 下载etcd包$ git clone https://github.com/coreos/etcd.git 下载完后，然后依次执行下面命令123$ cd etcd$ ./build$ ./bin/etcd 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171package mainimport ( &quot;time&quot; &quot;github.com/coreos/etcd/clientv3&quot; &quot;fmt&quot; &quot;context&quot; &quot;github.com/coreos/etcd/mvcc/mvccpb&quot; &quot;ketang/netWork/0604_Socket/Tool&quot;)var ( dialTimeout = 5 * time.Second requestTimeout = 2 * time.Second endPoints = []string&#123;&quot;127.0.0.1:2379&quot;&#125; //etcd 默认接受数据的端口2379)//添加 删除 查找 前缀 延时var etcd *clientv3.Clientfunc main() &#123; fmt.Println(Tool.GetLocalIp()) var err error etcd, err =clientv3.New(clientv3.Config&#123; Endpoints:endPoints, DialTimeout:dialTimeout, &#125;) if err != nil &#123; fmt.Println(err) &#125; //添加 err = putValue(&quot;a&quot;, &quot;abc&quot;) fmt.Println(err) //查找 result := getValue(&quot;a&quot;) fmt.Println(result) //删除 cnt := delValue(&quot;a&quot;) fmt.Println(&quot;delete:&quot;, cnt) err = putValue(&quot;b1&quot;, &quot;abc1&quot;) err = putValue(&quot;b2&quot;, &quot;abc2&quot;) err = putValue(&quot;b3&quot;, &quot;abc3&quot;) //按前缀查找 result = getValueWIthPrefix(&quot;b&quot;) fmt.Println(result) for _,item := range result &#123; fmt.Println(string(item.Key),string(item.Value)) &#125; //按前缀删除 cnt2 := delValueWithPrefix(&quot;b&quot;) fmt.Println(&quot;批量删除：&quot;, cnt2) //事务处理 putValue(&quot;user1&quot;, &quot;zhangsan&quot;) _,err = etcd.Txn(context.TODO()). If(clientv3.Compare(clientv3.Value(&quot;user1&quot;),&quot;=&quot;, &quot;zhangsan&quot;)). Then(clientv3.OpPut(&quot;user1&quot;, &quot;zhangsan&quot;)). Else(clientv3.OpPut(&quot;user1&quot;, &quot;lisi&quot;)).Commit() fmt.Println(err) result = getValue(&quot;user1&quot;) fmt.Println(&quot;user1:&quot;, string(result[0].Value)) //lease 设置有效时间 resp, err:= etcd.Grant(context.TODO(), 1) _,err = etcd.Put(context.TODO(), &quot;username&quot;,&quot;wangwu&quot;,clientv3.WithLease(resp.ID)) time.Sleep(3 * time.Second) v := getValue(&quot;username&quot;) fmt.Println(&quot;lease:&quot;,v) //watch监听的使用 putValue(&quot;w&quot;, &quot;hello&quot;) go func() &#123; rch := etcd.Watch(context.Background(),&quot;w&quot;) for wresp := range rch &#123; for _,ev := range wresp.Events &#123; fmt.Printf(&quot;watch&gt;&gt;w %s %q %q\n&quot;, ev.Type,ev.Kv, ev.Kv) &#125; &#125; &#125;() putValue(&quot;w&quot;, &quot;hello world!&quot;) //监听某个key在一定范围内 value的变化 //putValue(&quot;fo0&quot;, &quot;a&quot;) go func() &#123; //监听范围 [fo0-fo3) rch := etcd.Watch(context.Background(), &quot;fo0&quot;, clientv3.WithRange(&quot;fo3&quot;)) for wresp := range rch &#123; for _,ev := range wresp.Events &#123; fmt.Printf(&quot;watch range -- %s %q %q\n&quot;, ev.Type,ev.Kv, ev.Kv) &#125; &#125; &#125;() putValue(&quot;fo0&quot;, &quot;b&quot;) putValue(&quot;fo1&quot;, &quot;b&quot;) putValue(&quot;fo2&quot;, &quot;c&quot;) putValue(&quot;fo2.5&quot;, &quot;c&quot;) putValue(&quot;fo3&quot;, &quot;c&quot;) time.Sleep(10 * time.Second)&#125;//添加键值对func putValue(key, value string) error &#123; _, err := etcd.Put(context.TODO(),key, value) return err&#125;//查询func getValue(key string) []*mvccpb.KeyValue &#123; resp, err := etcd.Get(context.TODO(), key) if err != nil &#123; return nil &#125; else &#123; return resp.Kvs &#125;&#125;// 返回删除了几条数据func delValue(key string) int64 &#123; res,err := etcd.Delete(context.TODO(),key) if err != nil &#123; return 0 &#125; else &#123; return res.Deleted &#125;&#125;//按照前缀删除func delValueWithPrefix(prefix string) int64 &#123; res,err := etcd.Delete(context.TODO(),prefix,clientv3.WithPrefix()) if err != nil &#123; fmt.Println(err) return 0 &#125; else &#123; return res.Deleted &#125;&#125;func getValueWIthPrefix(prefix string) []*mvccpb.KeyValue &#123; resp, err := etcd.Get(context.TODO(), prefix, clientv3.WithPrefix()) if err != nil &#123; return nil &#125; else &#123; return resp.Kvs &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分布式Raft算法原理及实现]]></title>
      <url>%2F2018%2F07%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8FRaft%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[Raft 状态一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一： follower（跟随者） ：所有结点都以 follower 的状态开始。如果没收到 leader消息则会变成 candidate状态。 candidate（候选人）：会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election)。 leader（领导者）：所有对系统的修改都会先经过leader。 Raft 一致性算法Raft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。 基于leader的方法，Raft算法可以分解成三个子问题： Leader election (领导选举)：原来的leader挂掉后，必须选出一个新的leader Log replication (日志复制)：leader从客户端接收日志，并复制到整个集群中 Safety (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项 Leader election (领导选举)Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 follower(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，follower 会给当前term加1并且转换成candidate状态。 然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候， 他自己赢得了这次的选举 如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。 当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。 其他的服务器成为领导者 如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理： 如果leader的term大于或等于自身的term，那么改candidate 会转成follower 状态 如果leader的term小于自身的term，那么会拒绝该 leader，并继续保持candidate 状态 一段时间之后没有任何一个获胜的人 有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。 Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。 Log replication (日志复制)当选出 leader 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。leader 把指令追加成一个log entry，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，leader 会把该entry回放到状态机中，然后把结果返回给客户端。 当 follower 宕机或者运行较慢时，leader 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。 raft的log replication保证以下性质(Log Matching Property)： 如果两个log entry有相同的index和term，那么它们存储相同的指令 如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的 其中特性一通过以下保证： leader在一个特定的term和index下，只会创建一个log entry log entry不会改变它们在日志中的位置 特性二通过以下保证： AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm) 如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。 安全性选举限制在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。 为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。 提交之前任期内的日志条目领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。 如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下： 图a中，S1被选为主，然后复制到log index为2的log entry到S2上 图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3) 图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉 图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry 为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。 安全性论证以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。 如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。 在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。 领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。 这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。 投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。 因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目 跟随者和候选人崩溃跟随者或者候选人崩溃，会按如下处理： 领导者会不断给它发送选举和追加日志的RPC，直到成功 跟随者会忽略它已经处理过的追加日志的RPC 时间和可用性领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求： 1广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF） 广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间； 选举超时时间就是选举的超时时间限制 平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。 选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。 选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。 对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。 动画演示 Rafthttp://thesecretlivesofdata.com/raft/ 代码实现实现效果：4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287package mainimport ( &quot;fmt&quot; &quot;flag&quot; &quot;net&quot; &quot;strconv&quot; &quot;time&quot; &quot;strings&quot; &quot;net/http&quot; &quot;math/rand&quot;)const ( LEADER = iota CANDIDATE FOLLOWER)//声明地址信息type Addr struct &#123; Host string //ip Port int Addr string&#125;type RaftServer struct &#123; Votes int //选票 Role int // 角色 follower candidate leader Nodes []Addr isElecting bool //判断当前节点是否处于选举中 Timeout int //选举间隔时间（也叫超时时间） ElecChan chan bool //通道信号 HeartBeatChan chan bool //leader 的心跳信号 Port int //端口号 //网页接收到的参数 由主节点向子节点传参 CusMsg chan string&#125;func (rs *RaftServer)changeRole(role int) &#123; switch role &#123; case LEADER: fmt.Println(&quot;leader&quot;) case CANDIDATE: fmt.Println(&quot;candidate&quot;) case FOLLOWER: fmt.Println(&quot;follower&quot;) &#125; rs.Role = role&#125;func (rs *RaftServer)resetTimeout() &#123; //Raft系统一般为1500-3000毫秒选一次 rs.Timeout = 2000&#125;//运行服务器func (rs *RaftServer)Run() &#123; //rs监听 是否有人 给我投票 listen , _ := net.Listen(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(rs.Port)) defer listen.Close() go rs.elect() //控制投票时间 go rs.electTimeDuration() //go rs.printRole() // 主节点发送心跳 go rs.sendHeartBeat() // go rs.sendDataToOtherNodes() //监听http协议 go rs.setHttpServer() for &#123; conn,_ := listen.Accept() go func()&#123; for &#123; by := make([]byte, 1024) n,_:= conn.Read(by) fmt.Println(&quot;收到消息&quot;, string(by[:n])) value := string(by[:n]) v,_ := strconv.Atoi(value) if v == rs.Port &#123; rs.Votes++ fmt.Println(&quot;当前票数：&quot;, rs.Votes) // leader 选举成功 if VoteSuccess(rs.Votes, 5) == true &#123; fmt.Printf(&quot;我是 %v, 我被选举成leader&quot;, rs.Port) //通知其他节点。停止选举 //重置其他节点状态和票数 rs.VoteToOther(&quot;stopVote&quot;) rs.isElecting = false //改变当前节点状态 rs.changeRole(LEADER) break &#125; &#125; //收到leader发来的消息 if strings.HasPrefix(string(by[:n]), &quot;stopVote&quot;) &#123; //停止给别人投票 rs.isElecting = false //回退自己的状态 rs.changeRole(FOLLOWER) break &#125; &#125; &#125;() &#125;&#125;func VoteSuccess(vote int, target int) bool &#123; if vote &gt;= target &#123; return true &#125; return false&#125;//发送数据)func (rs *RaftServer)VoteToOther(data string) &#123; for _,k := range rs.Nodes &#123; if k.Port != rs.Port &#123; if data == &quot;1234&quot; &#123; fmt.Println(&quot;-------------&quot;, k.Port) &#125; label :conn,err := net.Dial(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(k.Port)) for &#123; if err != nil &#123; time.Sleep(1*time.Second) goto label &#125; break &#125; conn.Write([]byte(data)) &#125; &#125;&#125;//给别人投票func (rs *RaftServer)elect() &#123; for &#123; //通过通道确定现在可以给别人投票 &lt;- rs.ElecChan //给其他节点投票，不能投给自己 vote := getVoteNum() rs.VoteToOther(strconv.Itoa(vote)) // 设置选举状态 if rs.Role != LEADER &#123; rs.changeRole(CANDIDATE) &#125; else &#123; //是leader的情况 return &#125; &#125;&#125;func getVoteNum() int &#123; rand.Seed(time.Now().UnixNano()) return rand.Intn(4) + 5000&#125;func (rs *RaftServer)electTimeDuration() &#123; // fmt.Println(&quot;+++&quot;, rs.isElecting) for &#123; if rs.isElecting &#123; rs.ElecChan &lt;- true time.Sleep(time.Duration(rs.Timeout) * time.Millisecond) &#125; &#125;&#125;//打印当前对象的角色func (rs *RaftServer)printRole() &#123; for &#123; time.Sleep(1 * time.Second) fmt.Println(rs.Port, &quot;状态为&quot;, rs.Role, rs.isElecting) &#125;&#125;func main() &#123; //获取参数 //运行 go run main.go -p 5000 (p 后面就是要启动的端口) port := flag.Int(&quot;p&quot;,1234,&quot;port&quot;) flag.Parse() fmt.Println(*port) rs := RaftServer&#123;&#125; rs.isElecting = true rs.Votes = 0 rs.Role = FOLLOWER //控制是否开始投票 rs.ElecChan = make(chan bool) rs.HeartBeatChan = make(chan bool) rs.CusMsg = make(chan string) rs.resetTimeout() rs.Nodes = []Addr&#123; &#123;&quot;127.0.0.1&quot;,5000,&quot;5000&quot;&#125;, &#123;&quot;127.0.0.1&quot;,5001,&quot;5001&quot;&#125;, &#123;&quot;127.0.0.1&quot;,5002,&quot;5002&quot;&#125;, &#123;&quot;127.0.0.1&quot;,5003,&quot;5003&quot;&#125;, &#125; rs.Port = *port rs.Run()&#125;//主节点发送心跳信号给其他节点func (rs *RaftServer)sendHeartBeat() &#123; // 每隔1s 发送一次心跳 for &#123; time.Sleep(1 * time.Second) if rs.Role == LEADER &#123; //发送消息 rs.VoteToOther(&quot;heat beating&quot;) &#125; &#125;&#125;//通过leader 给其他所有子节点发送数据func (rs *RaftServer)sendDataToOtherNodes() &#123; for &#123; msg :=&lt;-rs.CusMsg if rs.Role == LEADER &#123; //发送消息 rs.VoteToOther(msg) &#125; &#125;&#125;//开启http服务器func (rs *RaftServer)setHttpServer() &#123; http.HandleFunc(&quot;/req&quot;, rs.request) httpPort := rs.Port + 10 if err:=http.ListenAndServe(&quot;:&quot;+strconv.Itoa(httpPort), nil); err == nil &#123; fmt.Println(err) &#125;&#125;//leader向其他子节点发送数据func (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request)&#123; request.ParseForm() if len(request.Form[&quot;data&quot;][0]) &gt; 0 &#123; writer.Write([]byte(&quot;ok&quot;)) fmt.Println(request.Form[&quot;data&quot;][0]) rs.CusMsg &lt;- request.Form[&quot;data&quot;][0] &#125;&#125; 运行：开启4个终端 分别执行 go run main.go -p 5000 go run main.go -p 5001 go run main.go -p 5002 go run main.go -p 5003 如果5001成为了leader，在浏览器输入http://127.0.0.1:5011/req?data=XXXxxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[拜占庭PBFT简单实现]]></title>
      <url>%2F2018%2F07%2F03%2F%E6%8B%9C%E5%8D%A0%E5%BA%ADPBFT%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[PBFT（拜占庭容错）基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示： 其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下： Request：请求端C发送请求到任意一节点，这里是0 Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123 Prepare：123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播 Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package mainimport ( &quot;os&quot; &quot;fmt&quot; &quot;net/http&quot; &quot;io&quot;)//声明节点信息,代表各个小国家type nodeInfo struct &#123; //标示 id string //准备访问的方法 path string //服务器做出的相应 writer http.ResponseWriter&#125;//存放四个国家的地址var nodeTable = make(map[string]string)//拜占庭在Fabric中的使用func main() &#123; //获取执行的参数 userId :=os.Args[1]//获取执行的第一个参数 fmt.Println(userId) //./main Apple //创建四个国家的地址 nodeTable = map[string]string &#123; &quot;Apple&quot;:&quot;localhost:1111&quot;, &quot;MS&quot;:&quot;localhost:1112&quot;, &quot;Google&quot;:&quot;localhost:1113&quot;, &quot;IBM&quot;:&quot;localhost:1114&quot;, &#125; node:=nodeInfo&#123;userId,nodeTable[userId],nil&#125; fmt.Println(node) //http协议的回调函数 //http://localhost:1111/req?warTime=8888 http.HandleFunc(&quot;/req&quot;,node.request) http.HandleFunc(&quot;/prePrepare&quot;,node.prePrepare) http.HandleFunc(&quot;/prepare&quot;,node.prepare) http.HandleFunc(&quot;/commit&quot;,node.commit) //启动服务器 if err:=http.ListenAndServe(node.path,nil);err!=nil &#123; fmt.Print(err) &#125;&#125;//此函数是http访问时候req命令的请求回调函数func (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request)&#123; //设置允许解析参数 request.ParseForm() //如果有参数值，则继续处理 if (len(request.Form[&quot;warTime&quot;])&gt;0)&#123; node.writer = writer //激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播 node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prePrepare&quot;) &#125;&#125;//由主节点向其他节点做广播func (node *nodeInfo)broadcast(msg string ,path string )&#123; //遍历所有的国家 for nodeId,url:=range nodeTable &#123; if nodeId == node.id &#123; continue &#125; //调用Get请求 //http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;) http.Get(&quot;http://&quot;+url+path+&quot;?warTime=&quot;+msg+&quot;&amp;nodeId=&quot;+node.id) &#125;&#125;func (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) &#123; request.ParseForm() //fmt.Println(&quot;hello world&quot;) //在做分发 if(len(request.Form[&quot;warTime&quot;])&gt;0)&#123; //分发给其他三个人 node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;) &#125;&#125;func (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request)&#123; request.ParseForm() //调用验证 if len(request.Form[&quot;warTime&quot;])&gt;0&#123; fmt.Println(request.Form[&quot;warTime&quot;][0]) &#125; if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123; fmt.Println(request.Form[&quot;nodeId&quot;][0]) &#125; node.authentication(request)&#125;var authenticationsuccess = truevar authenticationMap = make(map[string]string)//获得除了本节点外的其他节点数据func (node *nodeInfo)authentication(request *http.Request) &#123; //接收参数 request.ParseForm() if authenticationsuccess!=false &#123; if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123; authenticationMap[request.Form[&quot;nodeId&quot;][0]]=&quot;ok&quot; &#125; &#125; if len(authenticationMap)&gt;len(nodeTable)/3 &#123; //则拜占庭原理实现,通过commit反馈给浏览器 node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;) &#125;&#125;func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)&#123; //给浏览器反馈相应 io.WriteString(node.writer,&quot;ok&quot;)&#125; 如何运行：开启4个终端，eg：go run main.go Apple …然后在浏览器输入：http://localhost:1112/req?warTime=1234]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[共识算法DPOS原理及实现]]></title>
      <url>%2F2018%2F06%2F29%2F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95DPOS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[原理简介DPOS：Delegated Proof of Stake，委任权益证明它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。 算法具体实现原理假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。 代码简单实现其原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot; &quot;strconv&quot; &quot;crypto/sha256&quot; &quot;encoding/hex&quot;)type Block struct &#123; Index int Timestamp string Prehash string Hash string Data []byte delegate *Node// 代理 区块由哪个节点挖出&#125;func GenesisBlock() Block &#123; gene := Block&#123;0, time.Now().String(),&quot;&quot;, &quot;&quot;, []byte(&quot;genesis block&quot;), nil&#125; gene.Hash = string(blockHash(gene)) return Block&#123;&#125;&#125;func blockHash(block Block) []byte &#123; record := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data) h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hashed&#125;//节点类型type Node struct &#123; Name string //节点名称 Votes int // 被选举的票数&#125;func (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block &#123; var newBlock = Block&#123;lastBlock.Index+1, time.Now().String(), lastBlock.Hash, &quot;&quot;, data, nil&#125; newBlock.Hash = hex.EncodeToString(blockHash(newBlock)) newBlock.delegate = node return newBlock&#125;//创建节点var NodeArr = make([]Node,10)func CreateNode() &#123; for i := 0; i &lt; 10; i++ &#123; name := fmt.Sprintf(&quot;NODE %d num&quot;, i+1) NodeArr[i] = Node&#123;name, 0&#125; &#125;&#125;//简单模拟投票func Vote() &#123; for i := 0; i &lt; 10; i++ &#123; rand.Seed(time.Now().UnixNano()) vote := rand.Intn(10) + 1 NodeArr[i].Votes = vote &#125;&#125;//选出票数最多的前3位func SortNodes() []Node &#123; n:= NodeArr for i := 0; i&lt;len(n) ;i++ &#123; for j := 0; j &lt; len(n)-1 ;j++ &#123; if n[j].Votes &lt; n[j+1].Votes &#123; n[j],n[j+1] = n[j+1],n[j] &#125; &#125; &#125; return n[:3]&#125;func main() &#123; CreateNode() fmt.Println(NodeArr) Vote() nodes := SortNodes() fmt.Println(nodes) //创建创世区块 gene := GenesisBlock() lastBlock := gene for i:= 0; i&lt; len(nodes) ;i++ &#123; lastBlock = nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(&quot;new block %d&quot;,i))) &#125;&#125; 输出12345竞选的节点 [&#123;第 1 个节点 0&#125; &#123;第 2 个节点 0&#125; &#123;第 3 个节点 0&#125; &#123;第 4 个节点 0&#125; &#123;第 5 个节点 0&#125; &#123;第 6 个节点 0&#125; &#123;第 7 个节点 0&#125; &#123;第 8 个节点 0&#125; &#123;第 9 个节点 0&#125; &#123;第 10 个节点 0&#125;]选出的节点 [&#123;第 10 个节点 8&#125; &#123;第 4 个节点 7&#125; &#123;第 3 个节点 6&#125;]第 10 个节点 出块 &#123;1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000&#125;第 4 个节点 出块 &#123;2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018&#125;第 3 个节点 出块 &#123;3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[共识算法POS原理及实现]]></title>
      <url>%2F2018%2F06%2F29%2F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95POS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[POS简介POS：Proof of Stake，股权证明类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。 算法具体实现原理每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。 代码简单实现其原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package mainimport ( &quot;time&quot; &quot;strconv&quot; &quot;crypto/sha256&quot; &quot;math/rand&quot; &quot;fmt&quot; &quot;encoding/hex&quot;)//实现pos挖矿的原理type Block struct &#123; Index int Data string // PreHash string Hash string Timestamp string //记录挖矿节点 Validator *Node&#125;func genesisBlock() Block &#123; var genesBlock = Block&#123;0, &quot;Genesis block&quot;,&quot;&quot;,&quot;&quot;,time.Now().String(),&amp;Node&#123;0, 0, &quot;dd&quot;&#125;&#125; genesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock)) return genesBlock&#125;func BlockHash(block *Block) []byte &#123; record := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address h := sha256.New() h.Write([]byte(record)) hashed := h.Sum(nil) return hashed&#125;//创建全节点类型type Node struct &#123; Tokens int //持币数量 Days int //持币时间 Address string //地址&#125;//创建5个节点//算法的实现要满足 持币越多的节点越容易出块var nodes = make([]Node, 5)//存放节点的地址var addr = make([]*Node, 15)func InitNodes() &#123; nodes[0] = Node&#123;1, 1, &quot;0x12341&quot;&#125; nodes[1] = Node&#123;2, 1, &quot;0x12342&quot;&#125; nodes[2] = Node&#123;3, 1, &quot;0x12343&quot;&#125; nodes[3] = Node&#123;4, 1, &quot;0x12344&quot;&#125; nodes[4] = Node&#123;5, 1, &quot;0x12345&quot;&#125; cnt :=0 for i:=0;i&lt;5;i++ &#123; for j:=0;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123; addr[cnt] = &amp;nodes[i] cnt++ &#125; &#125;&#125;//采用Pos共识算法进行挖矿func CreateNewBlock(lastBlock *Block, data string) Block&#123; var newBlock Block newBlock.Index = lastBlock.Index + 1 newBlock.Timestamp = time.Now().String() newBlock.PreHash = lastBlock.Hash newBlock.Data = data //通过pos计算由那个村民挖矿 //设置随机种子 rand.Seed(time.Now().Unix()) //[0,15)产生0-15的随机值 var rd =rand.Intn(15) //选出挖矿的旷工 node := addr[rd] //设置当前区块挖矿地址为旷工 newBlock.Validator = node //简单模拟 挖矿所得奖励 node.Tokens += 1 newBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock)) return newBlock&#125;func main() &#123; InitNodes() //创建创世区块 var genesisBlock = genesisBlock() //创建新区快 var newBlock = CreateNewBlock(&amp;genesisBlock, &quot;new block&quot;) //打印新区快信息 fmt.Println(newBlock) fmt.Println(newBlock.Validator.Address) fmt.Println(newBlock.Validator.Tokens)&#125; 输出123&#123;1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0&#125;0x123412]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[共识算法POW原理及实现]]></title>
      <url>%2F2018%2F06%2F29%2F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95POW%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[POW简介Proof of Work，工作证明。POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法 算法具体实现原理这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。 代码简单实现其原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package mainimport ( &quot;strconv&quot; &quot;time&quot; &quot;crypto/sha256&quot; &quot;strings&quot; &quot;encoding/hex&quot; &quot;fmt&quot;)//pow 挖矿算法//定义难度系数const difiiculty = 4type Block struct &#123; Index int // 区块高度 TimeStamp int64 Data string //交易记录 Hash string Prehash string Nonce int Difficulty int //难度系数&#125;//创建区块链var BlockChain []Block//创世区块func GenesisBlock() *Block &#123; var geneBlock = Block&#123;0, time.Now().Unix(), &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, difiiculty&#125; geneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock)) return &amp;geneBlock&#125;func BlockHash(block Block) []byte &#123; re := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash + strconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty) h := sha256.New() h.Write([]byte(re)) hashed := h.Sum(nil) return hashed&#125;func isBlockValid(block Block) bool &#123; prefix := strings.Repeat(&quot;0&quot;, block.Difficulty) return strings.HasPrefix(block.Hash, prefix)&#125;//创建新区块 pow挖矿func CreateNewBlock(lastBlock *Block, data string) *Block &#123; var newBlock Block newBlock.Index = lastBlock.Index + 1 newBlock.TimeStamp = time.Now().Unix() newBlock.Data = data newBlock.Prehash = lastBlock.Hash newBlock.Difficulty = difiiculty newBlock.Nonce = 0 //开挖-当前区块的hash值的前面的0的个数与难度系数值相同 for &#123; //计算hash cuhash := hex.EncodeToString(BlockHash(newBlock)) fmt.Println(&quot;挖矿中&quot;,cuhash) newBlock.Hash = cuhash if isBlockValid(newBlock) &#123; //校验区块 if VerflyBlock(newBlock, *lastBlock) &#123; fmt.Println(&quot;挖矿成功&quot;) return &amp;newBlock &#125; &#125; newBlock.Nonce ++ &#125;&#125;//校验新的区块是否合法func VerflyBlock(newblock Block, lastBlock Block) bool &#123; if lastBlock.Index +1 !=newblock.Index &#123; return false &#125; if newblock.Prehash !=lastBlock.Hash &#123; return false &#125; return true&#125;func main() &#123; var genBlock = GenesisBlock() newBlock := CreateNewBlock(genBlock,&quot;新区块&quot;) fmt.Println(newBlock)&#125; 输出 123456挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811挖矿成功&amp;&#123;1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DSA和ECC签名验签]]></title>
      <url>%2F2018%2F06%2F28%2FDSA%E5%92%8CECC%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[DSADSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。在安全性上，DSA和RSA差不多，但是速度比RSA快很多。 DSA签名和验签123456789101112131415161718192021222324252627func main() &#123; //设置私钥使用的参数 var param dsa.Parameters dsa.GenerateParameters(&amp;param, rand.Reader, dsa.L1024N160) //创建私钥 var pri dsa.PrivateKey pri.Parameters = param dsa.GenerateKey(&amp;pri, rand.Reader) //生成公钥 pub := pri.PublicKey //签名 message := []byte(&quot;hello&quot;) r,s,_ := dsa.Sign(rand.Reader, &amp;pri, message) //验证 if dsa.Verify(&amp;pub, message, r, s)&#123; fmt.Println(&quot;验签成功&quot;) &#125; &#125; ECC椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。 椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。比特币就是用ECC来做签名和验签。 优点 安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。 计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多 存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多 带宽要求低使得ECC具有广泛得应用前景 椭圆曲线一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。 E:y2=ax3+ bx2+cx+d 例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为: E:y2=x3-2x+4 该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。 ECC签名和验签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func main() &#123; message := []byte(&quot;hello&quot;) //设置生成的私钥为256位 privatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader) //创建公钥 publicKey := privatekey.PublicKey //hash散列明文 digest := sha256.Sum256(message) //用私钥签名 r,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:]) //设置私钥的参数类型 param := privatekey.Curve.Params() //获取私钥的长度（字节） curveOrderBytes:=param.P.BitLen()/8 //获得签名返回的字节 rByte,sByte := r.Bytes(), s.Bytes() //创建数组合并字节 signature := make([]byte,curveOrderBytes*2) copy(signature[:len(rByte)], rByte) copy(signature[len(sByte):], sByte) //现在signature中就存放了完整的签名的结果 //验签 digest = sha256.Sum256(message) //获得公钥的字节长度 curveOrderBytes= publicKey.Curve.Params().P.BitLen()/8 //创建大整数类型保存rbyte,sbyte r,s = new(big.Int),new(big.Int) r.SetBytes(signature[:curveOrderBytes]) s.SetBytes(signature[curveOrderBytes:]) //开始认证 e:=ecdsa.Verify(&amp;publicKey,digest[:],r,s) if e== true &#123; fmt.Println(&quot;验签成功&quot;) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RSA签名验签]]></title>
      <url>%2F2018%2F06%2F28%2FRSA%E7%AD%BE%E5%90%8D%E9%AA%8C%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[什么是数字签名数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。 签名的生成和验证生成消息签名的行为生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。 验证消息签名的行为验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。 公钥密码与数字签名在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。 公钥密码机制公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有用与之对应的私钥才能正确解密。 数字签名数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 私钥加密 相当于 生成签名，而用 公钥解密 则相当于验证签名。 数字签名算法RSARSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。 DSADSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。 ECDSAECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字签名算法( NIST FIPS 186-3 )。 RSA算法实现签名和验签123456789101112131415161718192021222324252627282930313233func main() &#123; //生成私钥 pri,_ := rsa.GenerateKey(rand.Reader, 1024) //生成公钥 pub := &amp;pri.PublicKey plainTxt := []byte(&quot;hello world，你好&quot;) //对原文进行hash散列 h := md5.New() h.Write(plainTxt) hashed := h.Sum(nil) opts := rsa.PSSOptions&#123;rsa.PSSSaltLengthAuto, crypto.MD5&#125; //实现签名 sign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&amp;opts) fmt.Println(hex.EncodeToString(sign)) //通过公钥实现验签 err:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &amp;opts) //err 为空 及验签成功 fmt.Println(&quot;err:&quot;, err)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[非对称加密RSA原理简介及使用]]></title>
      <url>%2F2018%2F06%2F27%2F%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86RSA%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[什么是RSARSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。 RSA可以被用于公钥密码和数字签名。 RSA加密在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达： 密文=明文E mod N (RSA加密) RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。 加密公式中出现的两个数E和 N，到底都是什么数呢? RSA的加密是求明文的E次方mod N，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，E 和 N是RSA加密的密钥，也就是说，E 和 N的组合就是公钥。 RSA解密RSA的解密和加密一样简单，可以用下面的公式来表达: 明文=密文 D mod N ( RSA解密) 表示密文的数字的D次方求 mod N就可以得到明文。 这里所使用的数字N和加密时使用的数字N是相同的。数 D 和数 N 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。 在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 modN”，而解密则是求“密文的D次方的 mod N”。 生成密钥对在RSA中，加密是求“明文的E次方的 modN”，而解密则是求“密文的D次方的 mod N”。 由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。 生成私钥公钥步骤用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥） 1.生成 RSA 私钥（传统格式的） openssl genrsa -out rsa_private_key.pem 1024 2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车 openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM 3.生成 RSA 公钥 openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 此时在系统根目录已经生成了两个文件。可以直接使用cat命令查看文件中的内容 代码实现加密以及解密过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQABAoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPewMtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaemUOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1ybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNAJh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhwnfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrrt4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9T+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtFIXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi-----END RSA PRIVATE KEY-----`)var publicKey = []byte(`-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB-----END PUBLIC KEY-----`)func main() &#123; data := []byte(&quot;hello world&quot;) cry := RSAEncrypt(data) fmt.Println(hex.EncodeToString(cry)) ori := RSADecrypt(cry) fmt.Println(string(ori))&#125;func RSAEncrypt(plaintxt []byte) []byte &#123; //公钥加密 block, _:= pem.Decode(publicKey) //解析公钥 pubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes) //加载公钥 pub := pubInterface.(*rsa.PublicKey) //加密明文 bits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt) //bits为最终的密文 return bits&#125;func RSADecrypt(cryptTxt []byte) []byte &#123; block,_:= pem.Decode(privateKey) priv,_:= x509.ParsePKCS1PrivateKey(block.Bytes) bits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt) return bits&#125; 输出124bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8ahello world 代码实现生成公钥私钥来加密和解密12345678910111213141516171819202122232425262728293031func main() &#123; prikey := CreatePrivateKey() pubKey := CreatePublic(prikey) // 加密和解密 ori:=[]byte(&quot;hello world!!!&quot;) //通过oaep函数实现公钥加密 //第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要 cipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &amp;pubKey, ori, nil) fmt.Println(cipherTxt) //解密 plainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil) fmt.Println(string(plainTxt)) &#125;// 创建私钥func CreatePrivateKey() *rsa.PrivateKey &#123; // 长度为1024 位 的私钥 pri,_:= rsa.GenerateKey(rand.Reader, 1024) return pri&#125;// 生成公钥func CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey &#123; return prikey.PublicKey&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对称加密算法AES原理及实现]]></title>
      <url>%2F2018%2F06%2F27%2F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95AES%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。 AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。 总体结构AES中没有使用Feistel网络，其结构称为SPN结构。 和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。 AES总体结构示意图： 分组密码密码算法可以分为分组密码和流密码两种 分组密码（block cipher）是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。 例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。 流密码（stream cipher）是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。 分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。 模式分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。 ECB模式：Electronic CodeBook mode（电子密码模式） CBC模式：Cipher Block Chaining mode（密码分组链接模式） CFB模式：Cipher FeedBack mode（密文反馈模式） OFB模式：Output FeedBack mode（输出反馈模式） CTR模式：CounTeR mode（计数器模式） ECB模式存在很高的风险，下面举例后面4中模式的使用.加密的过程中使用了随机流，所以每次加密的密文都不一样 CBC模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273func main() &#123; key := &quot;1234567890asdfgh&quot; data := &quot;hollo, world!&quot; cry := AesCBCEncrypt([]byte(data), []byte(key)) fmt.Println(hex.EncodeToString(cry)) oriData := AESCBCDECriypt(cry, []byte(key)) fmt.Println(string(oriData))&#125;// AES也是对称加密 AES 是 DES 的替代品// AES 密钥长度 只能是 16、24、32 字节//加密func AesCBCEncrypt(org []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) //按照公钥长度 进行分组补码 org = PKCS7Padding(org, block.BlockSize()) //设置CBC的加密模式 blockMode := cipher.NewCBCEncrypter(block, key) //加密处理 crypted := make([]byte, len(org)) blockMode.CryptBlocks(crypted, org) return crypted&#125;//解密func AESCBCDECriypt(criptText []byte, key []byte) []byte &#123; //校验key的有效性 block,_:=aes.NewCipher(key) //通过CBC模式解密 blockMode:=cipher.NewCBCDecrypter(block,key) //实现解密 origData:=make([]byte,len(criptText)) blockMode.CryptBlocks(origData,criptText) //去码 origData = PKCS7UnPadding(origData) return origData&#125;//PKCS5 分组长度只能为8//PKCs7 分组长度 1- 255func PKCS7Padding(org []byte, blockSize int) []byte &#123; pad := blockSize-len(org)%blockSize padArr := bytes.Repeat([]byte&#123;byte(pad)&#125;, pad) return append(org, padArr...)&#125;func PKCS7UnPadding(cryptText []byte) []byte &#123; length := len(cryptText) lastByte := cryptText[length - 1] return cryptText[:length-int(lastByte)] &#125; 输出12ffa22c136fd3e944255d43e255c98ecchollo, world! CFB模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061func main() &#123; key := []byte(&quot;1234567890asdfgh&quot;) data := []byte(&quot;abc hello world!&quot;) cry := AESCFBEncrypt(data, key) fmt.Println(hex.EncodeToString(cry)) //fmt.Println(base64.StdEncoding.EncodeToString(cry)) ori := AESCFBDecrypt(cry, key) fmt.Println(string(ori))&#125;//CFB分组模式加密func AESCFBEncrypt(oriData []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) //拆分iv和密文 cipherText := make([]byte, aes.BlockSize + len(oriData)) iv := cipherText[:aes.BlockSize] //向iv切片数组初始化 reader（随机内存流） io.ReadFull(rand.Reader, iv) //设置加密模式CFB stream := cipher.NewCFBEncrypter(block,iv) //加密 stream.XORKeyStream(cipherText[aes.BlockSize:], oriData) return cipherText&#125;//解密func AESCFBDecrypt(cryptText []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) //拆分iv 和密文 iv := cryptText[:aes.BlockSize] cipherText := cryptText[aes.BlockSize:] //设置解密模式 stream := cipher.NewCFBDecrypter(block, iv) var des = make([]byte, len(cipherText)) //解密 stream.XORKeyStream(des, cipherText) return des&#125; 输出1292e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513abc hello world! OFB模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func main() &#123; key := []byte(&quot;1234567890asdfgh&quot;) data := []byte(&quot;abcd hello world!&quot;) cry := AESOFBEncrypt(data, key) fmt.Println(hex.EncodeToString(cry)) ori := AESOFBDecrypt(cry, key) fmt.Println(string(ori))&#125;//AES OFB分组加密模式 CTR也是一样func AESOFBEncrypt(plaintxt []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) cipherText := make([]byte, aes.BlockSize + len(plaintxt)) iv := cipherText[:aes.BlockSize] //向iv切片数组初始化 reader（随机内存流） io.ReadFull(rand.Reader, iv) //设置加密模式CFB stream := cipher.NewOFB(block,iv) //加密 stream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt) return cipherText&#125;//解密func AESOFBDecrypt(cryptText []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) //拆分iv 和 密文 iv := cryptText[:aes.BlockSize] plaintxt := make([]byte, len(cryptText)-aes.BlockSize) //设置解密模式 stream := cipher.NewOFB(block, iv) //解密 stream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:]) return plaintxt&#125; 输出129ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4abcd hello world! CTR模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func main() &#123; key := []byte(&quot;1234567890asdfgh&quot;) data := []byte(&quot;abcd hello world!&quot;) cry := AESCTREncrypt(data, key) fmt.Println(hex.EncodeToString(cry)) ori := AESCTRDecrypt(cry, key) fmt.Println(string(ori))&#125;//AES CTR分组加密模式func AESCTREncrypt(plaintxt []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) cipherText := make([]byte, aes.BlockSize + len(plaintxt)) iv := cipherText[:aes.BlockSize] //向iv切片数组初始化 reader（随机内存流） io.ReadFull(rand.Reader, iv) //设置加密模式CTR stream := cipher.NewCTR(block,iv) //加密 stream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt) return cipherText&#125;//解密func AESCTRDecrypt(cryptText []byte, key []byte) []byte &#123; //校验密钥 block,_ := aes.NewCipher(key) //拆分iv 和 密文 iv := cryptText[:aes.BlockSize] plaintxt := make([]byte, len(cryptText)-aes.BlockSize) //设置解密模式 stream := cipher.NewCTR(block, iv) //解密 stream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:]) return plaintxt&#125; 输出12c645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534abcd hello world!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对称加密算法DES原理及实现]]></title>
      <url>%2F2018%2F06%2F26%2F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95DES%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[DES加密算法DES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。 DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。 Feistel网络DES的基本结构，由IBM公司的Horst Feistel设计，因此称Feistel网络。在Feistel网络中，加密的每个步骤称为轮，经过初始置换后的64位明文，进行了16轮Feistel轮的加密过程，最后经过终结置换后形成最终的64位密文。如下为Feistel网络的示意图： 64位明文被分为左、右两部分处理，右侧数据和子密钥经过轮函数f生成用于加密左侧数据的比特序列，与左侧数据异或运算，运算结果输出为加密后的左侧，右侧数据则直接输出为右侧。 其中子密钥为本轮加密使用的密钥，每次Feistel均使用不同的子密钥。子密钥的计算，以及轮函数的细节，稍后下文介绍。由于一次Feistel轮并不会加密右侧，因此需要将上一轮输出后的左右两侧对调后，重复Feistel轮的过程，DES算法共计进行16次Feistel轮，最后一轮输出后左右两侧无需对调。 DES加密和解密的过程一致，均使用Feistel网络实现，区别仅在于解密时，密文作为输入，并逆序使用子密钥。 DES 加密算法的使用在使用DES加密前，需要自己实现对明文的补码和去码操作 补码1234567891011121314//实现PKCS5Padding补码func PKCS5Padding(cipherTxt [] byte, blockSize int) []byte &#123; //计算准备添加的数字 padding := blockSize - len(cipherTxt)%blockSize //得到补码 padTxt := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding) //拼接原文与补码 var byteTxt = append(cipherTxt, padTxt...) return byteTxt&#125; 去码1234567//PKCS5Unpadding 去码func PKCS5UnPadding(cipherTxt []byte) []byte &#123; var l = len(cipherTxt) var txt = int(cipherTxt[l-1]) res := cipherTxt[:l-txt] return res&#125; DES加密123456789101112131415161718// key 必须为8位func EnDESEncrypt (origData []byte, key []byte) []byte &#123; //校验密钥 block, _ := des.NewCipher(key) //设置补码 origData = MyDES.PKCS5Padding(origData, block.BlockSize()) //设置CBC加密模式 blockMode := cipher.NewCBCEncrypter(block, key) //加密明文 crypted := make([]byte, len(origData)) blockMode.CryptBlocks(crypted, origData) return crypted&#125; DES解密1234567891011121314func DeDESCriypt(cript []byte, key []byte) []byte &#123; //校验key的有效性 block,_:=des.NewCipher(key) //通过CBC模式解密 blockMode:=cipher.NewCBCDecrypter(block,key) //实现解密 origData:=make([]byte,len(cript)) blockMode.CryptBlocks(origData,cript) //去码 origData = MyDES.PKCS5UnPadding(origData) return origData&#125; 使用12345678910func main() &#123; key := []byte(&quot;aswedrfg&quot;) var data =[]byte(&quot;hello world&quot;) var cipherTxt = EnDESEncrypt(data,key) fmt.Println(&quot;加密的结果：&quot;,hex.EncodeToString( cipherTxt)) var origData=DeDESCriypt(cipherTxt,key) fmt.Println(&quot;解密后的结果为:&quot;,string(origData))&#125; 输出结果12加密的结果： 935ae7ca3229f6c707bb9de9db9693c7解密后的结果为: hello world 根据DES原理自己实现加密解密过程加密1234567891011121314func EnCrypt(key string, data []byte) []byte &#123; var sum = 0 for i := 0; i &lt; len(key); i++ &#123; sum += int(key[i]) &#125; // 对明文进行补码 var pad = PKCS5Padding(data, len(key)) //通过加法，实现简单加密 for i := 0;i&lt;len(pad);i++&#123; pad[i] = pad[i]+byte(sum) &#125; return pad&#125; 解密123456789101112131415161718func Decrypt(cipherTxt []byte,key string) []byte &#123; fmt.Println(&quot;???&quot;,cipherTxt) //计算key的总和 var sum =0 for i:=0;i&lt;len(key);i++ &#123; sum += int(key[i]) &#125; //减法运算 for i:=0;i&lt;len(cipherTxt);i++&#123; cipherTxt[i]=cipherTxt[i]-byte(sum) &#125; fmt.Println(&quot;???&quot;,cipherTxt) //去码 var p = PKCS5UnPadding(cipherTxt) return p&#125; 3DES3DES加密DES是一个经典的对称加密算法，但也缺陷明显，即56位的密钥安全性不足，已被证实可以在短时间内破解。为解决此问题，出现了3DES，也称Triple DES，3DES为DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。为了兼容普通的DES，3DES并没有直接使用 加密-&gt;加密-&gt;加密 的方式，而是采用了加密-&gt;解密-&gt;加密 的方式。 当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。 3DES解密3DES解密过程，与加密过程相反，即逆序使用密钥。是以密钥3、密钥2、密钥1的顺序执行 解密-&gt;加密-&gt;解密。 相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hash算法]]></title>
      <url>%2F2018%2F06%2F26%2Fhash%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[什么是 hash 算法散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。 散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。 Hash算法有什么特点一个优秀的 hash 算法，将能实现： 正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。 逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。 输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。 冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。 但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。 几种常见的hash算法 MD5 SHA-1 SHA-2 SHA-256 SHA-512 SHA-3 RIPEMD-160 MD5 加密使用1234567891011121314151617func Md5(data string) &#123; fmt.Println(&quot;-----------Md5-----------&quot;) mes := []byte(data) // 1. 使用系统的包实现 // 密文为16进制的数字 16 *8 = 128位 by := md5.Sum(mes) fmt.Printf(&quot;%x\n&quot;, by) // 2. 第二种写法 m := md5.New() m.Write(mes) //将字节数组转换成字符串 s2:= hex.EncodeToString(m.Sum(nil)) fmt.Println(s2)&#125; Sha256加密使用1234567891011121314151617181920212223242526func Sha256(data string) &#123; fmt.Println(&quot;--------sha256----------&quot;) // 32字节 通用在公链中 32 * 8 = 256 位 // 2. 第一种写法 by := sha256.Sum256([]byte(data)) s := fmt.Sprintf(&quot;%x&quot;, by) fmt.Println(s) // 2. 第二种写法 m := sha256.New() m.Write([]byte(data)) s2 := hex.EncodeToString(m.Sum(nil)) fmt.Println(s2) //对文件中的数据进行加密 file, _ := os.Open(&quot;test.txt&quot;) h := sha256.New() //将file copy到 h中 io.Copy(h, file) resu := h.Sum(nil) fmt.Println(hex.EncodeToString(resu))&#125; rpemd160加密使用12345678910//需要用到三方库 cryptofunc Ripem160(data string) &#123; fmt.Println(&quot;-------Ripem160--------&quot;) rip := ripemd160.New() rip.Write([]byte(data)) res := hex.EncodeToString(rip.Sum(nil)) fmt.Println(res)&#125; md5 实现原理对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476） 四轮循环运算 sha256 实现原理SHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。 附加填充比特：对报文进行填充使报文长度与448 模512 同余（长度=448 mod 512），填充的比特数范围是1 到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个 1，再加很多个0，直到长度 满足 mod 512=448.为什么是448，因为448+64=512. 第二步会加上一个 64bit的 原始报文的 长度信息。 附加长度值 将用64-bit 表示的初始报文（填充前）的位长度附加在步骤1 的结果后（低位字节优先）。 初始化缓存：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。 处理512-bit（16 个字）报文分组序列：该算法使用了六种基本逻辑函数，由64步迭代运算组成。每步都以256-bit 缓存值ABCDEFGH 为输入，然后更新缓存内容。 每步使用一个32-bit 常数值Kt 和一个32-bit Wt。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[slice]]></title>
      <url>%2F2018%2F05%2F04%2Fslice%2F</url>
      <content type="text"><![CDATA[切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。 slice声明和创建slice 本身不是数组，它指向数组的底层作为变长数组饿替代方案，可以关联底层数组的全部或者局部可以直接创建，一般用make(), 也可以从底层数组获取生成如果多个slice 指向相同的底层数组，一个值的改变会影响全部 12345678910111213141516171819202122232425262728293031323334353637383940414243func sliceCreate() &#123; //声明 slice 如果只是声明，只有指针初始地址，容量为0 var slice1 []int fmt.Printf(&quot;slice1 %p\n&quot;, slice1) //添加元素后，容量超出上限，内存地址重新分配 slice1 = []int&#123;1, 2, 3&#125; fmt.Printf(&quot;slice1 %p\n&quot;, slice1) //声明并赋值 var s2 = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; fmt.Println(s2) var arr = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; fmt.Print(&quot;s2 \n&quot;, arr) // 取第二个元素 slice2 := arr[1] fmt.Println(slice2) //取第5到10个元素 slice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间 fmt.Println(slice3) //从第5个元素取到最后 的两种写法 slice4 := arr[5:len(arr)] slice5 := arr[5:] fmt.Println(slice4, slice5) //取前5个元素 slice6 := arr[:5] fmt.Print(&quot;\n&quot;, slice6) //使用make 创建slice //存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍 // 如果不给初始容量，默认的初始容量就是当前元素个数 s1 := make([]int, 3, 10) fmt.Print(&quot;\n&quot;, len(s1), cap(s1))&#125; 输出 12345678910slice1 0x0slice1 0xc4200182c0[a b c]s2 [0 1 2 3 4 5 6 7 8 9]1[5 6 7 8 9][5 6 7 8 9] [5 6 7 8 9][0 1 2 3 4]3 10 ReSlice1234567891011121314151617181920212223func ResliceTest() &#123; // reslice索引 以 被slice 为准 // 索引不可以超过cap值 var a = []byte&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;&#125; // 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间 //取出 cde var s1 = a[2:5] fmt.Println(string(s1)) fmt.Println(len(s1), cap(s1)) //从 s1中取出de var s2 = s1[1:3] fmt.Print(&quot;\n&quot;, string(s2)) // 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾 var s3 = s1[0:cap(s1)] fmt.Print(&quot;\n s3 = &quot;, string(s3))&#125; 12345cde3 6de s3 = cdefgh Append可以在slice尾部追加元素可以将一个slice追加到另一个sliceslice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变1234567891011121314151617181920212223func appendTest() &#123; s1 := make([]int, 3, 6) fmt.Printf(&quot;%p\n&quot;, s1) s1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变 fmt.Printf(&quot;%v---%p\n&quot;, s1, s1) s1 = append(s1, 9) //超出容量，内存地址改变 fmt.Printf(&quot;%v %p\n&quot;, s1, s1) var arr = []int&#123;1, 2, 3, 4, 5&#125; var slice2 = arr[2:5] //3, 4, 5 var slice3 = arr[1:3] //2, 3 fmt.Println(slice2, slice3) //重叠部分是3 slice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变 fmt.Println(arr, slice2, slice3) slice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变 fmt.Println(slice3)&#125; 1234560xc42001c0c0[0 0 0 1 2 3]---0xc42001c0c0[0 0 0 1 2 3 9] 0xc420078060[3 4 5] [2 3][1 2 9 4 5] [9 4 5] [2 9][2 9 1 2 2 2 2 2] Copy12345678910111213141516171819202122func copyTest() &#123; //copy 会把重叠部分的元素给覆盖 var s1 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125; var s2 = []int&#123;7, 8, 9&#125; // 短的copy到长的情况 copy(s1, s2) //把s2 copy 到s1 中 fmt.Println(&quot;s1---&quot;, s1) // 长的copy到短的情况 var s3 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125; var s4 = []int&#123;7, 8, 9&#125; copy(s4, s3) fmt.Println(&quot;s4---&quot;, s4) var s5 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125; var s6 = []int&#123;7, 8, 9&#125; //将制定元素copy到指定位置 copy(s5[2:4], s6[1:3]) fmt.Println(&quot;s5---&quot;, s5)&#125; 123s1--- [7 8 9 4 5 6 7]s4--- [1 2 3]s5--- [1 2 8 9 5 6 7] deletego官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式 12345678910111213func sliceDelete() &#123; var slice = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125; fmt.Println(removeString(slice, 2)&#125;//删除函数func removeString(s []string, i int) []string &#123; return append(s[:i], s[i+1:]...)&#125; 输出 1[a b d] insert官方还是没有提供插入的方法，需要自己实现，如果用append实现，append每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现这里需要引入reflect 1234567891011121314151617181920212223func silceInsert() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; fmt.Println(a) fmt.Println(&quot;插入元素后&quot;, Insert(a, 3, 0)) b := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125; fmt.Println(b) fmt.Println(&quot;插入元素后&quot;, Insert(b, 3, &quot;x&quot;)) c := []interface&#123;&#125;&#123;1, &quot;a&quot;, true, 3.2, &apos;a&apos;&#125; fmt.Println(c) fmt.Println(&quot;插入元素后&quot;, Insert(c, 3, false))&#125;func Insert(slice interface&#123;&#125;, pos int, value interface&#123;&#125;) interface&#123;&#125; &#123; v := reflect.ValueOf(slice) v = reflect.Append(v, reflect.ValueOf(value)) reflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len())) v.Index(pos).Set(reflect.ValueOf(value)) return v.Interface()&#125; 123456[1 2 3 4 5]插入元素后 [1 2 3 0 4 5][a b c d e]插入元素后 [a b c x d e][1 a true 3.2 97]插入元素后 [1 a true false 3.2 97] 排序几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入sort 升序排序对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。 123456789101112func sliceSort() &#123; intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125; sort.Ints(intList) sort.Float64s(float8List) sort.Strings(stringList) fmt.Printf(&quot;%v\n%v\n%v\n&quot;, intList, float8List, stringList)&#125; 123[0 1 2 3 4 5 6 7 8 9][3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9][a b c d f i w x y z] 降序排序int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。 go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写： 1234567891011func sliceSort2() &#123; intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; float8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125; stringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125; sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(float8List))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Printf(&quot;%v\n%v\n%v\n&quot;, intList, float8List, stringList)&#125; 123[9 8 7 6 5 4 3 2 1 0][99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14][z y x w i f d c b a] 结构体类型的排序结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。 1、模拟 IntSlice 排序123456789101112131415161718192021222324252627282930313233343536373839404142package main import ( &quot;fmt&quot; &quot;sort&quot;) type Person struct &#123; Name string Age int&#125; // 按照 Person.Age 从大到小排序type PersonSlice [] Person func (a PersonSlice) Len() int &#123; // 重写 Len() 方法 return len(a)&#125;func (a PersonSlice) Swap(i, j int)&#123; // 重写 Swap() 方法 a[i], a[j] = a[j], a[i]&#125;func (a PersonSlice) Less(i, j int) bool &#123; // 重写 Less() 方法， 从大到小排序 return a[j].Age &lt; a[i].Age&#125; func main() &#123; people := [] Person&#123; &#123;&quot;zhang san&quot;, 12&#125;, &#123;&quot;li si&quot;, 30&#125;, &#123;&quot;wang wu&quot;, 52&#125;, &#123;&quot;zhao liu&quot;, 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonSlice(people)) // 按照 Age 的逆序排序 fmt.Println(people) sort.Sort(sort.Reverse(PersonSlice(people))) // 按照 Age 的升序排序 fmt.Println(people) &#125; 这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。 2、封装成 Wrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package main import ( &quot;fmt&quot; &quot;sort&quot;) type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; //注意此处 people [] Person by func(p, q * Person) bool&#125; func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; func main() &#123; people := [] Person&#123; &#123;&quot;zhang san&quot;, 12&#125;, &#123;&quot;li si&quot;, 30&#125;, &#123;&quot;wang wu&quot;, 52&#125;, &#123;&quot;zhao liu&quot;, 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;&#125;) fmt.Println(people) &#125; 这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。 3、进一步封装感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package main import ( &quot;fmt&quot; &quot;sort&quot;) type Person struct &#123; Name string Age int&#125; type PersonWrapper struct &#123; people [] Person by func(p, q * Person) bool&#125; type SortBy func(p, q *Person) bool func (pw PersonWrapper) Len() int &#123; // 重写 Len() 方法 return len(pw.people)&#125;func (pw PersonWrapper) Swap(i, j int)&#123; // 重写 Swap() 方法 pw.people[i], pw.people[j] = pw.people[j], pw.people[i]&#125;func (pw PersonWrapper) Less(i, j int) bool &#123; // 重写 Less() 方法 return pw.by(&amp;pw.people[i], &amp;pw.people[j])&#125; // 封装成 SortPerson 方法func SortPerson(people [] Person, by SortBy)&#123; sort.Sort(PersonWrapper&#123;people, by&#125;)&#125; func main() &#123; people := [] Person&#123; &#123;&quot;zhang san&quot;, 12&#125;, &#123;&quot;li si&quot;, 30&#125;, &#123;&quot;wang wu&quot;, 52&#125;, &#123;&quot;zhao liu&quot;, 26&#125;, &#125; fmt.Println(people) sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123; return q.Age &lt; p.Age // Age 递减排序 &#125;&#125;) fmt.Println(people) SortPerson(people, func (p, q *Person) bool &#123; return p.Name &lt; q.Name // Name 递增排序 &#125;) fmt.Println(people) &#125; 在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。 4、另一种思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package main import ( &quot;fmt&quot; &quot;sort&quot;) type Person struct &#123; Name string Weight int&#125; type PersonSlice []Person func (s PersonSlice) Len() int &#123; return len(s) &#125;func (s PersonSlice) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125; type ByName struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByName 中 func (s ByName) Less(i, j int) bool &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125; // 将 Less 绑定到 ByName 上 type ByWeight struct&#123; PersonSlice &#125; // 将 PersonSlice 包装起来到 ByWeight 中func (s ByWeight) Less(i, j int) bool &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125; // 将 Less 绑定到 ByWeight 上 func main() &#123; s := []Person&#123; &#123;&quot;apple&quot;, 12&#125;, &#123;&quot;pear&quot;, 20&#125;, &#123;&quot;banana&quot;, 50&#125;, &#123;&quot;orange&quot;, 87&#125;, &#123;&quot;hello&quot;, 34&#125;, &#123;&quot;world&quot;, 43&#125;, &#125; sort.Sort(ByWeight&#123;s&#125;) fmt.Println(&quot;People by weight:&quot;) printPeople(s) sort.Sort(ByName&#123;s&#125;) fmt.Println(&quot;\nPeople by name:&quot;) printPeople(s) &#125; func printPeople(s []Person) &#123; for _, o := range s &#123; fmt.Printf(&quot;%-8s (%v)\n&quot;, o.Name, o.Weight) &#125;&#125; 对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。 取最值这个取最大值和最小值也是需要自己实现, 引入包math123456789101112131415161718192021222324252627func sliceMinMax() &#123; intList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125; fmt.Println(intList) //取最大值 fmt.Println(&quot;maxValue = &quot;, getMaxValue(intList)) //取最小值 fmt.Println(&quot;minValue = &quot;, getMinValue(intList))&#125;func getMaxValue(slice []int) int &#123; var maxValue float64 = float64(slice[0]) for _, v := range slice &#123; maxValue = math.Max(float64(maxValue), float64(v)) &#125; return int(maxValue)&#125;func getMinValue(slice []int) int &#123; var maxValue float64 = float64(slice[0]) for _, v := range slice &#123; maxValue = math.Min(float64(maxValue), float64(v)) &#125; return int(maxValue)&#125; 123[2 4 3 5 7 6 9 8 1 0]maxValue = 9minValue = 0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串操作]]></title>
      <url>%2F2018%2F04%2F26%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[目录本文列举关于字符串最常用的几个操作，都会举例说明 字符串长度 查找 替换 分割 合并 前缀或后缀 截取 删除 插入 编码转换 转换数值类型 大小写转换 Trim操作 ASCII 转换 字符串重复几次 字符或子串在字符串中首次出现的位置或最后一次出现的位置 字符串相关操作需要导入包strings 字符串长度 len() 12345func strLength() &#123; var str = &quot;abc&quot; var length = len(str) fmt.Println(length)&#125; 查找 func Contains(s, substr string) bool 子串substr在s中，返回true func ContainsAny(s, chars string) bool chars中任何一个字符在s中，返回true func ContainsRune(s string, r rune) bool Unicode代码点r在s中，返回true func Count(s, sep string) int sep 在s中重复出现的次数(不计算重叠) func Index(s, sep string) int 在字符串s中查找sep所在的位置, 找不到返回-1 在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。另外，Count 是计算子串在字符串中出现的无重叠的次数 123456789101112131415161718192021222324252627282930313233343536func existSubStringOrChar() &#123; var super = &quot;abcdef!&quot; var suba = &quot;abc&quot; var subb = &quot;ef!&quot; var hasa = existSubString(super, suba) var hasb = existSubChar(super, subb) fmt.Println(hasa, hasb) var s = &quot;fivevev&quot; var sep1 = &quot;vev&quot; var sep2 = &quot;adfd&quot; var c1 = repeatCount(s, sep1) var c2 = repeatCount(s, sep2) fmt.Println(c1, c2)&#125;// 是否存在某个字符或子串func existSubString(superString string, substring string) bool &#123; return strings.Contains(superString, substring)&#125;//substring 是否含有superString 的任意一个字符func existSubChar(superString string, substring string) bool &#123; return strings.ContainsAny(superString, substring)&#125;//substring 的重复出现次数func repeatCount(superString string, substring string) int &#123; return strings.Count(superString, substring)&#125; 结果 12true true1 0 替换 strings.Replace(s, old, new, n) s需要替换的字符串 old需要被替换掉的某个子串 new替换的值n n&lt;0全部替换 n==0不替换 n&gt;0全部替换 如果n的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换 1234567891011func strReplace() &#123; var str = &quot;cabcdefgabc&quot; var value = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, -1) var value1 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 0) var value2 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 1) var value3 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 3) fmt.Println(value, value1, value2, value3) strings.Replace(s, old, new, n)&#125; 结果1cvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc 分割 Fields 和 FieldsFunc Fields 按空格切割 FieldsFunc 按照自己指定的方式切割 实际上，Fields 函数就是调用 FieldsFunc 实现的：123func Fields(s string) []string &#123; return FieldsFunc(s, unicode.IsSpace)&#125; 1234567891011121314151617181920func strCut() &#123; var str = &quot;abc bde efg&quot; var cut1 = strings.Fields(str) var cut2 = strings.FieldsFunc(str, unicode.IsSpace) fmt.Println(cut1, cut2) s := &quot;ab*cd*ef&quot; result := strings.FieldsFunc(s, func(c rune) bool &#123; if c == &apos;h&apos; &#123; return true &#125; return false &#125;) fmt.Println(result)&#125; 结果12[abc bde efg] [abc bde efg][ab*cd*ef] Split 和 SplitAfter、 SplitN 和 SplitAfterN1234func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep,len(sep), n)&#125; 它们都调用了 genSplit 函数。这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(“abc”,””)，得到的是[a b c]。 功能区分：after 会保留分隔符12fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;))fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;)) 输出：12[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;][&quot;foo,&quot; &quot;bar,&quot; &quot;baz&quot;] N的区别N 用来控制分割的个数当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割 fmt.Printf(&quot;%q\n&quot;, strings.SplitN(&quot;foo,bar,baz&quot;, &quot;,&quot;, 2))输出：[&quot;foo&quot; &quot;bar,baz&quot;] 另外看一下官方文档提供的例子，注意一下输出结果：1234fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;)) 输出：1234[&quot;a&quot; &quot;b&quot; &quot;c&quot;][&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;][&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;][&quot;&quot;] split总结关于字符串的分割，最常用的就是Split，其他几乎用不到 合并 将字符串数组（或slice）连接起来可以通过 Join 实现 func Join(a []string, sep string) string 12345678func strJoin() &#123; var arr = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; fmt.Println(arr) // 用 ‘-’ 拼接 fmt.Println(strings.Join(arr, &quot;-&quot;)) // 直接拼接 fmt.Println(strings.Join(arr, &quot;&quot;))&#125; 输出：123[a b c]a-b-cabc 前缀或后缀 123456789101112func presuf() &#123; var str = &quot;abcdefg&quot; //判断开始 var preA = strings.HasPrefix(str, &quot;a&quot;) //判断结尾 var preG = strings.HasSuffix(str, &quot;g&quot;) fmt.Println(preA, preG)&#125; 输出：true true 截取 12345678func subString() &#123; //strings 没有 截取字符串的方法 var str = &quot;abc中国defgh&quot; // 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等 var strArr = string([]rune(str)[:4]) fmt.Println(strArr)&#125; 输出：1abc中 删除 strings 包中没有提供删除的方法，只能自己实现 12345678func deleteStrWithRange(s string, start int, end int) string &#123;if len(s) == 0 || end &gt; len(s) &#123; return &quot;&quot;&#125;var str1 = string([]rune(s)[:start])var str2 = string([]rune(s)[end:])return str1 + str2&#125; 12var sss = deleteStrWithRange(&quot;012345678&quot;, 1, 3)fmt.Println(sss) 输出：0345678 插入 go strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string 编码转换 字符串转换需要用到 strconv Append 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte Format 函数将给定的类型变量转换为string返回 Parse 函数将字符串转换为其他类型 unicode 与 中文 互转12345678910111213141516171819202122func chinaeseToUnicode() &#123; sText := &quot;中文&quot; textQuoted := strconv.QuoteToASCII(sText) fmt.Println(textQuoted) textUnquoted := textQuoted[1 : len(textQuoted)-1] fmt.Println(textUnquoted) sUnicodev := strings.Split(textUnquoted, &quot;\\u&quot;) var context string for _, v := range sUnicodev &#123; if len(v) &lt; 1 &#123; continue &#125; temp, err := strconv.ParseInt(v, 16, 32) if err != nil &#123; panic(err) &#125; context += fmt.Sprintf(&quot;%c&quot;, temp) &#125; fmt.Println(context)&#125; 输出123&quot;\u4e2d\u6587&quot;\u4e2d\u6587中文 转码与解码需要导入包 net/url 123456789101112131415func encodeAndDecode() &#123; var str = &quot;https://www.baidu.com/生活&quot; //转码 var encode = url.QueryEscape(str) fmt.Println(encode) //解码 decodeurl, err := url.QueryUnescape(encode) if err != nil &#123; panic(err) &#125; fmt.Println(decodeurl)&#125; 输出12https%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BBhttps://www.baidu.com/生活 转换数值类型 12345678910111213141516171819202122232425func strToValue() &#123; // int 转 string var intA int = 123 var stringA string = strconv.Itoa(intA) fmt.Println(stringA, reflect.TypeOf(stringA)) // string 转 int var stringB = &quot;45678&quot; intB, err := strconv.Atoi(stringB) if err != nil &#123; panic(err) &#125; fmt.Println(intB, reflect.TypeOf(intB)) // string to float var stringc = &quot;123.45678&quot; floatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64, if err != nil &#123; panic(err) &#125; fmt.Println(floatC, reflect.TypeOf(floatC))&#125; 输出123123 string45678 int123.45678 float64 大小写转换 12345678// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)func Title(s string) string// 所有字母转换为小写func ToLower(s string) string// 所有字母转换为大写func ToUpper(s string) string 12345fmt.Println(strings.Title(&quot;her royal highness&quot;)) // Her Royal Highnessfmt.Println(strings.ToLower(&quot;Gopher123&quot;)) // gopher123fmt.Println(strings.ToUpper(&quot;Gopher&quot;)) // GOPHER Trim操作 bytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。 在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。 func Trim(s string, cutset string) string 去除两边自定义字符 func TrimFunc(s string, f func(rune) bool) string 自定义清除 func TrimLeft(s string, cutset string) string 清除左边 func TrimPrefix(s, prefix string) string 删除前缀 12345678910111213141516171819202122232425func strtrim() &#123; var str = &quot; ads!/ ;&apos; jha asdfhj &quot; // 去除首尾空格，一般这个最常用 var value1 = strings.Trim(str, &quot; &quot;) fmt.Println(value1) //自定义trim fmt.Println(strings.TrimFunc(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, func(r rune) bool &#123; if r == &apos;&amp;&apos; &#123; return true &#125; return false &#125;)) //trim 左侧 &amp; 右侧 fmt.Println(strings.TrimLeft(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;)) fmt.Println(strings.TrimRight(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;)) //去除前缀，后缀也一样 var str2 = &quot;xxx_abcd&quot; if strings.HasPrefix(str2, &quot;xxx_&quot;) &#123; fmt.Println(strings.TrimPrefix(str2, &quot;xxx_&quot;)) &#125;&#125; 输出： 12345ads!/ ;&apos; jha asdfhjnihaonihao&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;nihaoabcd ASCII 转换 123456789101112func strASCII() &#123; //字符转ASCII var c rune = &apos;a&apos; var i1 = int(c) fmt.Println(&quot;&apos;a&apos; convert to ASCII&quot;, i1) //ASCII 转字符 var i int = 98 var c1 = rune(i) fmt.Println(&quot;98 convert to string&quot;, string(c1))&#125; 输出 12&apos;a&apos; convert to ASCII 9798 convert to string b 字符串重复几次 func Repeat(s string, count int) string 123func strRepeatCount() &#123; fmt.Println(strings.Repeat(&quot;a&quot;, 2))&#125; 输出 aa 字符或子串在字符串中首次出现的位置或最后一次出现的位置 4个查找第一次出现的位置// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引func Index(s, sep string) int// chars中任何一个Unicode代码点在s中首次出现的位置func IndexAny(s, chars string) int// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 truefunc IndexFunc(s string, f func(rune) bool) int// Unicode 代码点 r 在 s 中第一次出现的位置func IndexRune(s string, r rune) int 一般用indexAny 3个查找最后一次出现的位置func LastIndex(s, sep string) intfunc LastIndexAny(s, chars string) intfunc LastIndexFunc(s string, f func(rune) bool) int 一般用LastIndexAny就行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[go数组]]></title>
      <url>%2F2018%2F04%2F18%2Fgo%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[数组 在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。 定义数组的格式：var [n]，n&gt;=0 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型 注意区分指向数组的指针和指针数组 数组在Go中为值类型 数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt;(比较的前提是数组个数相同，并且元素类型相同) 可以使用new来创建数组，此方法返回一个指向数组的指针 Go支持多维数组 创建数组123456789101112131415161718192021222324252627func createArr() &#123; // 指定数组长度 // 创建数组如果给定数组长度，数组个数就不能超过这个长度 var arr1 = [5]int&#123;1, 3, 5, 2, 9&#125; fmt.Println(arr1) //不指定数组长度 //Go 语言会根据元素的个数来设置数组的大小 var arr2 = []int&#123;1, 2&#125; var arr3 = [...]int&#123;2, 3, 4&#125; fmt.Println(arr2) fmt.Println(arr3) //创建变量或者常量 可以简写 arr4 := []int&#123;5&#125; fmt.Println(arr4) //初始化对指定元素赋值 //第三个元素 初始化为1 var arr5 = [5]int&#123;3: 1&#125; fmt.Println(arr5) // 获取数组的长度和容量 fmt.Println(len(arr1)) fmt.Println(cap(arr1))&#125; 结果1234567[1 3 5 2 9][1 2][2 3 4][5][0 0 0 1 0]55 编辑数组12345678910111213141516func editArr() &#123; var arr1 = []int&#123;1, 2&#125; fmt.Print(len(arr1), cap(arr1)) fmt.Println(arr1) // 给arr1 添加元素 3，4 var arr2 = append(arr1, 3, 4) fmt.Println(&quot;arr1 = &quot;, arr1) fmt.Println(&quot;arr2 = &quot;, arr2) fmt.Print(len(arr1), cap(arr1)) //改变数组中元素的值 arr1[0] = 9 fmt.Println(arr1)&#125; 结果1232 2[1 2][1 2 3 4]4 4[9 2 3 4] 指针&amp;数组123456789101112func pointArr() &#123; //数组指针 它是一个指针，指向数组的地址 a := []int&#123;5: 1&#125; var p *[]int = &amp;a fmt.Println(a) fmt.Println(p) //比a 多了一个取地址符 // 指针数组 数组里存放的是指针地址，不是实际的值 var x, y = 4, 5 arr := []*int&#123;&amp;x, &amp;y&#125; fmt.Println(arr)&#125; 结果123[0 0 0 0 0 1]&amp;[0 0 0 0 0 1][0xc4200142b0 0xc4200142b8] range遍历数组1234567func rangeArr() &#123; var arr = []int&#123;1, 2, 3, 4, 5&#125; for i, v := range arr &#123; fmt.Println(i, v) &#125;&#125; 结果123450 11 22 33 44 5 new 关键字创建数组1234567891011func newarr() &#123; var a = [5]int&#123;&#125; a[1] = 2 fmt.Println(a) p := new([5]int) //可以通过下标赋值 p[1] = 2 fmt.Println(p)&#125; 结果12[0 2 0 0 0]&amp;[0 2 0 0 0] 数组传递在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝12345678910111213141516func main() &#123; var testArr = [5]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(testArr) modifyarr(testArr) fmt.Println(&quot;In main&quot;, testArr)&#125;func modifyarr(arr [5]int) &#123; arr[0] = 10 fmt.Println(&quot;In modify&quot;, arr)&#125; 结果123[1 2 3 4 5]In modify [10 2 3 4 5]In main [1 2 3 4 5]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac下安装go及环境变量配置]]></title>
      <url>%2F2018%2F04%2F04%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85go%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[以下命令都是直接在根目录下执行即可 方法一：homebrewhomebrew是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装homebrew 安装命令12$ brew update &amp;&amp; brew upgrade$ brew install go 安装完输入 go env 查看环境信息 1234567891011121314151617181920212223GOARCH=&quot;amd64&quot;GOBIN=&quot;&quot;GOCACHE=&quot;/Users/qianjianeng/Library/Caches/go-build&quot;GOEXE=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;darwin&quot;GOOS=&quot;darwin&quot;GOPATH=&quot;/Users/qianjianeng/go&quot;GORACE=&quot;&quot;GOROOT=&quot;/usr/local/Cellar/go/1.10/libexec&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;clang&quot;CXX=&quot;clang++&quot;CGO_ENABLED=&quot;1&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common&quot; 方法二：pkg包安装直接去官方下载安装包，然后双击安装,之后同样地输入go env、go version等查看是否安装。 环境变量配置打开bash_profile$ open .bash_profile 如果不存在创建bash_profile$ vim ~/.bash_profile 添加go环境变量如果是第一种安装方法，只需要指定一下GOPATH即可。为了让自己的程序编译之后在命令行任何地方能直接执行，再加入GOPATH下的bin即可：12345678#This is my personal bash_profile,when loaded at login.#===2015-08-15===#GOPATHexport GOPATH=$HOME/Documents/go_workspace#GOPATH binexport PATH=$PATH:$GOPATH/bin 但是第二种方法安装之后输入go可能会显示ommand not found: go，所以需要在.bash_profile中指定GOROOT下的bin：12345678910111213#This is my personal bash_profile,when loaded at login.#===2015-08-15===#GOROOTexport GOROOT=/usr/local/go#GOPATHexport GOPATH=$HOME/Documents/go_workspace#GOROOT binexport PATH=$PATH:$GOROOT/bin#GOPATH binexport PATH=$PATH:$GOPATH/bin 一般环境变量更改后，重启后生效。在重启终端的时候就会自动执行.bash_profile文件。如果想立刻生效，则可执行下面的语句： $ source .bash_profile 注意如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中： $ open .zshrc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PhotoBatch-图片去重(3)]]></title>
      <url>%2F2017%2F12%2F22%2FPhotoBatch-%E5%9B%BE%E7%89%87%E5%8E%BB%E9%87%8D-3%2F</url>
      <content type="text"><![CDATA[参考资料：http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html 很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。 这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。 另外还找到了其他几种方法，这里是地址http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html 第一步，缩小尺寸。将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。在macOS，使用的是NSImage, 两者的一些操作很类似。12345678910111213141516- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize&#123; NSImage *sourceImage = image; if (![sourceImage isValid])&#123; NSLog(@&quot;Invalid Image&quot;); &#125; else &#123; NSImage *smallImage = [[NSImage alloc] initWithSize: reSize]; [smallImage lockFocus]; [sourceImage setSize: reSize]; [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh]; [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0]; [smallImage unlockFocus]; return smallImage; &#125; return nil;&#125; 第二步，简化色彩。将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。 第三步，计算平均值。计算所有64个像素的灰度平均值。1234567891011121314151617181920212223a[ArrSize] = 0;b[ArrSize] = 0;CGPoint point;for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度 for (j = 0; j &lt; cursize; j++) &#123; point.x = i; point.y = j; grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]); a[cursize * i + j] = grey; a[ArrSize] += grey; &#125;&#125;a[ArrSize] /= (ArrSize - 1);//灰度平均值for (i = 0 ; i &lt; cursize; i++) &#123;//计算b的灰度 for (j = 0; j &lt; cursize; j++) &#123; point.x = i; point.y = j; grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]); b[cursize * i + j] = grey; b[ArrSize] += grey; &#125;&#125;b[ArrSize] /= (ArrSize - 1);//灰度平均值 第四步，比较像素的灰度。将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。123456789101112a[ArrSize] = 0; b[ArrSize] = 0; CGPoint point; for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度 for (j = 0; j &lt; cursize; j++) &#123; point.x = i; point.y = j; grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]); a[cursize * i + j] = grey; a[ArrSize] += grey; &#125; &#125; 第五步，计算哈希值。将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算”汉明距离”（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。 代码实现上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。 这是一个比较耗时的操作，所以放在子线程中操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152NSMutableArray *totalArr = [NSMutableArray array]; __weak __typeof(self)weakSelf = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (NSString *filePath in allFiles) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理文件：%@&quot;, filePath]; &#125;); if (totalArr.count == 0) &#123; NSMutableArray *arr = [NSMutableArray array]; [arr addObject:filePath]; [totalArr addObject:arr]; &#125; else &#123; NSInteger groupCount = [[totalArr mutableCopy] count]; for (int i = 0; i &lt; groupCount; i++) &#123; NSMutableArray *arr = totalArr[i]; NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject]; NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath]; Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb]; if (simi &gt;= 0.9) &#123; //相似度比较接近 [arr addObject:filePath]; break; &#125; else &#123; if (i == [[totalArr mutableCopy] count] - 1) &#123; //已经遍历到最后一组，还没有找到相似图片，新建一组 NSMutableArray *arr = [NSMutableArray array]; [arr addObject:filePath]; @synchronized(totalArr) &#123; [totalArr addObject:arr]; &#125; break; &#125; &#125; &#125; &#125; &#125; NSMutableArray *repeatArr = [NSMutableArray new]; for (NSArray *arr in totalArr) &#123; if (arr.count &gt; 1) &#123; [repeatArr addObject:arr]; &#125; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理完成&quot;]; [self.checkRepeatView buildUIWithImageArr:repeatArr]; &#125;); &#125;); 效果图： demo地址:https://github.com/macOSApp/photoBatch]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PhotoBatch-文件重命名(2)]]></title>
      <url>%2F2017%2F12%2F04%2FPhotoBatch-%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D-2%2F</url>
      <content type="text"><![CDATA[上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名 搭建界面搭了个简单的界面，如下图：我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。 文件夹处理获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以file://开头，需要把前面的file://去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。 123456789101112131415161718192021222324252627282930313233343536373839- (void)dealFiles:(NSArray *)filepaths&#123; self.dealingLabel.stringValue = [filepaths.firstObject description]; NSMutableArray *arr = [NSMutableArray new]; // 对文件夹路径进行处理 for (NSString *path in filepaths) &#123; if ([[path description] hasPrefix:@&quot;file:///&quot;]) &#123; NSString *newpath = [[path description] substringFromIndex:7]; if ([newpath hasSuffix:@&quot;/&quot;]) &#123; newpath = [newpath substringToIndex:newpath.length - 1]; &#125; [arr addObject:newpath]; &#125; else &#123; if ([[path description] hasSuffix:@&quot;/&quot;]) &#123; NSString *tempStr = [path description]; [arr addObject:[tempStr substringToIndex:tempStr.length - 1]]; &#125; else &#123; [arr addObject:[path description]]; &#125; &#125; &#125; self.folderPaths = filepaths; NSMutableArray *allFiles = [NSMutableArray new]; for (NSString *docuPath in self.folderPaths) &#123; // 遍历所有文件夹 获取所有文件个数 NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名 [allFiles addObjectsFromArray:files]; &#125; NSAlert *alert = [[NSAlert alloc] init]; [alert setMessageText:@&quot;文件获取成功&quot;]; [alert setInformativeText:[NSString stringWithFormat:@&quot;文件总数：%ld 个&quot;, allFiles.count]]; [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) &#123; &#125;];&#125; 文件批量重命名遍历所有文件夹下所有文件，NSFileManager 并没有重命名的方法，如果要保留原文件，则执行copy操作，如果不保留原文件，则执行move操作。下面是重命名代码的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (IBAction)StartAction:(NSButton *)sender &#123; NSMutableArray *allFiles = [NSMutableArray new]; for (NSString *docuPath in self.folderPaths) &#123; NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名 for (NSString *filename in files) &#123; [allFiles addObject:[NSString stringWithFormat:@&quot;%@/%@&quot;, docuPath, filename]]; &#125; &#125; if (allFiles.count == 0) &#123; return; &#125; NSString *resultFilePath = [NSString stringWithFormat:@&quot;%@/%@&quot;, self.folderPaths.firstObject, @&quot;result&quot;]; NSError *err = nil; [XCFileManager createDirectoryAtPath:resultFilePath error:&amp;err]; NSString *prefixName = _reNameView.prefixInput.stringValue; if (!prefixName || prefixName.length == 0) &#123; prefixName = @&quot;img_&quot;; &#125; NSString *suffixName = _reNameView.suffixInput.stringValue; if(!suffixName || suffixName.length == 0) &#123; suffixName = @&quot;&quot;; &#125; NSInteger index = 1; NSString *suffix = @&quot;&quot;; for (NSString *path in allFiles) &#123;// // 如果遇到 没有文件名的文件，直接过滤 if ([path componentsSeparatedByString:@&quot;.&quot;].count &lt; 2) &#123; continue; &#125; if (suffixName.length == 0) &#123; suffix = [[path componentsSeparatedByString:@&quot;.&quot;].lastObject description]; &#125; else &#123; suffix = suffixName; &#125; self.dealingLabel.stringValue = [path description]; NSString *movePath = [NSString stringWithFormat:@&quot;%@/%@%ld.%@&quot;, resultFilePath, prefixName, index,suffix]; if (_reNameView.checkSaveBtn.state == 1) &#123; [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO]; &#125; else &#123; [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES]; &#125; index ++; &#125; self.dealingLabel.stringValue = @&quot;处理完成&quot;; &#125; demo地址:https://github.com/macOSApp/photoBatch]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PhotoBatch-文件操作(1)]]></title>
      <url>%2F2017%2F11%2F26%2FPhotoBatch-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1%2F</url>
      <content type="text"><![CDATA[最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。 文件拖拽 需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径 新建 macOS 工程跟新建iOS项目工程几乎一致。 自定义PBDragView在iOS中，最核心的的框架就是Foundation和UIKit, 在macOS中，就是Foundation和AppKit, 对于iOS中大部分控件，都是把前缀又UI换成了NS, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5), 讲述了这两个框架的一些异同。 我们需要自定义一个 PBDragView 继承自NSView，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。 注册支持的文件类型123456789- (void)awakeFromNib&#123; [super awakeFromNib]; // 设置支持的文件类型 [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];&#125;``` #### 实现文件拖动的几个方法 (NSDragOperation)draggingEntered:(id)sender{ if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragEnter)]) { [self.delegate dragEnter]; } return NSDragOperationGeneric;} (void)draggingExited:(id)sender{ if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragExit)]) { [self.delegate dragExit]; }} (BOOL)performDragOperation:(id)sender{ // 获取所有的路径 NSArray *arr = [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType]; if (self.delegate &amp;&amp; arr.count &gt; 0 &amp;&amp; [self.delegate respondsToSelector:@selector(dragFileComplete:)]) { [self.delegate dragFileComplete:arr]; } return YES;} 123456789101112131415161718#### 在SB中使用PBDragView![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。### 文件选择* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹#### 添加点击按钮在SB中添加按钮，然后添加点击事件![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)#### 文件选择功能实现 NSOpenPanel *openPanel = [NSOpenPanel openPanel]; [openPanel setPrompt: @”打开”]; [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹 [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录 [openPanel setCanChooseFiles:YES]; //设置允许打开文件 [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹 [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档 [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档 openPanel.allowedFileTypes = [NSArray arrayWithObjects: @”jpg”, @”doc”,@”txt”,@”jpeg”,@”png”,@”tiff”, nil]; //设置允许打开的文件类型 [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) { NSArray *filePaths = [openPanel URLs]; NSLog(@&quot;-----%@&quot;, filePaths); }];```效果图： demo地址:https://github.com/macOSApp/photoBatch]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gif播放与暂停]]></title>
      <url>%2F2017%2F11%2F14%2FGif%E6%92%AD%E6%94%BE%E4%B8%8E%E6%9A%82%E5%81%9C%2F</url>
      <content type="text"><![CDATA[gif播放的两种方式UIWebView这应该是播放gif文件最简单的方式了，缺点：无法暂停播放 12345678910//1. 把gif文件 转化成 dataguard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;//2. 给UIWebView 设置datalet webview = UIWebView()webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)webview.scalesPageToFit = truewebview.load(gifData as Data, mimeType: &quot;image/gif&quot;, textEncodingName: String(), baseURL: NSURL() as URL)self.view.addSubview(webview) UIImageView这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长 12345678910111213141516171819202122232425262728293031323334353637383940let imageView = UIImageView()imageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)self.view.addSubview(imageView)// 1. 把gif文件 转化成 dataguard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;// 2. 把data 转换成CGImageSource 对象guard let imageSource = CGImageSourceCreateWithData(gifData, nil) else &#123; return &#125;// 2.1 获取图片的个数let imageCount = CGImageSourceGetCount(imageSource)var images = [UIImage]()var gifDuration : TimeInterval = 0// 3. 遍历所有的图片for i in 0..&lt;imageCount &#123; // 3.1 取出图片 guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil) else &#123; return &#125; let image = UIImage(cgImage: cgimage) images.append(image) if (i == 0) &#123; imageView.image = image &#125; // 3.1 取出每张图片持续的时间 guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else &#123; continue &#125; guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else &#123; continue &#125; guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else &#123; continue &#125; gifDuration += imageDuration.doubleValue&#125;// 4.设置images属性imageView.animationImages = imagesimageView.animationDuration = gifDurationimageView.animationRepeatCount = 1// 5. 开始播放imageView.startAnimating() Gif暂停实现]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS三种录制视频方式详细对比]]></title>
      <url>%2F2017%2F03%2F22%2FiOS%E4%B8%89%E7%A7%8D%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91%E6%96%B9%E5%BC%8F%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[先附上参考资料http://www.jianshu.com/p/16cb14f53933 https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html https://github.com/objcio/VideoCaptureDemo https://github.com/gsixxxx/DTSmallVideo https://github.com/AndyFightting/VideoRecord 卷首吐槽语这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。 先附上dome demo地址 脑图方便大家对三中录制方式有一个大概的了解，看一下这张图片。第一种采用系统的录制较为简单，详细介绍后面两种。 效果图 demo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。 1.UIImagePickerController这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)viewDidLoad&#123; [super viewDidLoad]; if ([self isVideoRecordingAvailable]) &#123; return; &#125; self.sourceType = UIImagePickerControllerSourceTypeCamera; self.mediaTypes = @[(NSString *)kUTTypeMovie]; self.delegate = self; //隐藏系统自带UI self.showsCameraControls = NO; //设置摄像头 [self switchCameraIsFront:NO]; //设置视频画质类别 self.videoQuality = UIImagePickerControllerQualityTypeMedium; //设置散光灯类型 self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto; //设置录制的最大时长 self.videoMaximumDuration = 20;&#125;- (BOOL)isVideoRecordingAvailable&#123; if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])&#123; NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera]; if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie])&#123; return YES; &#125; &#125; return NO;&#125;- (void)switchCameraIsFront:(BOOL)front&#123; if (front) &#123; if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront])&#123; [self setCameraDevice:UIImagePickerControllerCameraDeviceFront]; &#125; &#125; else &#123; if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear])&#123; [self setCameraDevice:UIImagePickerControllerCameraDeviceRear]; &#125; &#125;&#125; 2.AVCaptureSession+AVCaptureMovieFileOutput流程：1234561. 创建捕捉会话2. 设置视频的输入3. 设置音频的输入4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据5. 添加视频预览层6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据 0. 创建捕捉会话1234self.session = [[AVCaptureSession alloc] init]; if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率 _session.sessionPreset=AVCaptureSessionPreset640x480; &#125; 1. 视频的输入123456789101112131415161718 - (void)setUpVideo&#123; // 1.1 获取视频输入设备(摄像头) AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头 // 视频 HDR (高动态范围图像) // videoCaptureDevice.videoHDREnabled = YES; // 设置最大，最小帧速率 //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60); // 1.2 创建视频输入源 NSError *error=nil; self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error]; // 1.3 将视频输入源添加到会话 if ([self.session canAddInput:self.videoInput]) &#123; [self.session addInput:self.videoInput]; &#125;&#125; 2. 音频的输入123456789// 2.1 获取音频输入设备 AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject]; NSError *error=nil; // 2.2 创建音频输入源 self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error]; // 2.3 将音频输入源添加到会话 if ([self.session canAddInput:self.audioInput]) &#123; [self.session addInput:self.audioInput]; &#125; 3.输出源设置1234567891011121314151617181920- (void)setUpFileOut&#123; // 3.1初始化设备输出对象，用于获得输出数据 self.FileOutput=[[AVCaptureMovieFileOutput alloc]init]; // 3.2设置输出对象的一些属性 AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo]; //设置防抖 //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持： if ([captureConnection isVideoStabilizationSupported ]) &#123; captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto; &#125; //预览图层和视频方向保持一致 captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation; // 3.3将设备输出添加到会话中 if ([_session canAddOutput:_FileOutput]) &#123; [_session addOutput:_FileOutput]; &#125;&#125; 4. 视频预览层一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。1234567891011121314151617181920 - (void)setUpPreviewLayerWithType:(FMVideoViewType )type&#123; CGRect rect = CGRectZero; switch (type) &#123; case Type1X1: rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth); break; case Type4X3: rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3); break; case TypeFullScreen: rect = [UIScreen mainScreen].bounds; break; default: rect = [UIScreen mainScreen].bounds; break; &#125; self.previewlayer.frame = rect; [_superView.layer insertSublayer:self.previewlayer atIndex:0];&#125; 5. 开始采集画面1[self.session startRunning]; 6.开始录制1234567- (void)writeDataTofile&#123; NSString *videoPath = [self createVideoFilePath]; self.videoUrl = [NSURL fileURLWithPath:videoPath]; [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self]; &#125; 3.AVCaptureSession+AVAssetWriter流程：1234561. 创建捕捉会话2. 设置视频的输入 和 输出3. 设置音频的输入 和 输出4. 添加视频预览层5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。 1. 创建捕捉会话需要确保在同一个队列，最好队列只创建一次1234self.session = [[AVCaptureSession alloc] init]; if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率 _session.sessionPreset=AVCaptureSessionPreset640x480; &#125; 2.设置视频的输入 和 输出1234567891011121314151617181920- (void)setUpVideo&#123; // 2.1 获取视频输入设备(摄像头) AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头 // 2.2 创建视频输入源 NSError *error=nil; self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error]; // 2.3 将视频输入源添加到会话 if ([self.session canAddInput:self.videoInput]) &#123; [self.session addInput:self.videoInput]; &#125; self.videoOutput = [[AVCaptureVideoDataOutput alloc] init]; self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue]; if ([self.session canAddOutput:self.videoOutput]) &#123; [self.session addOutput:self.videoOutput]; &#125; &#125; 3. 设置音频的输入 和 输出12345678910111213141516171819- (void)setUpAudio&#123; // 2.2 获取音频输入设备 AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject]; NSError *error=nil; // 2.4 创建音频输入源 self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error]; // 2.6 将音频输入源添加到会话 if ([self.session canAddInput:self.audioInput]) &#123; [self.session addInput:self.audioInput]; &#125; self.audioOutput = [[AVCaptureAudioDataOutput alloc] init]; [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue]; if([self.session canAddOutput:self.audioOutput]) &#123; [self.session addOutput:self.audioOutput]; &#125; &#125; 4. 添加视频预览层123456789101112131415161718192021 - (void)setUpPreviewLayerWithType:(FMVideoViewType )type&#123; CGRect rect = CGRectZero; switch (type) &#123; case Type1X1: rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth); break; case Type4X3: rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3); break; case TypeFullScreen: rect = [UIScreen mainScreen].bounds; break; default: rect = [UIScreen mainScreen].bounds; break; &#125; self.previewlayer.frame = rect; [_superView.layer insertSublayer:self.previewlayer atIndex:0];&#125; 5. 开始采集画面1[self.session startRunning]; 6. 初始化AVAssetWriterAVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。1234567- (void)setUpWriter&#123; self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]]; self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType]; self.writeManager.delegate = self; &#125; 7.拿到数据流后处理视频数据和音频数据需要分开处理1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection&#123; @autoreleasepool &#123; //视频 if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) &#123; if (!self.writeManager.outputVideoFormatDescription) &#123; @synchronized(self) &#123; CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer); self.writeManager.outputVideoFormatDescription = formatDescription; &#125; &#125; else &#123; @synchronized(self) &#123; if (self.writeManager.writeState == FMRecordStateRecording) &#123; [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo]; &#125; &#125; &#125; &#125; //音频 if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) &#123; if (!self.writeManager.outputAudioFormatDescription) &#123; @synchronized(self) &#123; CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer); self.writeManager.outputAudioFormatDescription = formatDescription; &#125; &#125; @synchronized(self) &#123; if (self.writeManager.writeState == FMRecordStateRecording) &#123; [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio]; &#125; &#125; &#125; &#125; &#125; 我们拿到最原始的数据以后，可以对其进行各种参数的设置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (void)setUpWriter&#123; self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil]; //写入视频大小 NSInteger numPixels = self.outputSize.width * self.outputSize.height; //每像素比特 CGFloat bitsPerPixel = 6.0; NSInteger bitsPerSecond = numPixels * bitsPerPixel; // 码率和帧率设置 NSDictionary *compressionProperties = @&#123; AVVideoAverageBitRateKey : @(bitsPerSecond), AVVideoExpectedSourceFrameRateKey : @(30), AVVideoMaxKeyFrameIntervalKey : @(30), AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel &#125;; //视频属性 self.videoCompressionSettings = @&#123; AVVideoCodecKey : AVVideoCodecH264, AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill, AVVideoWidthKey : @(self.outputSize.height), AVVideoHeightKey : @(self.outputSize.width), AVVideoCompressionPropertiesKey : compressionProperties &#125;; _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings]; //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据 _assetWriterVideoInput.expectsMediaDataInRealTime = YES; _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0); // 音频设置 self.audioCompressionSettings = @&#123; AVEncoderBitRatePerChannelKey : @(28000), AVFormatIDKey : @(kAudioFormatMPEG4AAC), AVNumberOfChannelsKey : @(1), AVSampleRateKey : @(22050) &#125;; _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings]; _assetWriterAudioInput.expectsMediaDataInRealTime = YES; if ([_assetWriter canAddInput:_assetWriterVideoInput]) &#123; [_assetWriter addInput:_assetWriterVideoInput]; &#125;else &#123; NSLog(@&quot;AssetWriter videoInput append Failed&quot;); &#125; if ([_assetWriter canAddInput:_assetWriterAudioInput]) &#123; [_assetWriter addInput:_assetWriterAudioInput]; &#125;else &#123; NSLog(@&quot;AssetWriter audioInput Append Failed&quot;); &#125; self.writeState = FMRecordStateRecording;&#125; 设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。 fileOut和writer的相同点和不同点从上面的两个流程大致可以看出来，相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。不同点：输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。AVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。 可配参数不一致，AVAssetWriter可以配置更多的参数。 视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。 其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。 demo地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[instruments实践]]></title>
      <url>%2F2017%2F01%2F01%2Finstruments%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个”意外”，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的： 第一步：查看dealloc看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。 第二步：查看内存,cpu 我先后两次进入到这个页面，发现刚进入这个页面的瞬间内存飚的很高，然后瞬间又降下来，到这里问题已经变得明显了，这个页面确实存在问题，下面就需要深入的寻找问题所在。 第三步：Profile直接在上图的右上角点击 Profile in instruments,进入instruments后，我还是重复之前的操作，进入这个问题页面，还是发现了内存飙高的情况，然后我在下面的堆栈里找，发现怎么也找不到到底是哪个方法引起的。然后我发现上面的内存图上有条线可以拖动，然后我就把它拖到内存最高的地方，然后再去下面找，发现还是找不到。最后，我尝试在内存飙高的同时，点击左上角暂停运行，然后再下面的堆栈中继续找，这回终于找到了，是我自己的一个类渲染UI的时候导致的内存问题，找到具体的原因，解决起来也就轻松了。光看果然是没有用的，重要的还是要实践。 leak 右侧几个属性选项 Separate by Thread（建议选择） 按照线程分类查看哪些占用cpu最多Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。Hidden System Librares (建议选择) 隐藏系统类库方法Flatten Recursion （一般不选）：选上它会将调用栈里递归函数作为一个入口。Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS数组防止越界crash]]></title>
      <url>%2F2016%2F12%2F24%2FiOS%E6%95%B0%E7%BB%84%E9%98%B2%E6%AD%A2%E8%B6%8A%E7%95%8Ccrash%2F</url>
      <content type="text"><![CDATA[有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。 crash的具体几种情况 取值：index超出array的索引范围 添加：插入的object为nil或者Null 插入：index大于count、插入的object为nil或者Null 删除：index超出array的索引范围 替换：index超出array的索引范围、替换的object为nil或者Null 解决思路任何代码都需要围绕”高内聚，低耦合”的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的demo。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决： 这是系统原本的调用方式 这是改变之后的调用方式 我是先勾住array自带的方法，进行判断，如果没有越界等几种情况，再继续执行它自身的方法，相当于在执行方法前多了一步判断，而网上是直接把方法替换成自己的方法了，这里还是有本质的区别。 具体实现原理这里举例说明 NSArray 的 addObject: 方法，其他也类似。 先定义一个静态变量static IMP array_old_func_imap_object = NULL;这个变量用来记录array自带方法的指针地址 获取方法，然后记录方法的指针地址12Method old_func_imap_object = class_getInstanceMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); array_old_func_imap_object = method_getImplementation(old_func_imap_object); 改变原方法的指针地址，并指向自定义方法method_setImplementation(old_func_imap_object, [self methodForSelector:@selector(fm_objectAtIndex:)]); 自定义方法的实现1234567- (id)fm_objectAtIndex:(NSUInteger)index &#123; if (index &lt; [(NSArray*)self count]) &#123; return ((id(*)(id, SEL, NSUInteger))array_old_func_imap_object)(self, @selector(objectAtIndex:), index); &#125; NSLog(@&quot;NArray objectAtIndex 失败--%@&quot;, [NSThread callStackSymbols]); return nil;&#125; 最后一步到这里已经差不多完成了，就剩最后一个问题了，就是怎么运用到项目中，让这个工具类继承自NSObject，把这个工具类写成一个单例，然后在load方法中调用单例。load 方法会在本类第一次使用的时候调用一次，所以，把这个工具类拖到项目中，不用写其他代码，就实现了以上的功能。12345678910111213+ (void)load &#123; [FMDetecter sharedInstance];&#125;static dispatch_once_t onceToken;static FMDetecter *sharedInstance;+ (instancetype)sharedInstance &#123; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[FMDetecter alloc] init]; &#125;); return sharedInstance;&#125; 这里有完整的代码，有兴趣可查看demo 实际出现的问题我用这两种方式都试了试，新建一个空项目，然后把上面几个方法都试一遍，似乎都没问题，然后我把他们公司的项目中，程序有时候卡死，还会crash，还是没法用，两种方式都有问题，找了找原因，发现NSArray和NSMutableArray的那几个方法，系统自己会调用很多很多次，极大的影响了性能，还有网友遇到了其他的问题：替换了objectAtIndex方法有输入的地方出来了软键盘按手机Home键就Crash了。简直无解，最后，还是决定写个分类，虽然low一点，毕竟还是能解决我的问题，并且不会带来新的问题。 这是给NSArray添加的方法1234567891011#import &quot;NSArray+beyond.h&quot;@implementation NSArray (beyond)-(id)objectAtIndexCheck:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self objectAtIndex:index]; &#125; return nil;&#125;@end 这是给NSMutableArray添加的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &quot;NSMutableArray+beyond.h&quot;@implementation NSMutableArray (beyond)-(id)objectAtIndexCheck:(NSUInteger)index&#123; if (index &lt; self.count) &#123; return [self objectAtIndex:index]; &#125; NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]); return nil;&#125;- (void)addObjectCheck:(id)anObject&#123; if (anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123; [self addObject:anObject]; &#125; else &#123; NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]); &#125;&#125;- (void)insertObjectCheck:(id)anObject atIndex:(NSUInteger)index&#123; if (index &lt;= self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123; [self insertObject:anObject atIndex:index]; &#125; else &#123; NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]); &#125;&#125;- (void)removeObjectAtIndexCheck:(NSUInteger)index&#123; if (index &lt; self.count) &#123; [self removeObjectAtIndex:index]; &#125; else &#123; NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]); &#125;&#125;- (void)replaceObjectAtIndexCheck:(NSUInteger)index withObject:(id)anObject&#123; if (index &lt; self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123; [self replaceObjectAtIndex:index withObject:anObject]; &#125; else &#123; NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]); &#125;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift小结]]></title>
      <url>%2F2016%2F11%2F29%2FSwift%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[懒加载 格式 lazy var 变量: 类型 = { 创建变量代码 }() 以 lazy var 开头，闭包末尾跟一个’()’ 懒加载的写法本质上是定义并执行一个闭包 好处：没有解包的麻烦，并且 延迟创建 与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行懒加载完整的写法：eg:懒加载一个数组 123lazy var dataList: [String] = &#123; () -&gt; [String] in return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]&#125;() in 和 前面的代码块可以省略，写成这样 123lazy var dataList: [String] = &#123; return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]&#125;() 后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了 lazy var dataList: [String] = [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;] 比如懒加载一个label lazy var label: UILabel = UIlabel() 如果对label需要添加其他属性，就可以写成带（）的 123456lazy var label :UILabel = &#123; let label = UILabel() label.font = UIFont.systemFont(ofSize: 15) label.textColor = UIColor.red return label&#125;() extensionswift中一个类只有一个.m文件，所有代码都会写在.m中，代码多了，难免就会混乱，extension 就是用来隔离代码用的。extension最常用的几个地方： 代理方法12extension HomeViewController : UITableViewdelegate,UItableViewDataSource &#123;&#125; 对类的扩展12345678910111213141516171819202122import UIKit//对UIBarButtonItem UIbarButton 的一个扩展extension UIBarButtonItem &#123; // 便利构造函数 convenience init(imageName: String, highImageName: String, size: CGSize = CGSize.zero) &#123; let btn = UIButton(); btn.setImage(UIImage(named: imageName), for: UIControlState()) if(highImageName != &quot;&quot;) &#123; btn.setImage(UIImage(named: highImageName), for: .highlighted) &#125; if size == CGSize.zero &#123; btn.sizeToFit() &#125;else &#123; btn.frame = CGRect(origin: CGPoint.zero, size: size) &#125; self.init(customView: btn) &#125;&#125; 本类中的私有方法extension 外如果想调用extension 内的私有方法，需要加上fileprivate123456789// MARK: - 设置UI界面extension HomeController &#123; fileprivate func setupUI() &#123; setupNavgationbar() &#125; private func setupNavgationbar() &#123; self.navigationItem.leftBarButtonItem = UIBarButtonItem(imageName:&quot;logo&quot;) &#125; Swift宏定义Swift中没有宏的存在，但是有其他实现的方法。而且Swift共享整个命名空间，不在需要.pch文件。新建一个Swfit file文件，最好导入UIKit框架，没有参数的宏直接使用常量定义即可，有参数的宏使用函数代替 无参数的宏1234567891011//oc中的宏定义#define kIOS7 [UIDevice currentDevice].systemVersion.doubleValue&gt;=7.0 ? 1 :0#define kIOS8 [UIDevice currentDevice].systemVersion.doubleValue&gt;=8.0 ? 1 :0#define kScreenHeight [UIScreen mainScreen].bounds.size.height#define kScreenWidth [UIScreen mainScreen].bounds.size.width//转换成Swift的写法let kIOS7 = Double(UIDevice().systemVersion)&gt;=7.0 ? 1 :0let kIOS8 = Double(UIDevice().systemVersion)&gt;=8.0 ? 1 :0let kScreenHeight = UIScreen.mainScreen().bounds.size.heightlet kScreenWidth = UIScreen.mainScreen().bounds.size.width 有参数的宏1234567//oc写法#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]//Swift中的写法func RGBCOLOR(r:CGFloat,_ g:CGFloat,_ b:CGFloat) -&gt; UIColor&#123; return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)&#125; Swift中weakSelf 的 写法第一种 类似OC的写法这里只能用 var 修饰1234weak var weakSelf = selfloadData &#123; (result) in print(weakSelf?.view)&#125; 第二种 Swift推荐的方式123loadData &#123; [weak self] (result) in print(self?.view)&#125; 第三种 不推荐使用[unowned self] 表示{} 中的 所有self 都是 assgined， 不会强引用，但是对象释放，指针地址不会变化12345//相当于 OC __unsafe_unretain // 如果对象被释放，继续调用，就会出现野指针,有极大的安全隐患loadData &#123; [unowned self] (result) in print(self.view) &#125; 单例Swift中单例写法较为简单，并且线程安全123456static let shared: XCRequest = &#123; // 实例化对象 let instance = XCRequest() // 返回对象 return instance &#125;() 还有另外一种写法123456static let instance: XCRequest = XCRequest() class func shareManager() -&gt;XCRequest &#123; return instance &#125; getter&amp;setter模仿OC的写法，事实上Swift不会这么写1234567891011121314151617181920212223var _name: String?var name: String? &#123; get &#123; return _name &#125; set &#123; _name = newValue &#125;&#125; var age:Int&#123; // 如果只重写了get,没有set. 那么属性是一个&quot;计算型&quot;属性 // 计算型属性不占用存储空间, 相当于OC中的readOnly get&#123; return 30 &#125; &#125; // 如果只有get可以简写为 var gender:String&#123; return &quot;lnj&quot; &#125; 计算型属性只有getter，没有setter的属性被称为计算型属性12345var title: String &#123; get &#123; return &quot;Mr &quot; + (name ?? &quot;&quot;) &#125; &#125; 只实现 getter 方法的属性被称为计算型属性，等同于 OC 中的 ReadOnly 属性 计算型属性本身不占用内存空间 不可以给计算型属性设置数值 计算型属性可以使用以下代码简写:123var title: String &#123; return &quot;Mr &quot; + (name ?? &quot;&quot;) &#125; didSetOC中最常见的就是重写setter方法，然后同时做一些额外的事情，那么Swift中就用didSet来实现 12345678var room_list : [[String : NSObject]]? &#123; didSet &#123; guard let room_list = room_list else &#123; return &#125; for dict in room_list &#123; anchors.append(AnchorModel(dict: dict)) &#125; &#125; &#125; 构造函数，析构函数先了解两个概念 方法重载：• 函数名相同，参数名／参数类型／参数个数不同 • 重载函数并不仅仅局限于构造函数 • 函数重载是面相对象程序设计语言的重要标志 • OC 不支持函数重载，OC 的替代方式是 withXXX… 方法重写：• 也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。 • 重写父类方法需要加override • 重写是子类的方法覆盖父类的方法，要求方法名和参数都相同 • 因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。 • 重写必须继承，重载不用 构造函数1234567891011121314151617181920212223class Person: NSObject &#123; var name: String ///最简单的必选属性的构造函数 ///构造函数的目的，给自己分配空间并设置初始值 ///属性的初始化放在super.init前面 /// 重写父类方法需要加override override init () &#123; name = &quot;default name:Tom&quot; super.init() &#125; /// 如果实现了 构造函数的重载，并且没有重写构造函数，那么系统不再提供原始的init()函数 /// 方法重载（类似OC自定义初始化方法） init(name: String) &#123; self.name = name super.init() &#125; &#125; 析构函数相当于OC中的dealloc方法123deinit &#123; print(&quot;被释放了&quot;)&#125; guard let &amp; if let相当于OC中用if来判断某个值是不是为空我认为这个语法最大的好处是避免了写大量的 ？！，用来判断的这个属性必须是可选的guard 与 if 的区别是 guard只有在条件不满足的时候才会执行这段代码123guard let _:String = pe.name else &#123; return&#125; 如果要判断多个参数,一直在后面加123guard let _ = pe.name, let _ = pe.title else &#123; return&#125; if let 可以在条件成立或者不成立的情况下，在{}中分别处理12345if let name = pe.name &#123; print(name) &#125; else &#123; return&#125; asas 的三种情况 as？1. 前面的返回值是可选的 2. guard let / if let 一定用 as? as!1. 前面的返回值一定有值 as1. NSString -&gt; String 2. NSArray -&gt;[ ] 3. NSDictionary -&gt; [ ] 4. 这种情况是因为底层做了结构体和OC对象的桥接 try 处理错误异常12345678910111213141516let jsonSTring = &quot;&#123;\&quot;name\&quot;: \&quot;zhang\&quot;]&quot;let data = jsonSTring.data(using: .utf8)//方法1. 推荐，如果解析成功就有值，否则 为nillet json1 = try? JSONSerialization.jsonObject(with: data!, options: [])print(json1 ?? &quot;json1 为 nil&quot;)//方法2. 墙裂不推荐 如果解析成功就有值，否则crash//let json2 = try! JSONSerialization.jsonObject(with: data!, options: [])//方法3. 异常处理,能够接受错误，可以在错误的情况下另行处理do &#123; let json3 = try JSONSerialization.jsonObject(with: data!, options: []) print(json3)&#125; catch &#123; print(error);&#125; 网络请求GET1234567891011121314151617181920212223242526func getWithPath(path: String,param: Dictionary&lt;String,Any&gt;?,completion: @escaping ((_ result: Any?, _ success:Bool) -&gt; ())) &#123; let url = URL(string: path.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!) if let para = param &#123; //对参数进行处理 print(para) &#125; else &#123; &#125; let session = URLSession.shared let dataTask = session.dataTask(with: url!) &#123; (data, respond, error) in if let data = data &#123; if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments)&#123; completion(result,true) &#125; &#125;else &#123; completion(error,false) &#125; &#125; dataTask.resume() &#125; POST1234567891011121314151617181920212223func postWithPath(path: String,paras: Dictionary&lt;String,Any&gt;?,success: @escaping ((_ result: Any) -&gt; ()),failure: @escaping ((_ error: Error) -&gt; ())) &#123; let url = URL(string: path) var request = URLRequest.init(url: url!) request.httpMethod = &quot;POST&quot; print(path) request.httpBody = path.data(using: .utf8) let session = URLSession.shared let dataTask = session.dataTask(with: request) &#123; (data, respond, error) in if let data = data &#123; if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) &#123; success(result) &#125; &#125;else &#123; failure(error!) &#125; &#125; dataTask.resume() &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swift自动布局]]></title>
      <url>%2F2016%2F11%2F24%2Fswift%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[苹果原生自动布局 自动布局核心公式 view1.attr1 = view2.attr2 * multiplier + constant 自动布局构造函数 12345678NSLayoutConstraint(item: 视图, attribute: 约束属性， relatedBy: 约束关系， toItem: 参照视图, attribute: 参照属性, multiplier:乘积, constant:约束数值) 如果指定 宽 高 约束 参照视图设置为 nil 参照属性选择 .notAnAttribute 自动布局类函数 12345NSLayoutConstraint.constraints(withVisualFormat: VLF公式, options:[], metrics: 约束数值字典[String : 数值], views: 视图字典[String : 子视图] ) VFL 可视化格式化语言 H 水平方向 V 垂直方向 | 边界 [] 包含控件的名称字符串，对应关系在views字典中定义 () 定义控件的宽/高，可以在metrics中指定 tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义刷新控件]]></title>
      <url>%2F2016%2F11%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[一：前言记得工作中第一次用的刷新控件是svpulltorefresh，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是MJRefresh,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致MJRefresh陷入一个死循环，导致不断的刷新，只能重启软件才行。MJRefresh工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的UIRefreshControl我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于UIRefreshControl，我同时也写了一个继承与UIView的control，两个进行对比，发现使用UIview会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。 二: 了解 UIRefreshControl 基本使用方法 123456//初始化一个controlUIRefreshControl *control = [[UIRefreshControl alloc] init];//给control 添加一个刷新方法[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];//把control 添加到 tableView[self.tableView addSubview:control]; 存在的问题 刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果 经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。 自定义控件的思路 去掉默认的动画效果 自定义自己的动画效果 改变满足刷新时的条件 三：FMRefreshControl 先看一下我写完的这个控件的使用方法 123FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];[self.tableView addSubview:control]; 两行代码，用法比系统的还要稍微简单一点。 再看一下效果 四：思路与代码1. 关于 UIRefreshControl 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 superViwe,再执行[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。 2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。3. 进入代码阶段12FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];[self.tableView addSubview:control]; 初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：123456789- (void)willMoveToSuperview:(UIView *)newSuperview &#123; [super willMoveToSuperview:newSuperview]; if ([newSuperview isKindOfClass:[UIScrollView class]]) &#123; self.superScrollView = (UIScrollView *)newSuperview; [self.superScrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil]; &#125;&#125; 这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于UIScrollView，如果是，就用KVO监听contentOffset属性，这样便能知道用户滑动的偏移量。 这里我定义了3种状态：12345typedef NS_ENUM(NSInteger, FMRefreshState) &#123; FMRefreshStateNormal = 0, /** 普通状态 */ FMRefreshStatePulling, /** 释放刷新状态 */ FMRefreshStateRefreshing, /** 正在刷新 */&#125;; 以及切换状态后UI的切换和方法的触发：123456789101112131415161718192021222324252627282930313233- (void)setCurrentStatus:(FMRefreshState)currentStatus &#123; _currentStatus = currentStatus; switch (_currentStatus) &#123; case FMRefreshStateNormal: NSLog(@&quot;切换到Normal&quot;); [self.imageView stopAnimating]; self.label.text = FM_Refresh_normal_title; [self.label sizeToFit]; self.imageView.image = [UIImage imageNamed:@&quot;refresh_1&quot;]; break; case FMRefreshStatePulling: NSLog(@&quot;切换到Pulling&quot;); self.label.text = FM_Refresh_pulling_title; [self.label sizeToFit]; self.imageView.animationImages = self.refreshingImages; self.imageView.animationDuration = 1.5; [self.imageView startAnimating]; break; case FMRefreshStateRefreshing: NSLog(@&quot;切换到Refreshing&quot;); self.label.text = FM_Refresh_Refreshing_title; [self.label sizeToFit]; [self beginRefreshing]; self.imageView.animationImages = self.refreshingImages; self.imageView.animationDuration = 1.5; [self.imageView startAnimating]; [self doRefreshAction]; break; &#125;&#125; 切换到FMRefreshStateNormal 停止动画，切换到FMRefreshStatePulling 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到FMRefreshStateRefreshing，如果此时往回滑动，小于临界值，那么状态重新切回FMRefreshStateNormal。满足刷新条件，则便可执行以下方法：123456789- (void)doRefreshAction&#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if (self.refreshTarget &amp;&amp; [self.refreshTarget respondsToSelector:self.refreshAction]) [self.refreshTarget performSelector:self.refreshAction];#pragma clang diagnostic pop &#125; 下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：123456789101112131415161718192021222324252627282930- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; //isDragging 属性是指用户手指是否在拖动 if (self.superScrollView.isDragging &amp;&amp; !self.isRefreshing) &#123; if (!self.originalOffsetY) &#123; self.originalOffsetY = -self.superScrollView.contentInset.top; &#125; CGFloat normalPullingOffset = self.originalOffsetY - k_FMRefresh_Height; if (self.currentStatus == FMRefreshStatePulling &amp;&amp; self.superScrollView.contentOffset.y &gt; normalPullingOffset) &#123; self.currentStatus = FMRefreshStateNormal; &#125; else if (self.currentStatus == FMRefreshStateNormal &amp;&amp; self.superScrollView.contentOffset.y &lt; normalPullingOffset) &#123; self.currentStatus = FMRefreshStatePulling; &#125; &#125; else if(!self.superScrollView.isDragging)&#123; if (self.currentStatus == FMRefreshStatePulling) &#123; self.currentStatus = FMRefreshStateRefreshing; &#125; &#125; //拖动的偏移量，转换成正数 CGFloat pullDistance = -self.frame.origin.y; self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance); CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width; CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2; self.imageView.frame = CGRectMake(imageViewX, -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height); self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height); &#125; 这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。 还有一种情况，上面也提到过，用户先滑动到FMRefreshStatePulling状态，然后又往回滑动，此时的偏移量在0-FMRefreshStatePulling状态的偏移量之间，此时调用自身的 endRefreshing偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/ 1234567891011121314151617- (void)endRefreshing &#123; if (self.currentStatus != FMRefreshStateRefreshing) &#123; return; &#125; self.currentStatus = FMRefreshStateNormal; [super endRefreshing]; //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if(self.superScrollView.contentOffset.y &gt;= self.originalOffsetY - k_FMRefresh_Height &amp;&amp; self.superScrollView.contentOffset.y &lt;= self.originalOffsetY) &#123; CGPoint offset = self.superScrollView.contentOffset; offset.y = self.originalOffsetY; [self.superScrollView setContentOffset:offset animated:YES]; &#125; &#125;);&#125; 最后还有一点不要忘记 dealloc移除监听：123- (void)dealloc &#123; [self.superScrollView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];&#125; 整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。 domo地址：https://github.com/suifengqjn/FMRefreshControl]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS语音识别]]></title>
      <url>%2F2016%2F11%2F16%2FIOS10%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。 iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。 一：基本配置 Xcode8，iOS10系统真机 导入头文件：OC #import&lt;Speech/Speech.h&gt; swift import Speech 配置info.plist文件:配置两个权限，语音识别和麦克风 12345&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;Your microphone will be used to record your speech when you press the &quot;Start Recording&quot; button.&lt;/string&gt; &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt; &lt;string&gt;Speech recognition will be used to determine which words you speak into this device&apos;s microphone.&lt;/string&gt; 二：用到的几个类AVAudioEngine 语音引擎，负责提供语音输入SFSpeechAudioBufferRecognitionRequest 处理语音识别请求SFSpeechRecognizer 语音识别器SFSpeechRecognitionTask 输出语音识别对象的结果NSLocale 语言类型语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给SFSpeechRecognitionTask处理，最后输出文字。SFSpeechRecognizer 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。12345678910111213141516171819202122232425262728293031//当开始检测音频源中的语音时首先调用此方法-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task&#123; &#125;//当识别出一条可用的信息后 会调用/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription&#123; &#125;//当识别完成所有可用的结果后调用- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult&#123; &#125;//当不再接受音频输入时调用 即开始处理语音识别任务时调用- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task&#123; &#125;//当语音识别任务被取消时调用- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task&#123; &#125;//语音识别任务完成时被调用- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully&#123;&#125; 三：重点代码有两点需要注意： 语音识别会很耗电以及会使用很多数据 语音识别一次只持续大概一分钟的时间 我先定义了这几个属性 12345@property (nonatomic, strong) AVAudioEngine *audioEngine;@property (nonatomic, strong) SFSpeechRecognizer *speechRecognizer;@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest *recognitionRequest;@property (nonatomic, strong) SFSpeechRecognitionTask *recognitionTask;@property (nonatomic, strong) NSLocale *locale; 语音权限的判断 1234567891011121314151617181920212223242526272829[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; BOOL isAuthorized = NO; switch (status) &#123; //结果未知 用户尚未进行选择 case SFSpeechRecognizerAuthorizationStatusNotDetermined: isAuthorized = NO; break; //用户拒绝授权语音识别 case SFSpeechRecognizerAuthorizationStatusDenied: isAuthorized = NO; break; //设备不支持语音识别功能 case SFSpeechRecognizerAuthorizationStatusRestricted: isAuthorized = NO; break; //用户授权语音识别 case SFSpeechRecognizerAuthorizationStatusAuthorized: isAuthorized = YES; break; default: break; &#125; if (callback) &#123; callback(isAuthorized, status); &#125; &#125;]; 将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程 1234AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0]; [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123; [self.recognitionRequest appendAudioPCMBuffer:buffer]; &#125;]; SFSpeechRecognitionTask 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。 123456789101112131415self.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; BOOL isFinal = NO; NSString *bestResult = [[result bestTranscription] formattedString]; isFinal = result.isFinal; if (error || isFinal) &#123; [self endTask]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeFail:)]) &#123; [self.delegate recognizeFail:error]; &#125; &#125; else &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) &#123; [self.delegate recognizeSuccess:bestResult]; &#125; &#125; &#125;]; 四：提取录音文件中的文字 也需要先获取用户的授权，授权代码与上面一致。 对文件的处理相对较为简单12345678910111213141516//初始化一个识别器SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];//初始化mp3的urlNSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];//初始化一个识别的请求SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];//发起请求[recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if(error != nil) &#123; NSLog(@&quot;识别错误:%@&quot;,error); &#125; NSString *resultString = result.bestTranscription.formattedString; NSLog(@&quot;%@&quot;,resultString); &#125;]; github地址：https://github.com/suifengqjn/IOS10Speech]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[runtime详解]]></title>
      <url>%2F2016%2F04%2F16%2Fruntime%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。 最初是在onevcat的博客上看到runtime的runtime的博客，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。 一：基本概念Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。 RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。 OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。 只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。 二：runtime的具体实现我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。每一个oc的方法，底层必然有一个与之对应的runtime方法。 当我们用OC写下这样一段代码[tableView cellForRowAtIndexPath:indexPath]; 在编译时RunTime会将上述代码转化成[发送消息]objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath); 三:常见方法 unsigned int count; 获取属性列表 12345objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count); for (unsigned int i=0; i&lt;count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]); &#125; 获取方法列表 12345Method *methodList = class_copyMethodList([self class], &amp;count);for (unsigned int i; i&lt;count; i++) &#123; Method method = methodList[i]; NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));&#125; 获取成员变量列表 123456Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Ivar myIvar = ivarList[i]; const char *ivarName = ivar_getName(myIvar); NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]); &#125; 获取协议列表 1234567891011 __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count); for (unsigned int i; i&lt;count; i++) &#123; Protocol *myProtocal = protocolList[i]; const char *protocolName = protocol_getName(myProtocal); NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]); &#125; ``` &gt;现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法- 获得类方法 Class PersonClass = object_getClass([Person class]);SEL oriSEL = @selector(test1);Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);12- 获得实例方法 Class PersonClass = object_getClass([xiaoming class]);SEL oriSEL = @selector(test2);Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);1- 添加方法 BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));12- 替换原方法实现 class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));1- 交换两个方法 method_exchangeImplementations(oriMethod, cusMethod);12345678910111213141516171819202122232425262728293031 ### 四：常见作用- 动态的添加对象的成员变量和方法- 动态交换两个方法的实现- 拦截并替换方法- 在方法上增加额外功能- 实现NSCoding的自动归档和解档- 实现字典转模型的自动转换### 五：代码实现要使用runtime，要先引入头文件`#import &lt;objc/runtime.h&gt;`这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。#### 1. 动态变量控制 在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。 ##### 1.动态获取XiaoMing类中的所有属性[当然包括私有] `Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);` ##### 2.遍历属性找到对应name字段 `const char *varName = ivar_getName(var);`##### 3.修改对应的字段值成20 `object_setIvar(self.xiaoMing, var, @&quot;20&quot;);` ##### 4.代码参考 -(void)answer{ unsigned int count = 0; Ivar ivar = class_copyIvarList([self.xiaoMing class], &amp;count); for (int i = 0; i&lt;count; i++) { Ivar var = ivar[i]; const char varName = ivar_getName(var); NSString *name = [NSString stringWithUTF8String:varName]; if ([name isEqualToString:@”_age”]) { object_setIvar(self.xiaoMing, var, @”20”); break; } } NSLog(@”XiaoMing’s age is %@”,self.xiaoMing.age); }123456#### 2.动态添加方法在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？ ##### 1.动态给XiaoMing类中添加guess方法： class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940414243这里参数地方说明一下：&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;&gt;“v@:@@” 意思是，两个参数的没有返回值。 ##### 2.调用guess方法响应事件： [self.xiaoMing performSelector:@selector(guess)];##### 3.编写guessAnswer的实现： void guessAnswer(id self,SEL _cmd)&#123; NSLog(@&quot;i am from beijing&quot;); &#125; 这个有两个地方留意一下：* void的前面没有+、-号，因为只是C的代码。* 必须有两个指定参数(id self,SEL _cmd) ##### 4.代码参考``` -(void)answer&#123; class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;); if ([self.xiaoMing respondsToSelector:@selector(guess)]) &#123; [self.xiaoMing performSelector:@selector(guess)]; &#125; else&#123; NSLog(@&quot;Sorry,I don&apos;t know&quot;); &#125; &#125; void guessAnswer(id self,SEL _cmd)&#123; NSLog(@&quot;i am from beijing&quot;); &#125; 3：动态交换两个方法的实现在程序当中，假设XiaoMing的中有test1 和 test2这两个方法，后来被Runtime交换方法后，每次调动test1 的时候就会去执行test2，调动test2 的时候就会去执行test1， 。那么，Runtime是如何做到的呢？ 1. 获取这个类中的两个方法并交换123Method m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1)); Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2)); method_exchangeImplementations(m1, m2); 交换方法之后，以后每次调用这两个方法都会交换方法的实现 4：拦截并替换方法在程序当中，假设XiaoMing的中有test1这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。 我们先增加一个tool类，然后写一个我们自己实现的方法-change，通过runtime把test1替换成change。 123456789101112131415161718192021222324Class PersionClass = object_getClass([Person class]);Class toolClass = object_getClass([tool class]); ////源方法的SEL和Method SEL oriSEL = @selector(test1); Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL); ////交换方法的SEL和Method SEL cusSEL = @selector(change); Method cusMethod = class_getInstanceMethod(toolClass, cusSEL); ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况 BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod)); if (addSucc) &#123; // 添加成功：将源方法的实现替换到交换方法的实现 class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); &#125;else &#123; //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即method_exchangeImplementations(oriMethod, cusMethod); &#125; 5：在方法上增加额外功能有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决： 12345678910111213141516171819202122232425262728293031@implementation UIButton (Hook)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class selfClass = [self class]; SEL oriSEL = @selector(sendAction:to:forEvent:); Method oriMethod = class_getInstanceMethod(selfClass, oriSEL); SEL cusSEL = @selector(mySendAction:to:forEvent:); Method cusMethod = class_getInstanceMethod(selfClass, cusSEL); BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod)); if (addSucc) &#123; class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); &#125;else &#123; method_exchangeImplementations(oriMethod, cusMethod); &#125; &#125;);&#125;- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; [CountTool addClickCount]; [self mySendAction:action to:target forEvent:event];&#125;@end load方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。 6.实现NSCoding的自动归档和解档如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍encodeObject 和 decodeObjectForKey方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。假设现在有一个Movie类，有3个属性，它的h文件这这样的 12345678910#import &lt;Foundation/Foundation.h&gt;//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding@interface Movie : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *movieId;@property (nonatomic, copy) NSString *movieName;@property (nonatomic, copy) NSString *pic_url;@end 如果是正常写法， m文件应该是这样的： 123456789101112131415161718192021#import &quot;Movie.h&quot;@implementation Movie- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:_movieId forKey:@&quot;id&quot;]; [aCoder encodeObject:_movieName forKey:@&quot;name&quot;]; [aCoder encodeObject:_pic_url forKey:@&quot;url&quot;]; &#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; self.movieId = [aDecoder decodeObjectForKey:@&quot;id&quot;]; self.movieName = [aDecoder decodeObjectForKey:@&quot;name&quot;]; self.pic_url = [aDecoder decodeObjectForKey:@&quot;url&quot;]; &#125; return self;&#125;@end 如果这里有100个属性，那么我们也只能把100个属性都给写一遍。不过你会使用runtime后，这里就有更简便的方法。下面看看runtime的实现方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;Movie.h&quot;#import &lt;objc/runtime.h&gt;@implementation Movie- (void)encodeWithCoder:(NSCoder *)encoder&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([Movie class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出i位置对应的成员变量 Ivar ivar = ivars[i]; // 查看成员变量 const char *name = ivar_getName(ivar); // 归档 NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [encoder encodeObject:value forKey:key]; &#125; free(ivars);&#125;- (id)initWithCoder:(NSCoder *)decoder&#123; if (self = [super init]) &#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([Movie class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出i位置对应的成员变量 Ivar ivar = ivars[i]; // 查看成员变量 const char *name = ivar_getName(ivar); // 归档 NSString *key = [NSString stringWithUTF8String:name]; id value = [decoder decodeObjectForKey:key]; // 设置到成员变量身上 [self setValue:value forKey:key]; &#125; free(ivars); &#125; return self;&#125;@end 这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。我们把encodeWithCoder 和 initWithCoder这两个方法抽成宏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &quot;Movie.h&quot;#import &lt;objc/runtime.h&gt;#define encodeRuntime(A) \\unsigned int count = 0;\Ivar *ivars = class_copyIvarList([A class], &amp;count);\for (int i = 0; i&lt;count; i++) &#123;\Ivar ivar = ivars[i];\const char *name = ivar_getName(ivar);\NSString *key = [NSString stringWithUTF8String:name];\id value = [self valueForKey:key];\[encoder encodeObject:value forKey:key];\&#125;\free(ivars);\\#define initCoderRuntime(A) \\if (self = [super init]) &#123;\unsigned int count = 0;\Ivar *ivars = class_copyIvarList([A class], &amp;count);\for (int i = 0; i&lt;count; i++) &#123;\Ivar ivar = ivars[i];\const char *name = ivar_getName(ivar);\NSString *key = [NSString stringWithUTF8String:name];\id value = [decoder decodeObjectForKey:key];\[self setValue:value forKey:key];\&#125;\free(ivars);\&#125;\return self;\\@implementation Movie- (void)encodeWithCoder:(NSCoder *)encoder&#123; encodeRuntime(Movie)&#125;- (id)initWithCoder:(NSCoder *)decoder&#123; initCoderRuntime(Movie)&#125;@end 我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。 7.实现字典转模型的自动转换字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。 先实现最外层的属性转换 1234567891011121314151617181920212223242526// 创建对应模型对象 id objc = [[self alloc] init]; unsigned int count = 0; // 1.获取成员属性数组 Ivar *ivarList = class_copyIvarList(self, &amp;count); // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值 for (int i = 0; i &lt; count; i++) &#123; // 2.1 获取成员属性 Ivar ivar = ivarList[i]; // 2.2 获取成员属性名 C -&gt; OC 字符串 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 2.3 _成员属性名 =&gt; 字典key NSString *key = [ivarName substringFromIndex:1]; // 2.4 去字典中取出对应value给模型属性赋值 id value = dict[key]; // 获取成员属性类型 NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; &#125; 如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。 内层数组，字典的转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; // 是字典对象,并且属性名对应类型是自定义类型 // 处理类型字符串 @\&quot;User\&quot; -&gt; User ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;]; ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;]; // 自定义对象,并且值是字典 // value:user字典 -&gt; User模型 // 获取模型(user)类对象 Class modalClass = NSClassFromString(ivarType); // 字典转模型 if (modalClass) &#123; // 字典转模型 user value = [modalClass objectWithDict:value]; &#125; &#125; if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel objectWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; 我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 [movie setValuesForKeysWithDictionary:dict]; 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，- (void)setValue:(id)value forUndefinedKey:(NSString *)key 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个id,我们需要把它赋值给uid属性；2. 字典中属性比模型的属性还多的情况。如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。这个方法的实现： 123456- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;id&quot;]) &#123; self.uid = value; &#125;&#125; 六.几个参数概念以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。 1.objc_msgSend 123456789/* Basic Messaging Primitives** On some architectures, use objc_msgSend_stret for some struct return types.* On some architectures, use objc_msgSend_fpret for some float return types.* On some architectures, use objc_msgSend_fp2ret for some float return types.** These functions must be cast to an appropriate function pointer type * before being called. */ 这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用objc_msgSend_stret来发送返回值类型为结构体的消息，使用objc_msgSend_fpret来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。最关键的一点：无论何时，要调用objc_msgSend函数，必须要将函数强制转换成合适的函数指针类型才能调用。从objc_msgSend函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。其实编译器会根据情况在objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。 2.SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:typedef struct objc_selector *SEL;其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。 3.idobjc_msgSend第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：typedef struct objc_object *id;那objc_object又是啥呢：struct objc_object { Class isa; };objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档. 4.Class之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：typedef struct objc_class *Class;objc_class里面的东西多着呢： 123456789101112131415struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改 *methodLists 的值来添加成员方法，这也是Category实现的原理. 上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。demo下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS release,debug版设置不同的AppIcon]]></title>
      <url>%2F2016%2F04%2F13%2FiOS-release-debug%E7%89%88%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84AppIcon%2F</url>
      <content type="text"><![CDATA[也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。 通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。 第一步创建一个新的AppIcon 第二步给两个AppIcon分别加入不同的图片 第三步在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name 第四步分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS公共库]]></title>
      <url>%2F2016%2F04%2F06%2FiOS%E5%85%AC%E5%85%B1%E5%BA%93%2F</url>
      <content type="text"><![CDATA[第一步 打开Xcode，file-&gt;new-&gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库 第二步 file-&gt;new-&gt;project-&gt;Application,创建我们的工程，创建好后关闭工程 第三步 file-&gt;new-&gt;project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework,创建依赖库 第四步 新建一个Tool类，然后在Amy.h里面引入，引入的方式：#import&lt;Amy/Tool.h&gt; 第五步 回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。 第六步 打开workspace，通过 file-&gt; AddFile to 依次把工程和依赖添加到workspace中。 第七步 在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework 第八步 在我们的工程中可以引入依赖使用了。引入方式：#import&lt;Amy/Tool.h&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发小技巧]]></title>
      <url>%2F2016%2F03%2F15%2FiOS%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[iOS开发的一些奇巧淫技,“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips. 如何查看真机沙盒文件一：安装iFunBox或IExployer二：设置在xcode的上部导航栏里，选择window -&gt; Devices,找到目标app,双击选中项目, 这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container,下载后保存到桌面，右键显示包内容即可。 ###如何使用命令行进行打包? 一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。 如果项目没有使用cocoapods:xcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径) 如果使用cocoapods:xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Releasexcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa 二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool） 如果项目没有使用cocoapods:xctool -scheme Demo archive -archivePath “Demo/“(会生成.xcarchive文件)xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa 如果使用cocoapods:xctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath “Demo”xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa Xcode历史版本下载地址https://developer.apple.com/downloads/ 加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)https://developer.apple.com/appstore/contact/appreviewteam/index.html也可以直接从ITunes右下角contact us也可以 但是无法填写相关文字描述 Autolayout及SizeClass示意图 窗口中有多个responder,如何快速释放键盘一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];二：[self.view endEditing:YES];如何去除UITableView中Group样式cell的边框一： UIView *tempView = [[UIView alloc] init]; [cell setBackgroundView:tempView]; [cell setBackgroundColor:[UIColor clearColor]]; 二：tableView.separatorColor=[UIColor clearColor];如何解决colorWithPatternImage设置view背景色太占内存问题 self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”main_landscape.jpg”]]; 切换成self.view.layer.contents =[UIImage imageNamed:@”name.png”].CGImage; App升级后如何删除NSUserDefaults全部数据APP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APPNSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; 如何修改图片颜色先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolorself.imageView.image = [[UIImage imageNamed:@”back”] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];self.imageView.tintColor = [UIColor redColor];也可以在Asset catelog中设置render as 如何放大图片使之不失真且不产生锯齿在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector 如何在拉伸图片的时候使之不变形一：stretchableImageWithLeftCapWidth: topCapHeight:二：在Xcode中选中图片，然后点击右下角的Show Slicing： Storyboard中如何正确设置控件透明度在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。此时应该这样设置 Background →0ther →0pacity [UIScreen mainScreen].bounds获取屏幕大小不对的问题#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)在标准模式下6+：[[UIScreen mainScreen] currentMode].size为{1242，2208}[UIScreen mainScreen].bounds.size为{414，736}6:[[UIScreen mainScreen] currentMode].size为{750，1334}[UIScreen mainScreen].bounds.size为{375，667} 放大模式下(设置-&gt;显示与亮度-&gt;显示模式) 6+:[[UIScreen mainScreen] currentMode].size为{1125,2001}[UIScreen mainScreen].bounds.size为{375,667}6:[[UIScreen mainScreen] currentMode].size为{640,1136}[UIScreen mainScreen].bounds.size为{320,568} Mac模式下如何将视频生成Gif文件一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片（ ffmpeg -i news.mov -r 10 -f image2 文件夹名/%05d.png）然后使用PicGIF (将多张图片生成gif文件)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode多工程联编及工程依赖]]></title>
      <url>%2F2016%2F03%2F12%2FXcode%E5%A4%9A%E5%B7%A5%E7%A8%8B%E8%81%94%E7%BC%96%E5%8F%8A%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96%2F</url>
      <content type="text"><![CDATA[在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。 一:targettarget指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。 target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。 若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。 二:projectxcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。 三:build settings一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。 四:workspaceworkspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。 五:xcode schemexcodescheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。 一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。 六:案例下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project: MyUseStatic，菜单 xocde7 &gt; file &gt; New Workspace 新建一个空的workspace，名字可以随便取。 在左边 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Framework &amp; Library &gt; Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。 在左边的 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Application &gt; Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace &gt; libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。 现在编译 MyUseStatic 会自动先编译依赖的 MyStaticLib。 参考文章：http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory !更多文章可前往我的blog：http://gcblog.github.io]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS缓存机制-非结构化存储]]></title>
      <url>%2F2016%2F03%2F12%2FiOS%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。 它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟NSUserDefaults用法类似。 以下排名按照性能由低到高： 1.EGOCache 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。 2.TMCache 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。 3.PINCache 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。 4.YYCache YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。 YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。 12341. 可以设置缓存上限，设置一定时间内定时清理缓存2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域4. 以上所有参数都可以根据自己的需求自行设置 demo地址 github Blog同步更新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一分钟学会环形进度条]]></title>
      <url>%2F2016%2F02%2F27%2F%E4%B8%80%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
      <content type="text"><![CDATA[有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。先看一下这篇博客，博客地址：http://www.brighttj.com/ios/ios-implement-loop-progress.html这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。 一：先制作一个不带颜色渐变的进度条自定义一个cycleView，在.m 中实现drawRect方法 12345678910111213141516171819- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文 CGPoint center = CGPointMake(100, 100); //设置圆心位置 CGFloat radius = 90; //设置半径 CGFloat startA = - M_PI_2; //圆起点位置 CGFloat endA = -M_PI_2 + M_PI * 2 * _progress; //圆终点位置 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES]; CGContextSetLineWidth(ctx, 10); //设置线条宽度 [[UIColor blueColor] setStroke]; //设置描边颜色 CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文 CGContextStrokePath(ctx); //渲染&#125; 因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 [self setNeedsDisplay]; 这个方法来进行重新绘制，在控制器里面加一个slider，滑动slider来控制进度变化 12345- (void)drawProgress:(CGFloat )progress&#123; _progress = progress; [self setNeedsDisplay];&#125; 看一下效果 如果进度条不需要加渐变色，那么这儿几行代码就完成了。 下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。环形渐变色线条的制作： 第一步使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图 代码实现 12345678910111213141516//生成渐变色 CALayer *gradientLayer = [CALayer layer]; //左侧渐变色 CAGradientLayer *leftLayer = [CAGradientLayer layer]; leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height); // 分段设置渐变色 leftLayer.locations = @[@0.3, @0.9, @1]; leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor]; [gradientLayer addSublayer:leftLayer]; //右侧渐变色 CAGradientLayer *rightLayer = [CAGradientLayer layer]; rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height); rightLayer.locations = @[@0.3, @0.9, @1]; rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor]; [gradientLayer addSublayer:rightLayer]; 这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。 第二步我们需要制作一个环形路径先看一下效果： 代码实现： 12345678910111213141516CGPoint center = CGPointMake(100, 100); CGFloat radius = 90; CGFloat startA = - M_PI_2; //设置进度条起点位置 CGFloat endA = -M_PI_2 + M_PI * 2 * _progress; //设置进度条终点位置 //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形） _progressLayer = [CAShapeLayer layer];//创建一个track shape layer _progressLayer.frame = self.bounds; _progressLayer.fillColor = [[UIColor clearColor] CGColor]; //填充色为无色 _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色 _progressLayer.opacity = 1; //背景颜色的透明度 _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的 _progressLayer.lineWidth = 10;//线的宽度 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形 _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。 [self.layer addSublayer:_progressLayer]; 第三步，也是最后一步了用我们在第二步生成的环形路径去截取第一步生成的渐变层 12[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层self.layer addSublayer:gradientLayer]; 截取的layer层就是我们最后需要的，看一看我们最后截取后得到的 到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。 demo下载地址 更多原创文章可以看 我的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github ssh key 问题]]></title>
      <url>%2F2016%2F02%2F27%2Fgithub%20ssh%20key%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。 我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。 原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS视频边下边播--缓存视频数据流]]></title>
      <url>%2F2016%2F02%2F25%2FiOS%E8%A7%86%E9%A2%91%E8%BE%B9%E4%B8%8B%E8%BE%B9%E6%92%AD-%E7%BC%93%E5%AD%98%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E6%B5%81%2F</url>
      <content type="text"><![CDATA[google搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。 这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。 123用到的框架：&lt;AVFoundation/AVFoundation.h&gt;用到的播放器：AVplayer 先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。 一:下面进入主题产品需求： 1.支持正常播放器的一切功能，包括暂停、播放和拖拽 2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据 3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache 实现方案: 需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。 2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。 3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。 视频播放器需要实现的功能 1.有开始暂停按钮 2.显示播放进度及总时长 3.可以通过拖拽从任意位置开始播放视频 4.视频加载中的过程和加载失败需要有相应的提示 代理对象需要实现的功能 1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据 2.缓存向服务器请求回的数据到本地 3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示 二：具体流程 视频播放器处理流程 1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频 2.如果本地cache中没有视频，则视频播放器向代理请求数据 3.加载视频时展示正在加载的提示（菊花转） 4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示 5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步 代理对象处理流程 1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求 2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现） 3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现） 4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现） 5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache 6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误 7.如果服务器返回其他错误，则代理通知播放器网络错误 三：resourceLoader的难点处理1234567- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest&#123; [self.pendingRequests addObject:loadingRequest]; [self dealWithLoadingRequest:loadingRequest]; return YES;&#125; 播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。 下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。 12345- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest&#123; [self.pendingRequests removeObject:loadingRequest]; &#125; 下面这个方法是对播放器发出的请求进行填充数据 1234567891011121314151617181920212223242526272829303132333435363738- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest&#123; long long startOffset = dataRequest.requestedOffset; if (dataRequest.currentOffset != 0) &#123; startOffset = dataRequest.currentOffset; &#125; if ((self.task.offset +self.task.downLoadingOffset) &lt; startOffset) &#123; //NSLog(@&quot;NO DATA FOR REQUEST&quot;); return NO; &#125; if (startOffset &lt; self.task.offset) &#123; return NO; &#125; NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil]; // This is the total data we have from startOffset to whatever has been downloaded so far NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset); // Respond with whatever is available if we can&apos;t satisfy the request fully yet NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes); [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]]; long long endOffset = startOffset + dataRequest.requestedLength; BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) &gt;= endOffset; return didRespondFully; &#125; 这是对存放所有的请求的数组进行处理 123456789101112131415161718192021- (void)processPendingRequests&#123; NSMutableArray *requestsCompleted = [NSMutableArray array]; //请求完成的数组 //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组 for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests) &#123; [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息 BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全 if (didRespondCompletely) &#123; [requestsCompleted addObject:loadingRequest]; //如果完整，把此次请求放进 请求完成的数组 [loadingRequest finishLoading]; &#125; &#125; [self.pendingRequests removeObjectsInArray:requestsCompleted]; //在所有请求的数组中移除已经完成的 &#125; resourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。 四：难点：对播放器状态的捕获 1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。 2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。 有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态： 123456typedef NS_ENUM(NSInteger, TBPlayerState) &#123; TBPlayerStateBuffering = 1, TBPlayerStatePlaying = 2, TBPlayerStateStopped = 3, TBPlayerStatePause = 4&#125;; 这样可以对播放器更好的把握和处理了。然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码： 123456789101112131415161718192021222324252627- (void)bufferingSomeSecond&#123; // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略 static BOOL isBuffering = NO; if (isBuffering) &#123; return; &#125; isBuffering = YES; // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来 [self.player pause]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 如果此时用户已经暂停了，则不再需要开启播放了 if (self.isPauseByUser) &#123; isBuffering = NO; return; &#125; [self.player play]; // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间 isBuffering = NO; if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) &#123; [self bufferingSomeSecond]; &#125; &#125;);&#125; 这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。 demo下载地址也可以去我的简书博客查看更多文章博客地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS性能监测]]></title>
      <url>%2F2016%2F02%2F25%2FiOS%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[iOS开发中，如果是由于占用内存或者cpu过高导致性能下降，使用Instruments比较容易那些造成性能低下的”罪魁祸首”，在开发测试阶段它可以帮助我们分析软件运行的性能消耗，但是这可定是远远不够的，我们需要一个工具，可以在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题. Time Profiler可以查看多个线程中每个方法的耗时。 对Xcode进行设置1. 不设置该选项，只能看到一堆栈如果想要在TimeProfile中直观的查看方法耗时，需要对Xcode进行设置在Xcode-&gt;Build Setting-&gt;Debug Information Format中设置选项为：DWARF with DSYM File 对TimeProfile进行设置1.在TimeProfile的Call Tree中，右侧面板有三个检查器：record setting（记录设置）、display setting（展示设置）、还有extends detail（扩展详情） 2.我们选择display setting，并在该选择器中勾选Separate by Thread和Hide System Libraries（两个最基本的选项） 3.这样就可以逐级查看每个方法的耗时了 Allocations这里可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置。具体操作是在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。 Leak可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。 UIImage这里要主要是会影响内存的开销，需要权衡下imagedNamed和imageWithContentsOfFile，了解两者特性后，在只需要显示一次的图片用后者，这样会减少内存的消耗，但是页面显示会增加Image IO的消耗，这个需要注意下。由于imageWithContentsOfFile不缓存，所以需要在每次页面显示前加载一次，这个IO的操作也是需要考虑权衡的一个点。 页面加载如果一个页面内容过多，view过多，这样将长页面中的需要滚动才能看到的那个部分视图内容通过开启新的线程同步的加载。 优化首次加载时间通过Time Profier可以查看到启动所占用的时间，如果太长可以通过Heaviest Stack Trace找到费时的方法进行改造。 寻找卡顿的切入点 监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int32_t __CFRunLoopRun()&#123; //通知即将进入runloop __CFRunLoopDoObservers(KCFRunLoopEntry); do &#123; // 通知将要处理timer和source __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); __CFRunLoopDoBlocks(); //处理非延迟的主线程调用 __CFRunLoopDoSource0(); //处理UIEvent事件 //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); // 即将进入休眠 __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); // 等待内核mach_msg事件 mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts(); // Zzz... // 从等待中醒来 __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); // 处理因timer的唤醒 if (wakeUpPort == timerPort) __CFRunLoopDoTimers(); // 处理异步方法唤醒,如dispatch_async else if (wakeUpPort == mainDispatchQueuePort) __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() // UI刷新,动画显示 else __CFRunLoopDoSource1(); // 再次确保是否有同步的方法需要调用 __CFRunLoopDoBlocks(); &#125; while (!stop &amp;&amp; !timeout); //通知即将退出runloop __CFRunLoopDoObservers(CFRunLoopExit);&#125; 不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿. ###量化卡顿的程度 要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下: 1234567891011121314151617static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; MyClass *object = (__bridge MyClass*)info; object-&gt;activity = activity;&#125;- (void)registerObserver&#123; CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);&#125; 只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; PerformanceMonitor *moniotr = (__bridge PerformanceMonitor*)info; moniotr-&gt;activity = activity; dispatch_semaphore_t semaphore = moniotr-&gt;semaphore; dispatch_semaphore_signal(semaphore);&#125;- (void)startMonitor&#123; if (observer) return; // 信号,Dispatch Semaphore保证同步 semaphore = dispatch_semaphore_create(0); // 注册RunLoop状态观察 CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;; observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); //将观察者添加到主线程runloop的common模式下的观察中 CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); // 在子线程监控时长 开启一个持续的loop用来进行监控 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (YES) &#123; //假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms) long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (st != 0) &#123; if (!observer) &#123; timeoutCount = 0; semaphore = 0; activity = 0; return; &#125; //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿 if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting) &#123; if (++timeoutCount &lt; 5) continue; PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]; PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config]; NSData *data = [crashReporter generateLiveReport]; PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL]; NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter withTextFormat:PLCrashReportTextFormatiOS]; //上传服务器 NSLog(@&quot;此处发生卡顿:---%@&quot;, report); &#125;//end activity &#125;// end semaphore wait timeoutCount = 0; &#125;// end while &#125;);&#125; 记录卡顿的函数调用 监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下: 12345678PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];NSData *data = [crashReporter generateLiveReport];PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter withTextFormat:PLCrashReportTextFormatiOS]; 当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑. demo地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用GitHub搭建Hexo博客]]></title>
      <url>%2F2016%2F02%2F23%2FGitHub%2BHexo%2F</url>
      <content type="text"><![CDATA[来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。 概况 为什么选择GitHub Pages1、GitHub Pages有免费的代码托管空间，资料自己管理，保存可靠；2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；3、顺便理解 GitHub 工作原理，最好的团队协作流程；4、GitHub建立私有仓库才会收费，所以会有很多开源代码。 GitHub Pages是什么应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 。 hexo出自何人hexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。 安装准备 环境搭建： Node.js：下载地址 Git：下载地址 Sublime：下载地址安装Node到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi安装GitGit的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\bin之类的，不多说。安装SublimeSublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。 GitHub注册与配置 注册：访问：GitHub，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考官方文档 配置和使用Github以下教程主要参考beiyuu的《使用Github Pages建独立博客》写成。 配置SSH keys我们如何让本地git项目与远程的github建立联系呢？用SSH keys。打开Git Bash工具，执行以下操作 检查SSH keys的设置 123456789101112 首先我们需要检查你电脑上现有的ssh key：$ cd ~/. ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」 然后系统会要你输入密码： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置ssh key了：12 添加SSH Key到GitHub在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 打开本地C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了 测试 1234567891011121314151617181920212223242526 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：$ ssh -T git@github.com 如果是下面的反馈：The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到：Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 设置用户信息： 现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。 GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。$ git config --global user.name &quot;cnfeat&quot;//用户名$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱 SSH Key配置成功，本机已成功连接到github。 Hexo博客 HexoHexo的作者是tommy351，根据官方介绍，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 Hexo Themes。 我比较喜欢 pacman ， modernist 、 ishgo ， raytaylorism 。 安装Hexo打开Git Bash工具（前提确保Node.js已经安装，环境配置OK） $ npm install -g hexo 注释： 执行命令：npm install -g hexo，报错如下： 12345678910111213141516171819202122232425262728293031npm ERR! Error: shasum check failed for C:\Users\ADMINI~1\AppData\Local\Temp\npm-30024-KDJHJzgP\registry.npmjs.org\hexo-cli\-\hexo-cli-0.1.6.tgznpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2npm ERR! Actual: 41de7d67a9b764352eb07c49c32fc38dd7f479b9npm ERR! From: https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgznpm ERR! at d:\Program Files\nodejs\node_modules\npm\node_modules\sha\index.js:38:8npm ERR! at ReadStream.&lt;anonymous&gt; (d:\Program Files\nodejs\node_modules\npm\node_modules\sha\index.js:85:7)npm ERR! at ReadStream.emit (events.js:117:20)npm ERR! at _stream_readable.js:943:16npm ERR! at process._tickCallback (node.js:419:13)npm ERR! If you need help, you may report this *entire* log,npm ERR! including the npm and node versions, at:npm ERR! &lt;http://github.com/npm/npm/issues&gt;npm ERR! System Windows_NT 6.2.9200npm ERR! command &quot;d:\\Program Files\\nodejs\\node.exe&quot; &quot;d:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js&quot; &quot;install&quot; &quot;-g&quot; &quot;hexo&quot;npm ERR! cwd C:\Users\Administrator\Desktopnpm ERR! node -v v0.10.31npm ERR! npm -v 1.4.23npm ERR! registry error parsing jsonnpm ERR!npm ERR! Additional logging details can be found in:npm ERR! C:\Users\Administrator\Desktop\npm-debug.lognpm ERR! not ok code 0 莫非是因为被墙了？换国内镜像源试试。npm config set registry=&quot;http://registry.cnpmjs.org&quot;， 然后再次执行npm install -g hexo，成功！ 部署Hexo123456789101112131415161718192021 在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。$ hexo init 如果无法使用右击“Git Bash”，则可以切换到指定目录 UUhike@UUhike-pc MINGW64 ~$ cd j:/github/hexo UUhike@UUhike-pc MINGW64 /j/github/hexo 安装依赖包$ npm install Hexo随后会自动在目标文件夹建立网站所需要的所有文件。 现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\hexo)，然后到浏览器输入localhost:4000看看。 本地查看$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 部署到GitHub123456789编辑E:\hexo下的_config.yml，修改Deployment部分：# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/luuman/luuman.github.io.git branch: master 注释： hexo d，执行该命令，报错： 1234567891011121314151617181920212223242526272829303132333435ERROR Deployer not found: git执行命令：npm install hexo-deployer-git --save再次执行hexo d,报错：INFO Deploying: gitINFO Clearing .deploy folder...INFO Copying files from public folder...warning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.The file will have its original line endings in your working directory.......*** Please tell me who you are.Run git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;to set your account&apos;s default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got &apos;Administrator@PC-201505290750.(none)&apos;)Username for &apos;https://github.com&apos;: voidkingPassword for &apos;https://voidking@github.com&apos;:error: src refspec master does not match any.error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: error: src refspec master does not match any.error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos; at ChildProcess.&lt;anonymous&gt; (E:\hexo\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:42:17) at ChildProcess.emit (events.js:98:17) at maybeClose (child_process.js:756:16) at Process.ChildProcess._handle.onexit (child_process.js:823:5) hexo d，执行该命令，报错： 复制cnfeat的主题以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。 12345678910111213$ hexo clean$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）建立了Hexo文件，复制我的主题了到themes文件夹中yilia$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yiliamodernist$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernistjacman$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman 启用cnfeat的主题修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。theme: jacman 注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。 更新主题 $ cd themes/jacman $ git pull 注意：为避免出错，请先备份你的_config.yml 文件后再升级本地查看调试 1234567891011121314$ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试或者直接作用组合命令$ hexo deploy -g$ hexo server -g简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 4、浏览器中查看效果 浏览器输入http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。 #进阶篇：Hexo设置 网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。 默认目录结构： 1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json hexo/_config.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #整站的基本信息title: 1000 words a Day #网站标题subtitle: Writing 1000 Words a Day Changes My Life #网站副标题description: 学习总结 思考感悟 知识管理 #网站描述author: cnFeat #网站作者，在下方显示email: cnFeat@gmail.com #联系邮箱language: zh-CN #主题实际的文件名称timezone:# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 日期格式，不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 每页显示文章数，可以自定义，我将10改成了5## Set per_page to 0 to disable paginationper_page: 5pagination_dir: page# Disqus Disqus插件，我们会替换成“多说”，不修改disqus_shortname:# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: spfk# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml# Deployment 站点部署到github要配置，上一节中已经讲过## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: git repository: git@github.com:luuman/luuman.github.io.git branch: master 修改局部页面 页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\主题名称\中： hexo\themes\ 1234567891011121314151617├── languages #多语言| ├── default.yml#默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget#小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css#css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml#主题配置文件└── README.md #用GitHub的都知道 主题文档的配置 hexo\themes/_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔# SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #douban: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# Contentexcerpt_link: morefancybox: truemathjax: true# Miscellaneousgoogle_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar: &quot;&quot;#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: 奥巴马的博客: http://localhost:4000/ 卡卡的美丽传说: http://localhost:4000/ 本泽马的博客: http://localhost:4000/ 吉格斯的博客: http://localhost:4000/ 习大大大不同: http://localhost:4000/ 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货… 参考资料：hexo你的博客如何搭建一个独立博客——简明Github Pages与Hexo教程Hexo的使用介绍Hexo插件安装]]></content>
    </entry>

    
  
  
</search>
